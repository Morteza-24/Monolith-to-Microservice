
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;

import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.user.api.dto.RegistrationTokenDto;
import pt.ist.socialsoftware.edition.user.api.dto.UserConnectionDto;
import pt.ist.socialsoftware.edition.user.api.dto.UserDto;
import pt.ist.socialsoftware.edition.user.domain.*;
import pt.ist.socialsoftware.edition.user.feature.inout.UsersXMLExport;
import pt.ist.socialsoftware.edition.user.feature.inout.UsersXMLImport;
import pt.ist.socialsoftware.edition.user.utils.Emailer;
import pt.ist.socialsoftware.edition.user.utils.UserBootstrap;


import javax.inject.Inject;
import javax.mail.MessagingException;
import javax.servlet.http.HttpServletRequest;
import java.io.ByteArrayInputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api")
public class UserProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(UserProvidesInterface.class);

    @Inject
    private Emailer emailer;

    @GetMapping("/user")
    @Atomic(mode = Atomic.TxMode.READ)
    public UserDto getUser(@RequestParam(name = "username") String username) {
        logger.debug("getUser: " + username);
        //new UserModule();
        User user = UserModule.getInstance().getUser(username);

        return user != null ? new UserDto(user) : null;
    }

    @GetMapping("/registrationToken/{token}")
    @Atomic(mode = Atomic.TxMode.READ)
    public RegistrationTokenDto getRegistrationToken(@PathVariable("token") String token) {
        logger.debug("getRegistrationToken: " + token);
        RegistrationToken registrationToken = UserModule.getInstance().getTokenSet(token);
        return registrationToken != null ? new RegistrationTokenDto(registrationToken) : null;
    }

    @GetMapping("/user/{username}/first")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getFirstName(@PathVariable("username") String username) {
        logger.debug("getFirstName:" + username);
        return getUserByUsername(username).orElse(null).getFirstName();
    }

    @GetMapping("/user/{username}/last")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getLastName(@PathVariable("username") String username) {
        logger.debug("getLastName: " + username);
        return getUserByUsername(username).orElse(null).getLastName();
    }

    @GetMapping("/user/{username}/isEnabled")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isEnabled(@PathVariable("username") String username) {
        logger.debug("isEnabled: " + username);
        return getUserByUsername(username).orElse(null).getEnabled();
    }

    @GetMapping("/user/{username}/isActive")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isActive(@PathVariable("username") String username) {
        logger.debug("isActive: " + username);
        return getUserByUsername(username).orElse(null).getActive();
    }

    @PostMapping("/user/{username}/enabled")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void setUserEnabled(@PathVariable("username") String username, @RequestParam(name = "enabled") boolean enabled) {
        logger.debug("setUserEnabled: " + username + ", " + enabled);
        getUserByUsername(username).orElse(null).setEnabled(enabled);
    }

    @PostMapping("/user/{username}/addRoles")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addRolesToUser(@PathVariable("username") String username, @RequestParam(name = "roleUser") Role.RoleType roleUser) {
        logger.debug("addRolesToUser:" + username + ", " + roleUser);
        getUserByUsername(username).orElse(null).addRoles(Role.getRole(roleUser));
    }

    @GetMapping("/user/{username}/email")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getEmail(@PathVariable("username") String username) {
        logger.debug("getEmail: " + username);
        return getUserByUsername(username).orElse(null).getEmail();
    }

    @GetMapping("/user/{username}/socialMediaId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getSocialMediaId(@PathVariable("username") String username) {
        logger.debug("getSocialMediaId: " +  username);
        return getUserByUsername(username).orElse(null).getSocialMediaId();
    }

    @GetMapping("/users")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<UserDto> getUsersSet() {
        logger.debug("getUsersSet");
        return UserModule.getInstance().getUsersSet().stream().map(UserDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/isAdmin")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean getAdmin() {
        logger.debug("getAdmin");
        return UserModule.getInstance().getAdmin();
    }

    @PostMapping("/updatePassword")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updatePassword(@RequestParam(name = "username") String username, @RequestParam("currentPassword") String currentPassword, @RequestParam("newPassword") String newPassword) {
        logger.debug("updatePassword: " + username);
        getUserByUsername(username).orElseThrow(LdoDException::new)
                .updatePassword(null, currentPassword, newPassword);
    }

    @PostMapping("/setLastLogin")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void setUserLastLogin(@RequestParam(name = "username") String username, @RequestParam(name = "now") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate now) {
        logger.debug("setUserLastLogin: " + username);
        getUserByUsername(username).orElseThrow(() -> new LdoDException("User not found")).setLastLogin(now);
    }

    @GetMapping("/userConnections")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<UserConnectionDto> getUserConnections(@RequestParam(name = "userId") String userId) {
        logger.debug("getUserConnections: " + userId);
        return UserModule.getInstance().getUserConnectionSet().stream().filter(uc -> uc.getUserId().equals(userId)).sorted((uc1, uc2) -> compareByProviderIdAndRank(uc1, uc2)).map(UserConnectionDto::new).collect(Collectors.toList());
    }

    @GetMapping("/userConnectionsByProviderId")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<UserConnectionDto> getUserConnectionsByProviderId(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId) {
        logger.debug("getUserConnectionsByProviderId: " + userId + ", " + providerId);
        return UserModule.getInstance().getUserConnectionSet().stream()
                .filter(uc -> uc.getUserId().equals(userId) && uc.getProviderId().equals(providerId))
                .sorted((uc1, uc2) -> Integer.compare(uc1.getRank(), uc2.getRank()))
                .map(UserConnectionDto::new)
                .collect(Collectors.toList());
    }

    @GetMapping("/userConnectionByUserProviderId")
    @Atomic(mode = Atomic.TxMode.READ)
    public UserConnectionDto getUserConnectionsByUserProviderId(@RequestParam(name = "userId") String userId, @RequestParam(name = "key") String key, @RequestParam(name = "u") String u) {
       // return new UserConnectionDto(UserModule.getInstance().getUserConnection(userId, key, u));
        logger.debug("getUserConnectionsByUserProviderId: " + userId + ", " + key + ", " + u);
        UserConnection uc = UserModule.getInstance().getUserConnection(userId, key, u);
        return  uc != null ? new UserConnectionDto(uc) : null;
    }

    @PostMapping("/createUserConnection")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createUserConnection(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserId") String providerUserId, @RequestParam(name = "nextRank") int nextRank, @RequestParam(name = "displayName") String displayName, @RequestParam(name = "profileUrl") String profileUrl, @RequestParam(name = "imageUrl") String imageUrl, @RequestParam(name = "encrypt") String encrypt, @RequestParam(name = "encrypt1") String encrypt1, @RequestParam(name = "encrypt2") String encrypt2, @RequestParam(name = "expireTime") Long expireTime) {
        logger.debug("createUserConnection: " + userId);
        UserModule.getInstance().createUserConnection(userId, providerId, providerUserId, nextRank, displayName, profileUrl, imageUrl, encrypt, encrypt1, encrypt2, expireTime);
    }

    @PostMapping("/updateUserConnection")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateUserConnection(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserId") String providerUserId, @RequestParam(name = "displayName") String displayName, @RequestParam(name = "profileUrl") String profileUrl, @RequestParam(name = "imageUrl") String imageUrl, @RequestParam(name = "accessToken") String accessToken, @RequestParam(name = "secret") String secret, @RequestParam(name = "refreshToken") String refreshToken, @RequestParam(name = "expireTime") Long expireTime) {
        logger.debug("updateUserConnection: " + userId);
        UserConnection userConnection = UserModule.getInstance().getUserConnection(userId, providerId, providerUserId);
        if (userConnection != null) {
            userConnection.setDisplayName(displayName);
            userConnection.setProfileUrl(profileUrl);
            userConnection.setImageUrl(imageUrl);
            userConnection.setAccessToken(accessToken);
            userConnection.setSecret(secret);
            userConnection.setRefreshToken(refreshToken);
            userConnection.setExpireTime(expireTime);
        }
    }

    @GetMapping("/hasRoleAdmin")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean hasRoleTypeAdmin(@RequestParam(name = "username") String username) {
        logger.debug("hasRoleTypeAdmin: " + username);
        return UserModule.getInstance().getUser(username).getRolesSet().contains(Role.getRole(Role.RoleType.ROLE_ADMIN));
    }

    @GetMapping("/user/{username}/roles")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getRolesFromUser(@PathVariable("username") String username) {
        logger.debug("getRolesFromUser: " + username);
        return UserModule.getInstance().getUser(username).getRolesSet().stream().map(role -> role.getType().name()).collect(Collectors.toList());
    }

    @GetMapping("/userIdsWithConnections")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getUserIdsWithConnections(@RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserId") String providerUserId) {
        logger.debug("getUserIdsWithConnections: " + providerId);
        return UserModule.getInstance().getUserConnectionSet().stream().filter(uc -> uc.getProviderId().equals(providerId)
                && uc.getProviderUserId().equals(providerUserId))
                .map(uc -> uc.getUserId()).collect(Collectors.toList());
    }

    @GetMapping("/userIdsConnectedTo")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getUserIdsConnectedTo(@RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserIds") Set<String> providerUserIds) {
        logger.debug("getUserIdsConnectedTo: " + providerId);
        return UserModule.getInstance().getUserConnectionSet().stream()
                .filter(uc -> uc.getProviderId().equals(providerId) && providerUserIds.contains(uc.getProviderUserId()))
                .map(uc -> uc.getUserId()).collect(Collectors.toSet());
    }

//    @PostMapping("/createUser")
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    public UserDto createUser(@RequestBody PasswordEncoder passwordEncoder, @RequestParam(name = "username") String username, @RequestParam(name = "password") String password, @RequestParam(name = "firstName") String firstName, @RequestParam(name = "lastName") String lastName, @RequestParam(name = "email") String email, @RequestParam(name = "socialMediaServiceForm") String socialMediaServiceForm, @RequestParam(name = "socialMediaId") String socialMediaId) {
//        User.SocialMediaService socialMediaService = socialMediaServiceForm.equals("") ? null
//                : User.SocialMediaService.valueOf(socialMediaServiceForm.toUpperCase());
//        User user = UserModule.getInstance().createUser(passwordEncoder, username, password, firstName, lastName, email, socialMediaService, socialMediaId);
//        return new UserDto(user);
//    }

    @PostMapping("/createUser")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public UserDto createUser(@RequestParam(name = "username") String username, @RequestParam(name = "password") String password, @RequestParam(name = "firstName") String firstName, @RequestParam(name = "lastName") String lastName, @RequestParam(name = "email") String email, @RequestParam(name = "socialMediaServiceForm", required = false) String socialMediaServiceForm, @RequestParam(name = "socialMediaId", required = false) String socialMediaId) {
        logger.debug("createUser: " + username);
        User.SocialMediaService socialMediaService = socialMediaServiceForm != null ? socialMediaServiceForm.equals("") ? null
                : User.SocialMediaService.valueOf(socialMediaServiceForm.toUpperCase()) : null;
        User user = UserModule.getInstance().createUser(username, password, firstName, lastName, email, socialMediaService, socialMediaId);
        return new UserDto(user);
    }

    @PostMapping("/createRegistrationToken")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public RegistrationTokenDto createRegistrationToken(@RequestParam(name = "username") String username, @RequestParam(name = "toString") String toString) {
        logger.debug("createRegistrationToken: " + username + ", " + toString);
        RegistrationToken token = UserModule.getInstance().getUser(username).createRegistrationToken(toString);
        return new RegistrationTokenDto(token);
    }

    private Optional<User> getUserByUsername(String username) {
        return Optional.ofNullable(UserModule.getInstance().getUser(username));
    }

    private int compareByProviderIdAndRank(UserConnection uc1, UserConnection uc2) {
        if (uc1.getProviderId().compareTo(uc2.getProviderId()) != 0) {
            return uc1.getProviderId().compareTo(uc2.getProviderId());
        }
        return Integer.compare(uc1.getRank(), uc2.getRank());
    }

//    @PostMapping("/requestAuthorization")
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    public void requestAuthorization(@RequestParam(name = "token") String token, @RequestBody TokenRequestDto tokenRequestDto) throws MessagingException {
//        UserModule.getInstance().getTokenSet(token).requestAuthorization(tokenRequestDto.getServletRequest(), tokenRequestDto.getEmailer());
//    }

    @PostMapping("/requestAuthorization")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public HashMap<String, String> requestAuthorization(@RequestParam(name = "token") String token, HttpServletRequest httpServletRequest) throws MessagingException {
        logger.debug("requestAuthorization: " + token);
        return UserModule.getInstance().getTokenSet(token).requestAuthorization(httpServletRequest, this.emailer);
    }

    @PostMapping("/setAuthorized")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void setAuthorized(@RequestParam(name = "token") String token, @RequestParam(name = "authorized") boolean authorized) {
        logger.debug("setAuthorized: " + token + ", " + authorized);
        UserModule.getInstance().getTokenSet(token).setAuthorized(authorized);
    }

    @PostMapping("/requestConfirmation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public HashMap<String, String> requestConfirmation(@RequestParam(name = "token") String token, HttpServletRequest httpServletRequest) throws MessagingException {
        logger.debug("requestConfirmation: " + token);
        return UserModule.getInstance().getTokenSet(token).requestConfirmation(httpServletRequest, this.emailer);
    }

    @GetMapping("/registrationToken/{token}/user")
    @Atomic(mode = Atomic.TxMode.READ)
    public UserDto getUserFromRegistrationToken(@PathVariable("token") String token) {
        logger.debug("getUserFromRegistrationToken: " + token);
        return new UserDto(UserModule.getInstance().getTokenSet(token).getUser());
    }

    @PostMapping("/user/{username}/enableUnconfirmed")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void enableUnconfirmedUser(@PathVariable("username") String username) {
        logger.debug("enableUnconfirmedUser: " + username);
        UserModule.getInstance().getUser(username).enableUnconfirmedUser();
    }

    @PostMapping("/switchAdmin")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void switchAdmin() {
        logger.debug("switchAdmin");
        UserModule.getInstance().switchAdmin();
    }

    @GetMapping("/user/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public UserDto getUserFromExternalId(@PathVariable("externalId") String externalId) {
        logger.debug("getUserFromExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof User) {
            return new UserDto((User) domainObject);
        } else {
            return null;
        }
    }

    @GetMapping("/hasRoleUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean hasRoleTypeUser(@RequestParam(name = "username") String username) {
        logger.debug("hasRoleTypeUser: " + username);
        return UserModule.getInstance().getUser(username).getRolesSet().contains(Role.getRole(Role.RoleType.ROLE_USER));
    }

    @PostMapping("/updateUserInfo")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateUserInfo(@RequestParam(name = "username") String username, @RequestParam(name = "oldUsername") String oldUsername, @RequestParam(name = "newUsername") String newUsername, @RequestParam(name = "firstName") String firstName, @RequestParam(name = "lastName") String lastName, @RequestParam(name = "email") String email, @RequestParam(name = "newPassword") String newPassword, @RequestParam(name = "user") boolean user, @RequestParam(name = "admin") boolean admin, @RequestParam(name = "enabled") boolean enabled) {
        logger.debug("updateUserInfo: " + username);
        UserModule.getInstance().getUser(username).update(null, oldUsername, newUsername, firstName, lastName, email, newPassword, user, admin, enabled);
    }

    @PostMapping("/switchUserActive")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void switchUserActive(@RequestParam(name = "username") String username) {
        logger.debug("switchUserActive: " + username);
        UserModule.getInstance().getUser(username).switchActive();
    }

    @DeleteMapping("/removeUser")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeUser(@RequestParam(name = "username") String username) {
        logger.debug("removeUser: " + username);
        UserModule.getInstance().getUser(username).remove();
    }

    @GetMapping("/exportXMLUsers")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportXMLUsers() {
        logger.debug("exportXMLUsers");
        UsersXMLExport generator = new UsersXMLExport();
        return generator.export();
    }

    @PostMapping("/importUsersFromXML")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void importUsersFromXML(@RequestBody byte[] inputStream) {
        logger.debug("importUsersFromXML");
        UsersXMLImport loader = new UsersXMLImport();
        loader.importUsers(new ByteArrayInputStream(inputStream));
    }

    @PostMapping("/createTestUsers")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createTestUsers() {
        logger.debug("createTestUsers");
        UserModule.getInstance().createTestUsers(null);
    }

    @GetMapping("/user/{username}/listOfRoles")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getUserListofRoleAsStrings(@PathVariable("username") String username) {
       logger.debug("getUserListofRoleAsStrings: " + username);
        return UserModule.getInstance().getUser(username).getListOfRolesAsStrings();
    }

    @GetMapping("/user/{username}/lastLogin")
    @Atomic(mode = Atomic.TxMode.READ)
    public LocalDate getUserLastLogin(@PathVariable("username") String username) {
        logger.debug("getUserLastLogin: " + username);
        return UserModule.getInstance().getUser(username).getLastLogin();
    }

    @DeleteMapping("/removeAllUserConnectionsByProviderId")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeAllUserConnectionsByProviderId(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId) {
        logger.debug("removeAllUserConnectionsByProviderId: " + userId);
        Set<UserConnection> userConnections = UserModule.getInstance().getUserConnectionSet();
        Set<UserConnection> toRemoveUserConnections = userConnections.stream()
                .filter(uc -> uc.getUserId().equals(userId) && uc.getProviderId().equals(providerId))
                .collect(Collectors.toSet());
        userConnections.removeAll(toRemoveUserConnections);
    }

    @DeleteMapping("/removeAllUserConnectionsByConnectionKey")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeAllUserConnectionsByConnectionKey(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserId") String providerUserId) {
        logger.debug("removeAllUserConnectionsByConnectionKey: " + userId);
        Set<UserConnection> userConnections = UserModule.getInstance().getUserConnectionSet();
        Set<UserConnection> toRemoveUserConnections = userConnections.stream()
                .filter(uc -> uc.getUserId().equals(userId) && uc.getProviderId().equals(providerId)
                        && uc.getProviderUserId().equals(providerUserId))
                .collect(Collectors.toSet());
        userConnections.removeAll(toRemoveUserConnections);
    }

    @GetMapping("/role/{role}")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getRoleName(@PathVariable("role") String role) {
        logger.debug("getRoleName: " + role);
        if (role.equals("Admin")) {
           return Role.RoleType.ROLE_ADMIN.name();
        } else {
           return Role.RoleType.ROLE_USER.name();
        }
    }

    @PostMapping("/initializeUserModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public boolean initializeUserModule() {
        logger.debug("initializeUserModule");
       return UserBootstrap.initializeUserModule();
    }

    // Testing purposes
    @PostMapping("/createTestUser")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public UserDto createTestUser(@RequestParam(name = "username") String username, @RequestParam(name = "password") String password, @RequestParam(name = "firstName") String firstName, @RequestParam(name = "lastName") String lastName, @RequestParam(name = "email") String email) {
        logger.debug("createTestUser: " + username);
        return new UserDto(new User(UserModule.getInstance(), username, password, firstName, lastName, email));
    }

    @GetMapping("/getTokensSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<RegistrationTokenDto> getTokensSet() {
        logger.debug("getTokensSet");
        return UserModule.getInstance().getTokenSet().stream().map(RegistrationTokenDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/removeOutdatedUnconfirmedUsers")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeOutdatedUnconfirmedUsers() {
        logger.debug("removeOutdatedUnconfirmedUsers");
        UserModule.getInstance().removeOutdatedUnconfirmedUsers();
    }

    @GetMapping("/user/{username}/token")
    @Atomic(mode = Atomic.TxMode.READ)
    public RegistrationTokenDto getTokenFromUsername(@PathVariable("username") String username) {
        logger.debug("getTokenFromUsername: " + username);
        return new RegistrationTokenDto(getUserByUsername(username).orElse(null).getToken());
    }

    @GetMapping("/getUserConnectionSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<UserConnectionDto> getUserConnectionSet() {
        logger.debug("getUserConnectionSet");
        return UserModule.getInstance().getUserConnectionSet().stream().map(UserConnectionDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/removeUserConnection")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeUserConnection(@RequestParam(name = "userId") String userId, @RequestParam(name = "providerId") String providerId, @RequestParam(name = "providerUserId") String providerUserId) {
        logger.debug("removeUserConnection: " + userId);
        UserConnection userConnection = UserModule.getInstance().getUserConnection(userId, providerId, providerUserId);
        userConnection.remove();
    }

    @PostMapping("/removeToken")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeToken(@RequestParam(name = "token") String token) {
       logger.debug("removeToken: " + token);
        UserModule.getInstance().getTokenSet(token);
    }

    @PostMapping("/removeUserModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeUserModule() {
        logger.debug("removeUserModule");
        UserModule userModule = UserModule.getInstance();
        if (userModule != null) {
            userModule.remove();
        }
    }

    @PostMapping("/token/{token}/updateExpireTimeDateTime")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateExpireTimeDateTime(@PathVariable("token") String token, @RequestParam(name = "i") int i, @RequestParam(name = "i1") int i1, @RequestParam(name = "i2") int i2, @RequestParam(name = "i3") int i3, @RequestParam(name = "i4") int i4, @RequestParam(name = "i5") int i5, @RequestParam(name = "i6") int i6) {
        UserModule.getInstance().getTokenSet(token).setExpireTimeDateTime(new DateTime(i, i1, i2, i3, i4, i5, i6));
    }

}


import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import pt.ist.socialsoftware.edition.notification.event.Event;

import javax.jms.Queue;
import javax.jms.Topic;

@Component
public class UserEventPublisher {
    private static final Logger logger = LoggerFactory.getLogger(UserEventPublisher.class);


    @Autowired
    private final Topic queue = new ActiveMQTopic("test-topic");

    @Autowired
    private JmsTemplate jmsTemplate;


    @GetMapping("/publishEvent")
    public ResponseEntity<Event> publishEvent(Event event){
        jmsTemplate.convertAndSend(queue, event);
        System.out.println("published Event!");
        return new ResponseEntity(event, HttpStatus.OK);
    }
}


import pt.ist.socialsoftware.edition.user.api.UserProvidesInterface;
import pt.ist.socialsoftware.edition.user.domain.UserConnection;

public class UserConnectionDto {

    private final UserProvidesInterface userProvidesInterface = new UserProvidesInterface();

    private String userId;
    private String providerId;
    private String providerUserId;
    private String displayName;
    private String profileUrl;
    private String imageUrl;
    private String accessToken;
    private String secret;
    private String refreshToken;
    private long expireTime;
    private int rank;

    public UserConnectionDto(UserConnection userConnection) {
        this.userId = userConnection.getUserId();
        this.providerId = userConnection.getProviderId();
        this.providerUserId = userConnection.getProviderUserId();
        this.displayName = userConnection.getDisplayName();
        this.profileUrl = userConnection.getProfileUrl();
        this.imageUrl = userConnection.getImageUrl();
        this.accessToken = userConnection.getAccessToken();
        this.secret = userConnection.getSecret();
        this.refreshToken = userConnection.getRefreshToken();
        this.expireTime = userConnection.getExpireTime();
        this.rank = userConnection.getRank();
    }

    public String getUserId() {
        return userId;
    }

    public String getProviderId() {
        return providerId;
    }

    public String getProviderUserId() {
        return providerUserId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getProfileUrl() {
        return profileUrl;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public String getSecret() {
        return secret;
    }

    public String getRefreshToken() {
        return refreshToken;
    }

    public long getExpireTime() {
        return expireTime;
    }

    public int getRank() {
        return rank;
    }

    public void updateUserConnection(String displayName, String profileUrl, String imageUrl, String accessToken, String secret, String refreshToken, Long expireTime) {
        this.userProvidesInterface.updateUserConnection(this.userId, this.providerId, this.providerUserId, displayName, profileUrl, imageUrl, accessToken, secret, refreshToken, expireTime);
    }
}



import pt.ist.socialsoftware.edition.user.domain.User;


public class UserDto {

    private String username;

    // cached attributes
    private String firstName;

    private String lastName;

    private boolean isEnabled;

    private boolean isActive;

    private String socialMedalId;

    private String externalId;

    private String password;

    private String email;

    public UserDto(String username) {
        setUsername(username);
    }

    public UserDto(User user) {
        setUsername(user.getUsername());
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
        this.isEnabled = user.getEnabled();
        this.isActive = user.getActive();
        this.socialMedalId = user.getSocialMediaId();
        this.externalId = user.getExternalId();
        this.password = user.getPassword();
        this.email = user.getEmail();
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getFirstName() {
        //return this.userProvidesInterface.getFirstName(this.username);
        return this.firstName;
    }

    public String getLastName() {
        //return this.userProvidesInterface.getLastName(this.username);
        return this.lastName;
    }

    public boolean isEnabled() {
        //return this.userProvidesInterface.isEnabled(this.username);
        return this.isEnabled;
    }

    public boolean isActive() {
        //return this.userProvidesInterface.isActive(this.username);
        return this.isActive;
    }

    public String getSocialMediaId() {
       //return this.userProvidesInterface.getSocialMediaId(this.username);
       return this.socialMedalId;
    }

    public String getPassword() {
        return this.password;
    }

    public String getExternalId() {
        return this.externalId;
    }

    public String getEmail() {
        return email;
    }

}


import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.DateTime;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeSerializer;
import pt.ist.socialsoftware.edition.user.domain.RegistrationToken;


public class RegistrationTokenDto {

    private String token;
    private DateTime expireTimeDateTime;
    private boolean authorized;

    public RegistrationTokenDto(RegistrationToken registrationToken) {
        this.token = registrationToken.getToken();
        this.expireTimeDateTime = registrationToken.getExpireTimeDateTime();
        this.authorized = registrationToken.getAuthorized();
    }

    public String getToken() {
        return this.token;
    }

    @JsonSerialize(using = CustomDateTimeSerializer.class)
    public DateTime getExpireTimeDateTime() {
        return expireTimeDateTime;
    }

    public boolean isAuthorized() {
        return authorized;
    }

}


import pt.ist.socialsoftware.edition.user.domain.Role;
import pt.ist.socialsoftware.edition.user.domain.User;
import pt.ist.socialsoftware.edition.user.domain.UserModule;

public class UserBootstrap {

    public static boolean initializeUserModule() {

        boolean userCreate = false;
        if (UserModule.getInstance() == null) {
            new UserModule();
            UserModule.getInstance().setAdmin(true);
            createUsersAndRoles();
            userCreate = true;
        }
        return userCreate;
    }

    private static void createUsersAndRoles() {
        UserModule userModule = UserModule.getInstance();

        Role user = Role.getRole(Role.RoleType.ROLE_USER);
        Role admin = Role.getRole(Role.RoleType.ROLE_ADMIN);

        // the bcrypt generator
        // https://www.dailycred.com/blog/12/bcrypt-calculator
        User ars = new User(userModule, User.USER_ARS, "$2a$11$Y0PQlyE20CXaI9RGhtjZJeTM/0.RUyp2kO/YAJI2P2FeINDEUxd2m",
                "António", "Rito Silva", "rito.silva@tecnico.ulisboa.pt");

        User twitter = new User(userModule, "Twitter", null, User.USER_TWITTER, "Social Media", "");

        // User diego = new User(ldod, "diego",
        // "$2a$11$b3rI6cl/GOzVqOKUOWSQQ.nTJFn.s8a/oALV.YOWoUZu6HZGvyCXu",
        // "Diego", "Giménez", "dgimenezdm@gmail.com");
        // User mp = new User(ldod, "mp",
        // "$2a$11$Nd6tuFTBZV3ej02xJcJhUOZtHKsc888UOBXFz9jDYDBs/EHQIIP26", "Manuel",
        // "Portela", "mportela@fl.uc.pt");
        // User tiago = new User(ldod, "tiago",
        // "$2a$11$GEa2gLrEweOV5b.fzTi5ueg.s9h2wP/SmRUt2mCvU.Ra7BxgkPVci",
        // "Tiago", "Santos", "tiago@tiagosantos.me");
        // User nuno = new User(ldod, "nuno",
        // "$2a$11$ICywhcOlcgbkWmi2zxYRi./AjLrz4Vieb25TBUeK3FsMwYmSPTcMu",
        // "Nuno", "Pinto", "nuno.mribeiro.pinto@gmail.com");
        // User luis = new User(ldod, "luis",
        // "$2a$11$c0Xrwz/gw0tBoMo3o1AG3.boCszoGOXyDWZ5z2vSY259/RDLK4ZDi",
        // "Luís", "Lucas Pereira", "lmlbpereira@gmail.com");
        // User andre = new User(ldod, "afs",
        // "$2a$11$na24dttCBjjT5uVT0mBCb.MlDdCGHwu3w6tRTqf5OD9QAsIPYJzfu",
        // "André", "Santos", "andrefilipebrazsantos@gmail.com");
        // User daniela = new User(ldod, "daniela",
        // "$2a$04$QiGbDnmoyrvyFnJdfsHhSeJoWJkjVkegrIpIADcIBVziVYWPHnPpC",
        // "Daniela", "Maduro", "cortesmaduro@hotmail.com");
        // User joana = new User(ldod, "joana",
        // "$2a$12$tdXO4XfyDP0BdrvGyScv9uRHjDPitbwKzpU1eepeJxgzZFnXZczLq",
        // "Joana", "Malta", "joanavmalta@gmail.com");
        // User bernardosoares = new User(ldod, "bernardosoares",
        // "$2a$04$2romaiXNBOFcVpDrcg0Miepy7AeeBGJq4jc4EdRA/EFekYxSFxTsC", "Bernardo",
        // "Soares",
        // "bernardosoares@pessoa.pt");
        // User rita = new User(ldod, "rita",
        // "$2a$12$6UbQBZNy0s2LQnQjaPe2au645FF.gEC7/RF5Xv9P8bdAhJo.fugoa",
        // "Rita", "Marrone", "bernardosoares@pessoa.pt");
        // User osvaldo = new User(ldod, "osvaldo",
        // "$2a$12$5WFTqOwTFfhPEeJ.L2Dbk.qvbCArQCSkcp7DdeUkrxj3dX2XT827e",
        // "Osvaldo", "Silvestre", "omsilvestre@gmail.com");
        // User jose = new User(ldod, "jose",
        // "$2a$12$gqbtKFUkIS8hqALVuc/h3eETWIWeQgxmPiWK9fm3joROsZRYHDkiW",
        // "José Maria", "Cunha", "z@josemariacunha.com");

        ars.setEnabled(true);
        ars.addRoles(user);
        ars.addRoles(admin);

        twitter.setActive(false);
        twitter.setEnabled(true);
        // diego.setEnabled(true);
        // diego.addRoles(user);
        // diego.addRoles(admin);
        //
        // mp.setEnabled(true);
        // mp.addRoles(user);
        // mp.addRoles(admin);
        //
        // tiago.setEnabled(true);
        // tiago.addRoles(user);
        // tiago.addRoles(admin);
        //
        // nuno.setEnabled(true);
        // nuno.addRoles(user);
        // nuno.addRoles(admin);
        //
        // luis.setEnabled(true);
        // luis.addRoles(user);
        // luis.addRoles(admin);
        //
        // andre.setEnabled(true);
        // andre.addRoles(user);
        // andre.addRoles(admin);
        //
        // daniela.setEnabled(true);
        // daniela.addRoles(user);
        // daniela.addRoles(admin);
        //
        // joana.setEnabled(true);
        // joana.addRoles(user);
        //
        // bernardosoares.setEnabled(true);
        // bernardosoares.addRoles(user);
        //
        // rita.setEnabled(true);
        // rita.addRoles(user);
        // rita.addRoles(admin);
        //
        // osvaldo.setEnabled(true);
        // osvaldo.addRoles(user);
        // osvaldo.addRoles(admin);
        //
        // jose.setEnabled(true);
        // jose.addRoles(user);
        // jose.addRoles(admin);
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class Emailer {
    private static final Logger logger = LoggerFactory.getLogger(Emailer.class);

    public void sendEmail(String to, String subject, String msg, String from)
            throws MessagingException {
        Properties properties = setMailProperties();

        Session getMailSession = Session.getDefaultInstance(properties, null);

        Message generateMailMessage = createMessage(from, to, subject, msg, getMailSession);

        sendMessage(getMailSession, generateMailMessage);
    }

    private void sendMessage(Session getMailSession, Message generateMailMessage) throws MessagingException {
        Transport transport = getMailSession.getTransport("smtp");
        System.out.println((String) PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.host"));
        System.out.println((String) PropertiesManager.getProperties().get("registration.confirmation.email.user"));
        System.out.println((String) PropertiesManager.getProperties().get("registration.confirmation.email.password"));
        transport.connect((String) PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.host"),
                (String) PropertiesManager.getProperties().get("registration.confirmation.email.user"),
                (String) PropertiesManager.getProperties().get("registration.confirmation.email.password"));
        transport.sendMessage(generateMailMessage, generateMailMessage.getAllRecipients());
        transport.close();
    }

    private Message createMessage(String from, String to, String subject, String msg, Session getMailSession)
            throws MessagingException {
        Message generateMailMessage = new MimeMessage(getMailSession);
        generateMailMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
        generateMailMessage.addRecipient(Message.RecipientType.BCC, new InternetAddress(from));
        generateMailMessage.setSubject(subject);
        generateMailMessage.setContent(msg, "text/html");
        return generateMailMessage;
    }

    private Properties setMailProperties() {
        Properties properties = new Properties();
        properties.put("mail.smtp.auth", "true");
        properties.put("mail.smtp.starttls.enable", "true");
        properties.put("mail.smtp.host",
                PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.host"));
        properties.put("mail.smtp.port",
                PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.port"));
        return properties;
    }
}


import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}



import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import pt.ist.socialsoftware.edition.user.utils.Emailer;

import javax.jms.Queue;

@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.user")
@SpringBootApplication
@Configuration
@EnableJms
public class UserApplication extends SpringBootServletInitializer implements InitializingBean {


    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }

    @Bean
    public Emailer emailer() {
        return new Emailer();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(11);
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;


import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.notification.event.EventInterface;
import pt.ist.socialsoftware.edition.notification.utils.LdoDDuplicateUsernameException;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.user.api.UserEventPublisher;
import pt.ist.socialsoftware.edition.user.config.BeanUtil;




import java.util.stream.Collectors;

public class User extends User_Base {
    private static final Logger logger = LoggerFactory.getLogger(User.class);
    public static String USER_TWITTER = "Twitter";
    public static String USER_ARS = "ars";

    public enum SocialMediaService {
        TWITTER, FACEBOOK, LINKEDIN, GOOGLE
    }

    @Override
    public void setFirstName(String firstName) {
        if (!firstName.matches("^[\\p{L}\\s]+$")) {
            throw new LdoDException(firstName);
        }
        super.setFirstName(firstName);
    }

    @Override
    public void setLastName(String lastName) {
        if (!lastName.matches("^[\\p{L}\\s]+$")) {
            throw new LdoDException(lastName);
        }
        super.setLastName(lastName);
    }

    @Override
    public void setUsername(String username) {
        if (!username.matches("^[A-Za-z0-9_\\s\\-]+$")) {
            throw new LdoDException(username);
        }
        checkUniqueUsername(username);
        super.setUsername(username);
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {

//        EventInterface.getInstance().publish(new Event(Event.EventType.USER_REMOVE, getUsername()));
        String username = getUsername();

        getUserModule().getUserConnectionSet().stream().filter(uc -> uc.getUserId().equals(getUsername()))
                .forEach(uc -> uc.remove());
        if (getToken() != null) {
            getToken().remove();
        }
        getRolesSet().stream().forEach(r -> removeRoles(r));
        setUserModule(null);

        deleteDomainObject();

        UserEventPublisher userEventPublisher = BeanUtil.getBean(UserEventPublisher.class);
        userEventPublisher.publishEvent(new Event(Event.EventType.USER_REMOVE, username));
    }

    public User(UserModule userModule, String username, String password, String firstName, String lastName, String email) {
        setEnabled(false);
        setActive(true);
        setUserModule(userModule);
        setUsername(username);
        setPassword(password);
        setFirstName(firstName);
        setLastName(lastName);
        setEmail(email);
    }

    private void checkUniqueUsername(String username) {
        if (getUserModule().getUsersSet().stream().filter(u -> u.getUsername() != null && u.getUsername().equals(username))
                .findFirst().isPresent()) {
            throw new LdoDDuplicateUsernameException(username);
        }

    }

    @Atomic(mode = TxMode.WRITE)
    public RegistrationToken createRegistrationToken(String token) {
        return new RegistrationToken(token, this);
    }

    @Atomic(mode = TxMode.WRITE)
    public void enableUnconfirmedUser() {
        setEnabled(true);
        if (getToken() != null) {
            getToken().remove();
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void updatePassword(PasswordEncoder passwordEncoder, String currentPassword, String newPassword) {
//        if (!passwordEncoder.matches(currentPassword, getPassword())) {
//            throw new LdoDException();
//        }
        if (currentPassword.equals(getPassword())) {
            throw new LdoDException();
        }

//        setPassword(passwordEncoder.encode(newPassword));
        setPassword(newPassword);

    }

    public String getListOfRolesAsStrings() {
        return getRolesSet().stream().map(r -> r.getType().name()).collect(Collectors.joining(", "));
    }

    @Atomic(mode = TxMode.WRITE)
    public void switchActive() {
        if (getActive()) {
            setActive(false);
        } else {
            setActive(true);
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void update(PasswordEncoder passwordEncoder, String oldUsername, String newUsername, String firstName,
                       String lastName, String email, String newPassword, boolean isUser, boolean isAdmin, boolean isEnabled) {

        if (!oldUsername.equals(newUsername)) {
            changeUsername(oldUsername, newUsername);
        }

        setFirstName(firstName);
        setLastName(lastName);
        setEmail(email);

        getRolesSet().clear();

        if (isUser) {
            addRoles(Role.getRole(Role.RoleType.ROLE_USER));
        }

        if (isAdmin) {
            addRoles(Role.getRole(Role.RoleType.ROLE_ADMIN));
        }

        setEnabled(isEnabled);

        if (newPassword != null && !newPassword.trim().equals("")) {
//            setPassword(passwordEncoder.encode(newPassword));
            setPassword(newPassword);
        }

    }

    private void changeUsername(String oldUsername, String newUsername) {
        setUsername(newUsername);

        UserConnection userConnection = getUserModule().getUserConnectionSet().stream()
                .filter(uc -> uc.getUserId().equals(oldUsername)).findFirst().orElse(null);

        if (userConnection != null) {
            userConnection.setUserId(newUsername);
        }

    }

}


import org.joda.time.DateTime;
import org.joda.time.Period;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.user.domain.RegistrationToken_Base;
import pt.ist.socialsoftware.edition.user.utils.Emailer;


import javax.mail.MessagingException;
import javax.mail.internet.AddressException;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;

public class RegistrationToken extends RegistrationToken_Base {
    private static final int EXPIRATION = 1440;

    public RegistrationToken(String token, User user) {
        setUser(user);
        setUserModule(user.getUserModule());
        setToken(token);
        setExpireTimeDateTime(DateTime.now().plus(new Period().withMinutes(EXPIRATION)));
    }

    public DateTime getExpireTimeDateTime() {
        return new DateTime(getExpireTime());
    }

    public void setExpireTimeDateTime(DateTime date) {
        setExpireTime(date.getMillis());
    }

    @Override
    @Atomic(mode = TxMode.WRITE)
    public void setAuthorized(boolean authorized) {
        super.setAuthorized(authorized);
    }

    public void remove() {
        setUser(null);
        setUserModule(null);

        deleteDomainObject();
    }

    public HashMap<String, String> requestAuthorization(HttpServletRequest request, Emailer emailer) throws AddressException, MessagingException {

        HashMap<String, String> map = new HashMap<>();

        String recipientAddress = PropertiesManager.getProperties()
                .getProperty("registration.authorization.email.address");

        String subject = "VirtualModule - Autorização de Registo";

        String path = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
                + request.getContextPath();
        String authorizationUrl = path + "/signup/registrationAuthorization?token=" + getToken();

        map.put("to", recipientAddress);
        map.put("subject", subject);
        map.put("msg", "Autorize o registo no arquivo do VirtualModule do utilizador " + getUser().getFirstName() + " "
                        + getUser().getLastName() + " com username " + getUser().getUsername()
                        + " com o endereço de email " + getUser().getEmail() + " nesta ligação <a href=\""
                        + authorizationUrl + "\">" + authorizationUrl + "</a>");
        map.put("from", PropertiesManager.getProperties().getProperty("registration.confirmation.email.address"));
        return map;

//        emailer.sendEmail(recipientAddress, subject,
//                "Autorize o registo no arquivo do VirtualModule do utilizador " + getUser().getFirstName() + " "
//                        + getUser().getLastName() + " com username " + getUser().getUsername()
//                        + " com o endereço de email " + getUser().getEmail() + " nesta ligação <a href=\""
//                        + authorizationUrl + "\">" + authorizationUrl + "</a>",
//                PropertiesManager.getProperties().getProperty("registration.confirmation.email.address"));
    }

    public HashMap<String, String> requestConfirmation(HttpServletRequest request, Emailer emailer) throws AddressException, MessagingException {
        HashMap<String, String> map = new HashMap<>();

        String recipientAddress = getUser().getEmail();

        String subject = "VirtualModule - Confirmação de Registo";

        String path = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
                + request.getContextPath();
        String confirmationUrl = path + "/signup/registrationConfirm?token=" + getToken();

        map.put("to", recipientAddress);
        map.put("subject", subject);
        map.put("msg", "Confirme o registo no arquivo do VirtualModule do utilizador " + getUser().getUsername()
                + " com o endereço de email " + getUser().getEmail() + " nesta ligação <a href=\""
                + confirmationUrl + "\">" + confirmationUrl + "</a>");
        map.put("from", PropertiesManager.getProperties().getProperty("registration.confirmation.email.address"));

        return map;
//        emailer.sendEmail(recipientAddress, subject,
//                "Confirme o registo no arquivo do VirtualModule do utilizador " + getUser().getUsername()
//                        + " com o endereço de email " + getUser().getEmail() + " nesta ligação <a href=\""
//                        + confirmationUrl + "\">" + confirmationUrl + "</a>",
//                PropertiesManager.getProperties().getProperty("registration.confirmation.email.address"));
    }

}


import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.notification.utils.LdoDDuplicateUsernameException;


public class UserModule extends UserModule_Base {
    public static Logger logger = LoggerFactory.getLogger(UserModule.class);

    public static UserModule getInstance() {
        return FenixFramework.getDomainRoot()
                .getUserModule();
    }

    public UserModule() {
        FenixFramework.getDomainRoot().setUserModule(this);
    }

    public void remove() {
        getUsersSet().forEach(u -> u.remove());
        getRolesSet().forEach(r -> r.remove());
        getTokenSet().forEach(t -> t.remove());
        getUserConnectionSet().forEach(c -> c.remove());

        setRoot(null);

        deleteDomainObject();
    }

    public User getUser(String username) {
        for (User user : getUsersSet()) {
            if (user.getUsername().equals(username)) {
                return user;
            }
        }
        return null;
    }

    @Atomic(mode = TxMode.WRITE)
    public void switchAdmin() {
        setAdmin(!getAdmin());
    }

//    @Atomic(mode = TxMode.WRITE)
//    public User createUser(PasswordEncoder passwordEncoder, String username, String password, String firstName,
//                           String lastName, String email, User.SocialMediaService socialMediaService, String socialMediaId) {
//
//        removeOutdatedUnconfirmedUsers();
//
//        if (getUser(username) == null) {
//            User user = new User(this, username, passwordEncoder.encode(password), firstName, lastName, email);
//            user.setSocialMediaService(socialMediaService);
//            user.setSocialMediaId(socialMediaId);
//
//            Role userRole = Role.getRole(Role.RoleType.ROLE_USER);
//            user.addRoles(userRole);
//
//            return user;
//        } else {
//            throw new LdoDDuplicateUsernameException(username);
//        }
//    }


    @Atomic(mode = TxMode.WRITE)
    public User createUser(String username, String password, String firstName,
                           String lastName, String email, User.SocialMediaService socialMediaService, String socialMediaId) {

        removeOutdatedUnconfirmedUsers();

        if (getUser(username) == null) {
            User user = new User(this, username, password, firstName, lastName, email);
            user.setSocialMediaService(socialMediaService);
            user.setSocialMediaId(socialMediaId);

            Role userRole = Role.getRole(Role.RoleType.ROLE_USER);
            user.addRoles(userRole);

            return user;
        } else {
            throw new LdoDDuplicateUsernameException(username);
        }
    }

    public void removeOutdatedUnconfirmedUsers() {
        DateTime now = DateTime.now();
        getTokenSet().stream().filter(t -> t.getExpireTimeDateTime().isBefore(now)).map(t -> t.getUser())
                .forEach(u -> u.remove());
    }

    public RegistrationToken getTokenSet(String token) {
        return getTokenSet().stream().filter(t -> t.getToken().equals(token)).findFirst().orElse(null);
    }


    public UserConnection getUserConnection(String userId, String providerId, String providerUserId) {
        return getUserConnectionSet().stream().filter(uc -> uc.getUserId().equals(userId)
                && uc.getProviderId().equals(providerId) && uc.getProviderUserId().equals(providerUserId)).findFirst()
                .orElse(null);
    }

    @Atomic(mode = TxMode.WRITE)
    public void createUserConnection(String userId, String providerId, String providerUserId, int rank,
                                     String displayName, String profileUrl, String imageUrl, String accessToken, String secret,
                                     String refreshToken, Long expireTime) {

        new UserConnection(this, userId, providerId, providerUserId, rank, displayName, profileUrl, imageUrl,
                accessToken, secret, refreshToken, expireTime);
    }

    @Atomic(mode = TxMode.WRITE)
    public void createTestUsers(PasswordEncoder passwordEncoder) {
        UserModule userModule = UserModule.getInstance();

        Role userRole = Role.getRole(Role.RoleType.ROLE_USER);
        Role admin = Role.getRole(Role.RoleType.ROLE_ADMIN);

        PasswordEncoder passwordEncoder1 = new BCryptPasswordEncoder(11);

        // the bcrypt generator
        // https://www.dailycred.com/blog/12/bcrypt-calculator
        for (int i = 0; i < 6; i++) {
            String username = "zuser" + Integer.toString(i + 1);
            if (userModule.getUser(username) == null) {
//                User user = new User(userModule, username, passwordEncoder.encode(username), "zuser", "zuser",
//                        "zuser" + Integer.toString(i + 1) + "@teste.pt");
                User user = new User(userModule, username, passwordEncoder1.encode(username), "zuser", "zuser",
                        "zuser" + Integer.toString(i + 1) + "@teste.pt");

                user.setEnabled(true);
                user.addRoles(userRole);
            }
        }
    }


}


import org.springframework.dao.DuplicateKeyException;


public class UserConnection extends UserConnection_Base {

    public UserConnection(UserModule userModule, String userId, String providerId, String providerUserId, int rank,
                          String displayName, String profileUrl, String imageUrl, String accessToken, String secret,
                          String refreshToken, Long expireTime) {
        checkUnique(userModule, userId, providerId, rank);

        setUserModule(userModule);
        setUserId(userId);
        setProviderId(providerId);
        setProviderUserId(providerUserId);
        setRank(rank);
        setDisplayName(displayName);
        setProfileUrl(profileUrl);
        setImageUrl(imageUrl);
        setAccessToken(accessToken);
        setSecret(secret);
        setRefreshToken(refreshToken);
        setExpireTime(expireTime);
    }

    private void checkUnique(UserModule userModule, String userId, String providerId, int rank) {
        if (userModule.getUserConnectionSet().stream().filter(
                uc -> uc.getUserId().equals(userId) && uc.getProviderId().equals(providerId) && (uc.getRank() == rank))
                .findFirst().isPresent()) {
            throw new DuplicateKeyException(providerId);
        }
    }

    public void remove() {
        setUserModule(null);

        deleteDomainObject();
    }

}



public class Role extends Role_Base {

    public enum RoleType {
        ROLE_USER, ROLE_ADMIN
    }

    public static Role getRole(RoleType type) {
        return UserModule.getInstance().getRolesSet().stream().filter(r -> r.getType().equals(type)).findFirst()
                .orElseGet(() -> new Role(type));
    }

    private Role(RoleType type) {
        setUserModule(UserModule.getInstance());
        setType(type);
    }

    public void remove() {
        setUserModule(null);
        getUsersSet().forEach(u -> u.remove());

        deleteDomainObject();
    }

}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.filter.Filters;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.joda.time.LocalDate;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.user.domain.*;



import java.io.*;
import java.nio.charset.Charset;

public class UsersXMLImport {

    public void importUsers(InputStream inputStream) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        Document doc;
        try {
            Reader reader = new InputStreamReader(inputStream, Charset.defaultCharset());
            doc = builder.build(reader);
            //doc = builder.build(inputStream);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        processImport(doc);
    }

    public void importUsers(String usersXML) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        InputStream stream = new ByteArrayInputStream(usersXML.getBytes());

        importUsers(stream);
    }

    @Atomic(mode = TxMode.WRITE)
    public void processImport(Document doc) {
        UserModule userModule = UserModule.getInstance();

        importUsers(doc, userModule);
        importUserConnections(doc, userModule);
        importRegistrationTokens(doc, userModule);
    }

    private void importUsers(Document doc, UserModule userModule) {
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//users-management/users/user", Filters.element());
        for (Element element : xp.evaluate(doc)) {
            String username = element.getAttributeValue("username");
            User user = userModule.getUser(username);
            if (user == null) {
                String firstName = element.getAttributeValue("firstName");
                String lastName = element.getAttributeValue("lastName");
                String email = element.getAttributeValue("email");

                user = new User(userModule, username, null, firstName, lastName, email);
            }

            // Support null passwords
            if (element.getAttributeValue("password") != null) {
                String password = element.getAttributeValue("password");
                user.setPassword(password);
            }

            if (element.getAttributeValue("lastLogin") != null) {
                user.setLastLogin(LocalDate.parse(element.getAttributeValue("lastLogin")));
            }

            user.setActive(convertToBool(element.getAttributeValue("active")));
            user.setEnabled(convertToBool(element.getAttributeValue("enabled")));

            String socialMediaService = element.getAttributeValue("socialMediaService");
            if (socialMediaService != null) {
                user.setSocialMediaService(convertToSocialMediaService(socialMediaService));
            }

            String socialMediaId = element.getAttributeValue("socialMediaId");
            if (socialMediaId != null) {
                user.setSocialMediaId(socialMediaId);
            }

            importUserRoles(element, user);
        }
    }

    private void importUserRoles(Element element, User user) {
        for (Element roleElement : element.getChild("roles").getChildren("role")) {
            user.addRoles(Role.getRole(convertToRoleType(roleElement.getAttributeValue("type"))));
        }

    }

    private void importUserConnections(Document doc, UserModule userModule) {
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//users-management/user-connections/user-connection",
                Filters.element());
        for (Element element : xp.evaluate(doc)) {
            String userId = element.getAttributeValue("userId");
            String providerId = element.getAttributeValue("providerId");
            String providerUserId = element.getAttributeValue("providerUserId");
            int rank = Integer.parseInt(element.getAttributeValue("rank"));
            String displayName = element.getAttributeValue("displayName");
            String profileUrl = element.getAttributeValue("profileUrl");
            String imageUrl = element.getAttributeValue("imageUrl");
            String accessToken = element.getAttributeValue("accessToken");
            String secret = element.getAttributeValue("secret");
            String refreshToken = element.getAttributeValue("refreshToken");
            Long expireTime = null;
            if (element.getAttributeValue("expireTime") != null) {
                expireTime = Long.parseLong(element.getAttributeValue("expireTime"));
            }

            new UserConnection(userModule, userId, providerId, providerUserId, rank, displayName, profileUrl, imageUrl,
                    accessToken, secret, refreshToken, expireTime);
        }
    }

    private void importRegistrationTokens(Document doc, UserModule userModule) {
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//users-management/registration-tokens/token", Filters.element());

        for (Element element : xp.evaluate(doc)) {
            String token = element.getAttributeValue("token");
            Long expireTime = Long.parseLong(element.getAttributeValue("expireTime"));
            boolean authorized = convertToBool(element.getAttributeValue("authorized"));
            String user = element.getAttributeValue("user");

            RegistrationToken registrationToken = new RegistrationToken(token, userModule.getUser(user));
            registrationToken.setExpireTime(expireTime);
            registrationToken.setAuthorized(authorized);
        }
    }

    private User.SocialMediaService convertToSocialMediaService(String value) {
        switch (value) {
            case "TWITTER":
                return User.SocialMediaService.TWITTER;
            case "FACEBOOK":
                return User.SocialMediaService.FACEBOOK;
            case "LINKEDIN":
                return User.SocialMediaService.LINKEDIN;
            case "GOOGLE":
                return User.SocialMediaService.GOOGLE;
            default:
                throw new LdoDException("UsersXMLImport::convertToSocialMediaService " + value);

        }
    }

    private boolean convertToBool(String value) {
        if (value.equals("true")) {
            return true;
        }

        if (value.equals("false")) {
            return false;
        }

        throw new LdoDException("UsersXMLImport::convertToBool " + value);
    }

    private Role.RoleType convertToRoleType(String value) {
        switch (value) {
            case "ROLE_USER":
                return Role.RoleType.ROLE_USER;
            case "ROLE_ADMIN":
                return Role.RoleType.ROLE_ADMIN;
            default:
                throw new LdoDException("UsersXMLImport::convertToRoleType " + value);

        }
    }

}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.user.domain.*;

public class UsersXMLExport {

    @Atomic
    public String export() {
        UserModule userModule = UserModule.getInstance();

        Element element = createHeader();

        exportUsers(element, userModule);
        exportUserConnections(element, userModule);
        exportRegistrationTokens(element, userModule);

        XMLOutputter xml = new XMLOutputter();
        xml.setFormat(Format.getPrettyFormat());
        // System.out.println(xml.outputString(element));

        return xml.outputString(element);
    }

    public Element createHeader() {
        Document jdomDoc = new Document();
        Element rootElement = new Element("users-management");

        jdomDoc.setRootElement(rootElement);
        return rootElement;
    }

    private void exportUsers(Element element, UserModule userModule) {
        Element usersElement = new Element("users");

        for (User user : userModule.getUsersSet()) {
            exportUser(usersElement, user);
        }

        element.addContent(usersElement);
    }

    private void exportUser(Element element, User user) {
        Element userElement = new Element("user");
        userElement.setAttribute("username", user.getUsername());
        userElement.setAttribute("enabled", exportBoolean(user.getEnabled()));
        userElement.setAttribute("active", exportBoolean(user.getActive()));

        // TODO: changed because of Social Media User, password cannot be null
        String password = user.getPassword();
        if (password != null) {
            userElement.setAttribute("password", password);
        }

        userElement.setAttribute("firstName", user.getFirstName());
        userElement.setAttribute("lastName", user.getLastName());
        userElement.setAttribute("email", user.getEmail());
        if (user.getLastLogin() != null) {
            userElement.setAttribute("lastLogin", user.getLastLogin().toString());
        }
        if (user.getSocialMediaService() != null) {
            userElement.setAttribute("socialMediaService", user.getSocialMediaService().toString());
        }
        if (user.getSocialMediaId() != null) {
            userElement.setAttribute("socialMediaId", user.getSocialMediaId());
        }

        exportUserRoles(userElement, user);

        element.addContent(userElement);
    }

    private void exportUserRoles(Element element, User user) {
        Element userRolesElement = new Element("roles");

        for (Role role : user.getRolesSet()) {
            exportUserRole(userRolesElement, role);
        }

        element.addContent(userRolesElement);

    }

    private void exportUserRole(Element element, Role role) {
        Element roleElement = new Element("role");

        roleElement.setAttribute("type", role.getType().toString());

        element.addContent(roleElement);

    }

    private String exportBoolean(boolean value) {
        if (value) {
            return "true";
        } else {
            return "false";
        }
    }

    private void exportUserConnections(Element element, UserModule userModule) {
        Element userConnectionsElement = new Element("user-connections");

        for (UserConnection userConnection : userModule.getUserConnectionSet()) {
            exportUserConnection(userConnectionsElement, userConnection);
        }

        element.addContent(userConnectionsElement);
    }

    private void exportUserConnection(Element element, UserConnection userConnection) {
        Element userConnectionElement = new Element("user-connection");

        userConnectionElement.setAttribute("userId", userConnection.getUserId());
        userConnectionElement.setAttribute("providerId", userConnection.getProviderId());
        userConnectionElement.setAttribute("providerUserId", userConnection.getProviderUserId());
        userConnectionElement.setAttribute("rank", Integer.toString(userConnection.getRank()));
        userConnectionElement.setAttribute("displayName", userConnection.getDisplayName());
        if (userConnection.getProfileUrl() != null) {
            userConnectionElement.setAttribute("profileUrl", userConnection.getProfileUrl());
        }
        userConnectionElement.setAttribute("imageUrl", userConnection.getImageUrl());
        userConnectionElement.setAttribute("accessToken", userConnection.getAccessToken());
        if (userConnection.getSecret() != null) {
            userConnectionElement.setAttribute("secret", userConnection.getSecret());
        }
        if (userConnection.getRefreshToken() != null) {
            userConnectionElement.setAttribute("refreshToken", userConnection.getRefreshToken());
        }
        if (userConnection.getExpireTime() != null) {
            userConnectionElement.setAttribute("expireTime", userConnection.getExpireTime().toString());
        }

        element.addContent(userConnectionElement);
    }

    private void exportRegistrationTokens(Element element, UserModule userModule) {
        Element registrationTokensElement = new Element("registration-tokens");

        for (RegistrationToken registrationToken : userModule.getTokenSet()) {
            exportRegistrationToken(registrationTokensElement, registrationToken);
        }

        element.addContent(registrationTokensElement);
    }

    private void exportRegistrationToken(Element element, RegistrationToken registrationToken) {
        Element tokenElement = new Element("token");

        tokenElement.setAttribute("token", registrationToken.getToken());
        tokenElement.setAttribute("expireTime", registrationToken.getExpireTime().toString());
        tokenElement.setAttribute("authorized", exportBoolean(registrationToken.getAuthorized()));
        tokenElement.setAttribute("user", registrationToken.getUser().getUsername());

        element.addContent(tokenElement);
    }


}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.game.domain.*;

import pt.ist.socialsoftware.edition.game.feature.classification.inout.WriteGamestoFile;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TagDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.notification.event.EventInterface;
import pt.ist.socialsoftware.edition.notification.event.EventTagRemove;
import pt.ist.socialsoftware.edition.notification.event.SubscribeInterface;



import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

@Component
public class GameRequiresInterface implements SubscribeInterface {
    private static final Logger logger = LoggerFactory.getLogger(GameRequiresInterface.class);

    private static GameRequiresInterface instance;

    public static GameRequiresInterface getInstance() {
        if (instance == null) {
            instance = new GameRequiresInterface();
        }
        return instance;
    }

    @JmsListener(id = "1", containerFactory = "jmsListenerContainerFactory", destination = "test-topic")
    public void listener(Event message){
        this.notify(message);
    }

    protected GameRequiresInterface() {
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public void notify(Event event) {

        if (event.getType().equals(Event.EventType.USER_REMOVE)) {
            String username = event.getIdentifier();

            ClassificationModule.getInstance().getPlayerSet().stream().filter(player -> player.getUser().equals(username))
                    .forEach(Player::remove);
            ClassificationModule.getInstance().getClassificationGameSet().stream()
                    .filter(classificationGame -> classificationGame.getResponsible().equals(username))
                    .forEach(ClassificationGame::remove);
        }
        else if (event.getType().equals(Event.EventType.VIRTUAL_EDITION_REMOVE)){
            String editionId = event.getIdentifier();

            ClassificationModule.getInstance().getClassificationGameSet().stream()
                    .filter(classificationGame -> classificationGame.getEditionId().equals(editionId))
                    .forEach(ClassificationGame::remove);
        }
        else if (event.getType().equals(Event.EventType.VIRTUAL_INTER_REMOVE)){
            String interId = event.getIdentifier();

            ClassificationModule.getInstance().getClassificationGameSet().stream()
                    .filter(classificationGame -> classificationGame.getInterId().equals(interId))
                    .forEach(ClassificationGame::remove);
        }

        else if (event.getType().equals(Event.EventType.TAG_REMOVE)){
            EventTagRemove tagRemove = (EventTagRemove) event;

            String urlId = tagRemove.getIdentifier();
            String interId = tagRemove.getInterId();

            ClassificationModule.getInstance().getClassificationGameSet().stream()
                    .filter(classificationGame -> classificationGame.getTagId() != null
                            && classificationGame.getTagId().equals(urlId)
                            && classificationGame.getInterId().equals(interId))
                    .forEach(ClassificationGame::remove);
        }
        else if (event.getType().equals(Event.EventType.VIRTUAL_EXPORT)){
            WriteGamestoFile writeGamestoFile = new WriteGamestoFile();
            writeGamestoFile.exportToVirtualZip(event.getIdentifier());
        }
    }

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);

    public void removeTag(String externalId){
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeTagFromInter")
                    .queryParam("externalId", externalId)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.removeTagFromInter(externalId);
    }

    public VirtualEditionDto getVirtualEdition(String acronym){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym)
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEdition(acronym);
    }

    public VirtualEditionInterDto getVirtualEditionInter(String xmlId){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/xmlId/" + xmlId)
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInter(xmlId);
    }

    public Set<VirtualEditionDto> getVirtualEditionUserIsParticipant(String username){
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditionsInters/getVirtualEditionIntersUserIsContributor")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToFlux(VirtualEditionDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionsUserIsParticipant(username);
    }

    public Set<VirtualEditionInterDto> getVirtualEditionInterDtoSet(String acronym){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInterSet/" + acronym)
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterSet(acronym);
    }

    public Set<VirtualEditionInterDto> getVirtualEditionInterDtoSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInterSet")
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterSet(acronym);
    }

    public boolean getOpenVocabularyStatus(String acronym){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/taxonomyVocabularyStatus")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.getVirtualEditionTaxonomyVocabularyStatus(acronym);
    }

    public boolean getOpenAnnotationStatus(String acronym){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/taxonomyAnnotationStatus")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.getVirtualEditionTaxonomyAnnotationStatus(acronym);
    }

    public TagDto createTag(String editionId, String interId, String tagName, String user){
        return webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/createTagInInter")
                    .queryParam("editionId", editionId)
                    .queryParam("interId", interId)
                    .queryParam("tagName", tagName)
                    .queryParam("user", user)
                .build())
                .retrieve()
                .bodyToMono(TagDto.class)
                .block();
        //        return this.virtualProvidesInterface.createTagInInter(editionId, interId, tagName, user);
    }

    public boolean isUserParticipant(String acronym, String username){
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + acronym + "/isUserParticipant")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.isUserParticipant(acronym, username);
    }

    public VirtualEditionInterDto getVirtualEditionInterFromModule(String xmlId) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + xmlId + "/interFromModule")
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
    }
}




import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.game.api.dtoc.ClassificationGameDto;
import pt.ist.socialsoftware.edition.game.api.dtoc.ClassificationGameParticipantDto;
import pt.ist.socialsoftware.edition.game.api.dtoc.ClassificationVirtualGameDto;
import pt.ist.socialsoftware.edition.game.api.dtoc.PlayerDto;
import pt.ist.socialsoftware.edition.game.api.dtoc.wrapper.CreateGameWrapper;
import pt.ist.socialsoftware.edition.game.domain.*;
import pt.ist.socialsoftware.edition.game.feature.classification.GameRunner;
import pt.ist.socialsoftware.edition.game.feature.classification.inout.GameXMLImport;
import pt.ist.socialsoftware.edition.game.utils.GameBootstrap;


import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api")
@Component
public class GameProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(GameProvidesInterface.class);

    
    @Autowired
    GameRunner gameRunner;

    @GetMapping("/classificationGames")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ClassificationGameDto> getClassificationGames() {
        logger.debug("getClassificationGames");
        return ClassificationModule.getInstance().getClassificationGameSet().stream()
                .map(ClassificationGameDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/overallUserPosition")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getOverallUserPosition(@RequestParam(name = "username") String username) {
        logger.debug("getOverallUserPosition: " + username);
        return ClassificationModule.getInstance().getOverallUserPosition(username);
    }

    @GetMapping("/player/{username}")
    @Atomic(mode = Atomic.TxMode.READ)
    public PlayerDto getPlayerByUsername(@PathVariable("username") String username) {
        logger.debug("getPlayerByUsername: " + username);
        Player player = ClassificationModule.getInstance().getPlayerByUsername(username);
        if (player != null){
            return new PlayerDto(player);
        }

        return null;
    }

    @GetMapping("/player/{username}/classificationGames")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ClassificationGameDto> getClassificationGamesForPlayer(@PathVariable("username") String username) {
        logger.debug("getClassificationGamesForPlayer: " + username);
        Player player = ClassificationModule.getInstance().getPlayerByUsername(username);
        if (player != null){
            return player.getClassificationGameParticipantSet().stream().map(ClassificationGameParticipant::getClassificationGame)
                    .map(ClassificationGameDto::new).collect(Collectors.toSet());
        }

        return new HashSet<>();
    }

    @GetMapping("/classificationGamesForEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ClassificationGameDto> getClassificationGamesForEdition(@RequestParam(name = "acronym") String acronym) {
        logger.debug("getClassificationGamesForEdition: " + acronym);
        return  ClassificationModule.getInstance().getClassificationGamesForEdition(acronym)
                .stream().sorted(Comparator.comparing(ClassificationGame::getDateTime))
                .map(ClassificationGameDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/createClassificationGame")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createClassificationGame(@RequestBody CreateGameWrapper createGameWrapper) {
        logger.debug("createClassificationGame");
        ClassificationModule.createClassificationGame(createGameWrapper.getVirtualEditionDto(), createGameWrapper.getDescription(), createGameWrapper.getParse(), createGameWrapper.getInter(), createGameWrapper.getAuthenticatedUser());
    }

    @PostMapping("/importGamesFromTEI")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void importGamesFromTEI(@RequestBody byte[] inputStream) {
        logger.debug("importGamesFromTEI");
        GameXMLImport game = new GameXMLImport();
        game.importGamesFromTEI(new ByteArrayInputStream(inputStream));
    }

    @GetMapping("/classificationGame/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ClassificationGameDto getClassificationGameByExternalId(@PathVariable("externalId") String externalId) {
        logger.debug("getClassificationGameByExternalId: " + externalId);
        DomainObject object = FenixFramework.getDomainObject(externalId);

        if (object instanceof ClassificationGame) {
            return new ClassificationGameDto((ClassificationGame) object);
        }
        return null;
    }

    @PostMapping("/removeClassificationGame")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeClassificationGame(@RequestParam(name = "externalId") String externalId) {
        logger.debug("removeClassificationGame: " + externalId);
        DomainObject object = FenixFramework.getDomainObject(externalId);
        if (object instanceof ClassificationGame) {
            ((ClassificationGame) object).remove();
        }
    }

    @GetMapping("/classificationGameParticipant/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ClassificationGameParticipantDto> getClassificationGameParticipantByExternalId(@PathVariable("externalId") String externalId) {
        logger.debug("getClassificationGameParticipantByExternalId: " + externalId);
        DomainObject object = FenixFramework.getDomainObject(externalId);
        if (object instanceof ClassificationGame) {
           return  ((ClassificationGame) object).getClassificationGameParticipantSet().stream()
                   .sorted(Comparator.comparing(ClassificationGameParticipant::getScore).reversed())
                   .map(ClassificationGameParticipantDto::new).collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    @PostMapping("/initializeGameModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void initializeGameModule() {
        logger.debug("initializeGameModule");
        GameBootstrap.initializeGameModule();
    }


    @PostMapping("/startGameRunner")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void startGameRunner(@RequestParam(name = "id") String id) {
        logger.debug("startGameRunner: " + id);
        this.gameRunner.setGameId(id);
        new Thread(this.gameRunner).start();
    }

    @GetMapping("/getGamesForScheduledTasks")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getGamesForScheduledTasks() {
        DateTime now = DateTime.now();
        logger.debug("getGamesForScheduledTasks: " + now);
        return ClassificationModule.getInstance().getClassificationGameSet().stream()
                .filter(g -> g.getState().equals(ClassificationGame.ClassificationGameState.CREATED)
                        && g.getDateTime().isAfter(now) && g.getDateTime().isBefore(now.plusMinutes(2)))
                .sorted(Comparator.comparing(ClassificationGame::getDateTime)).map(g -> g.getExternalId())
                .collect(Collectors.toList());
    }

    @PostMapping("/manageDailyClassificationGames")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void manageDailyClassificationGames() {
        logger.debug("manageDailyClassificationGames");
        ClassificationModule.manageDailyClassificationGames(DateTime.now());
    }

    // Test Calls

    @PostMapping("/classificationGame/{externalId}/addParticipant")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addParticipantToGame(@PathVariable("externalId") String externalId, @RequestParam(name = "username") String username) {
        logger.debug("addParticipantToGame: " + username);
        DomainObject object = FenixFramework.getDomainObject(externalId);
        if (object instanceof ClassificationGame) {
          ((ClassificationGame) object).addParticipant(username);
        }
    }

    @PostMapping("/setTestGameRound")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void setTestGameRound(@RequestParam(name = "acronym") String acronym, @RequestParam(name = "username") String username) {
        logger.debug("setTestGameRound: " + username);

        ClassificationGameParticipant participant = ClassificationModule.getInstance().getClassificationGamesForEdition(acronym).stream().findFirst().get().getParticipant(username);

        ClassificationGameRound round = new ClassificationGameRound();
        round.setNumber(1);
        round.setRound(1);
        round.setTag("XXXX");
        round.setVote(1);
        round.setClassificationGameParticipant(participant);
        round.setTime(DateTime.now());
        participant.setScore(participant.getScore() + ClassificationGame.SUBMIT_TAG);
    }

    @PostMapping("/removeGameModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeGameModule() {
        logger.debug("removeGameModule");
        ClassificationModule classificationModule = ClassificationModule.getInstance();
        if (classificationModule != null) {
            classificationModule.remove();
        }
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.messaging.SessionConnectedEvent;
import org.springframework.web.socket.messaging.SessionDisconnectEvent;
import org.springframework.web.socket.messaging.SessionSubscribeEvent;
import org.springframework.web.socket.messaging.SessionUnsubscribeEvent;

import java.util.ArrayList;
import java.util.List;

@Component
public class WebSocketEventListener {

    private static final Logger logger = LoggerFactory.getLogger(WebSocketEventListener.class);
    private List<String> subscribedUsers = new ArrayList<>();

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        logger.info("Web socket connected {}", headerAccessor.getSessionId());
    }


    @EventListener
    public void handleSubscribe(SessionSubscribeEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String destination = headerAccessor.getDestination();
        String subId = headerAccessor.getSubscriptionId();
        logger.info("Received a subscribe to: {}, with subId: {}", destination, subId);
        this.subscribedUsers.add(subId);

    }

    @EventListener
    public void handleUnSubscribe(SessionUnsubscribeEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        logger.info("Received a unsubscribe: " + headerAccessor.getSubscriptionId());
        this.subscribedUsers.remove(headerAccessor.getSubscriptionId());

    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        logger.info("Web socket disconnected {}", headerAccessor.getSessionId());
    }

    public List<String> getSubscribedUsers() {
        return this.subscribedUsers;
    }

    public void setSubscribedUsers(List<String> subscribedUsers) {
        this.subscribedUsers = subscribedUsers;
    }

}


import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameParticipant;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameRound;
import pt.ist.socialsoftware.edition.game.domain.ClassificationModule;
import pt.ist.socialsoftware.edition.game.api.dtoc.ClassificationVirtualGameDto;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/services/ldod-game")
public class ClassificationGameController {
    private static final Logger logger = LoggerFactory.getLogger(ClassificationGameController.class);

    @Autowired
    private SimpMessagingTemplate broker;

    private final Map<String, ClassificationVirtualGameDto> gamesMapDto = new LinkedHashMap<>(100);

    // ------------- REST Methods ------------- //

    @GetMapping(value = "/{username}/active", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    @PreAuthorize("hasPermission(#username, 'user.logged')")
    public @ResponseBody
    ResponseEntity<List<ClassificationVirtualGameDto>> getActiveGames(
            @PathVariable(value = "username") String username) {
        // logger.debug("getActiveGames: {}", username);

        List<ClassificationVirtualGameDto> result = ClassificationModule.getInstance().getActiveGames4User(username).stream()
                .map(ClassificationVirtualGameDto::new).sorted(Comparator.comparingLong(ClassificationVirtualGameDto::getDateTime))
                .collect(Collectors.toList());

        for (ClassificationVirtualGameDto gameDto : result) {
            if (!this.gamesMapDto.containsKey(gameDto.getGameExternalId())) {
                this.gamesMapDto.put(gameDto.getGameExternalId(), gameDto);
            }
        }

        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @GetMapping("/end/{gameId}")
    public @ResponseBody
    ResponseEntity<?> end(@PathVariable(value = "gameId") String gameId) {
        // logger.debug("end: {}", gameId);

        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        game.finish();
        String usernameWinner = game.getClassificationGameParticipantSet().stream()
                .filter(ClassificationGameParticipant::getWinner).findFirst().get().getPlayer().getUser();

        List<Object> response = new ArrayList<>();
        response.add(usernameWinner);
        return new ResponseEntity<>(response.toArray(), HttpStatus.OK);
    }

    @GetMapping("/leaderboard")
    public @ResponseBody
    ResponseEntity<?> getLeaderboard() {
        // logger.debug("getLeaderboard: {}", gameId);

        List<Object> response = new ArrayList<>();

        Map<String, Double> overallLeaderboard = ClassificationModule.getInstance().getOverallLeaderboard();
        List<String> users = overallLeaderboard.entrySet().stream()
                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).map(Map.Entry::getKey)
                .collect(Collectors.toList());
        List<Double> scores = overallLeaderboard.entrySet().stream()
                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).map(Map.Entry::getValue)
                .collect(Collectors.toList());

        response.add(users);
        response.add(scores);

        return new ResponseEntity<>(response.toArray(), HttpStatus.OK);
    }

    // ------------- WebSocket Methods ------------- //

    @MessageMapping("/{gameId}/connect")
    public @ResponseBody
    void handleConnect(@Payload Map<String, String> payload) {
        // logger.debug(" handleConnect keys: {}, value: {}", payload.keySet(),
        // payload.values());

        String userId = payload.get("userId");
        String gameId = payload.get("gameId");

        createGameParticipant(gameId, userId);
    }

    @MessageMapping("/{gameId}/tags")
    @SendTo("/topic/ldod-game/{gameId}/tags")
    public @ResponseBody
    void handleTags(@Payload Map<String, String> payload) {
        // logger.debug("handleTags keys: {}, values: {}", payload.keySet(),
        // payload.values());

        String gameId = payload.get("gameId");
        String authorId = payload.get("authorId");
        String tag = payload.get("msg");
        Object number = payload.get("paragraph");
        int finalNumber = Integer.parseInt((String) number);

        changeGameState(gameId, ClassificationGame.ClassificationGameState.TAGGING);
        saveTag(gameId, authorId, tag, finalNumber);

        this.broker.convertAndSend("/topic/ldod-game/" + gameId + "/tags", payload.values());
    }

    @Atomic(mode = TxMode.READ)
    @MessageMapping("/{gameId}/votes")
    @SendTo("/topic/ldod-game/{gameId}/votes")
    public @ResponseBody
    void handleVotes(@Payload Map<String, String> payload) {
        // logger.debug("handleVotes keys: {}, values: {}", payload.keySet(),
        // payload.values());

        String gameId = payload.get("gameId");
        String voterId = payload.get("voterId");
        String tagMsg = payload.get("msg");
        Object vote = payload.get("vote");
        double finalVote = Double.parseDouble((String) vote);
        Object number = payload.get("paragraph");
        int finalNumber = Integer.parseInt((String) number);
        double v = 0;

        changeGameState(gameId, ClassificationGame.ClassificationGameState.VOTING);
        v = saveVote(gameId, voterId, tagMsg, finalVote, finalNumber);

        payload.remove("paragraph");
        String currentTopTag = getCurrentTagWinner(gameId);
        String currentWinner = getCurrentParticipantWinner(gameId);

        payload.put("vote", String.valueOf(v));
        payload.put("top", currentTopTag);
        payload.put("winner", currentWinner);

        this.broker.convertAndSend("/topic/ldod-game/" + gameId + "/votes", payload.values());
    }

    @Atomic(mode = TxMode.READ)
    @MessageMapping("/{gameId}/review")
    @SendTo("/topic/ldod-game/{gameId}/review")
    public @ResponseBody
    void handleReview(@Payload Map<String, String> payload) {
        // logger.debug("handleReview keys: {}, values: {}", payload.keySet(),
        // payload.values());

        String gameId = payload.get("gameId");
        Object limit = payload.get("limit");
        int numberOfParagraphs = Integer.parseInt((String) limit);
        numberOfParagraphs = numberOfParagraphs == 1 ? 2 : numberOfParagraphs;

        changeGameState(gameId, ClassificationGame.ClassificationGameState.REVIEWING);
        Set<String> topTags = getTopTags(gameId, numberOfParagraphs);

        List<Map<String, String>> response = new ArrayList<>();

        for (String topTag : topTags) {
            Map<String, String> map = new LinkedHashMap<>();
            map.put("tag", topTag);
            map.put("vote", String.valueOf(0));
            response.add(map);
        }

        String currentTopTag = getCurrentTagWinner(gameId);
        String currentWinner = getCurrentParticipantWinner(gameId);

        payload.put("top", currentTopTag);
        payload.put("winner", currentWinner);

        Map<String, String> map = new LinkedHashMap<>();
        map.put(currentWinner, currentTopTag);
        response.add(map);

        this.broker.convertAndSend("/topic/ldod-game/" + gameId + "/review", response);
    }

    @MessageMapping("/{gameId}/sync")
    public void syncGame(@Payload Map<String, String> payload) {
        // logger.debug("syncGame: {}", payload.values());
        String gameId = payload.get("gameId");
        changeToSync(gameId);
    }

    // ------------- DB Transactions ------------- //

    @Atomic(mode = TxMode.WRITE)
    private void createGameParticipant(String gameId, String userId) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        game.addParticipant(userId);
    }

    @Atomic(mode = TxMode.WRITE)
    private void saveTag(String gameId, String userId, String tag, int number) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        ClassificationGameParticipant participant = game.getParticipant(userId);
        ClassificationGameRound round = new ClassificationGameRound();

        round.setNumber(number);
        round.setRound(1);
        round.setTag(tag);
        round.setVote(1);
        round.setClassificationGameParticipant(participant);
        round.setTime(DateTime.now());
        participant.setScore(participant.getScore() + ClassificationGame.SUBMIT_TAG);
    }

    @Atomic(mode = TxMode.WRITE)
    private double saveVote(String gameId, String userId, String tag, double vote, int paragraph) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        ClassificationGameParticipant participant = game.getParticipant(userId);
        ClassificationGameRound round = new ClassificationGameRound();

        round.setNumber(paragraph);

        if (getGameState(gameId).equals(ClassificationGame.ClassificationGameState.REVIEWING)) {
            round.setRound(ClassificationGame.VOTING_FINAL_ROUND);
            round.setVote(game.getVotesForTagInFinalRound(tag) + vote);
        } else if (getGameState(gameId).equals(ClassificationGame.ClassificationGameState.VOTING)) {
            round.setRound(ClassificationGame.VOTING_PARAGRAPH_ROUND);
            round.setVote(game.getVotesForTagInParagraph(tag, paragraph) + vote);
        }

        round.setTag(tag);

        // Vote changed in review, makes participant receive a -1 penalty
        if (vote < 0) {
            participant.setScore(participant.getScore() + ClassificationGame.VOTE_CHANGE);
        }

        round.setClassificationGameParticipant(participant);
        round.setTime(DateTime.now());

        return round.getVote();
    }

    @Atomic(mode = TxMode.WRITE)
    private void changeToSync(String gameId) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        game.setSync(true);
    }

    @Atomic(mode = TxMode.WRITE)
    private void changeGameState(String gameId, ClassificationGame.ClassificationGameState state) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);

        // If we reached reviewing state it should not switch to voting again
        if (game.getState().equals(ClassificationGame.ClassificationGameState.REVIEWING)) {
            return;
        }
        game.setState(state);
    }

    @Atomic(mode = TxMode.READ)
    private Set<String> getTopTags(String gameId, int numberOfParagraphs) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        return game.getCurrentTopTags(numberOfParagraphs);
    }

    @Atomic(mode = TxMode.READ)
    private String getCurrentTagWinner(String gameId) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        return game.getCurrentTagWinner();
    }

    @Atomic(mode = TxMode.READ)
    private String getCurrentParticipantWinner(String gameId) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        return game.getCurrentParticipantWinner().getPlayer().getUser();
    }

    @Atomic(mode = TxMode.READ)
    private ClassificationGame.ClassificationGameState getGameState(String gameId) {
        ClassificationGame game = FenixFramework.getDomainObject(gameId);
        return game.getState();
    }
}



import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

public class VirtualEditionInterGameDto {
    private String fragmentId;
    private String title;
    private int number;
    private String urlId;
    private String text;

    public VirtualEditionInterGameDto() {
    }

    public VirtualEditionInterGameDto(VirtualEditionInterDto inter) {
        this.setFragmentId(inter.getFragmentXmlId());
        this.title = inter.getTitle();
        this.number = inter.getNumber();
        this.urlId = inter.getUrlId();

        this.text = inter.getLastUsed().getTranscription();
    }

    public String getFragmentId() {
        return this.fragmentId;
    }

    public void setFragmentId(String fragmentId) {
        this.fragmentId = fragmentId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getNumber() {
        return this.number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

}


import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;



public class ClassificationVirtualGameDto {
	private String gameExternalId;
	private String virtualEditionAcronym;
	private String virtualEditionTitle;
	private boolean openAnnotation;
	private long dateTime;
	private VirtualEditionInterGameDto virtualEditionInterGameDto;

	public ClassificationVirtualGameDto() {

	}

	public ClassificationVirtualGameDto(ClassificationGame game) {
		//GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

		setGameExternalId(game.getExternalId());

		setVirtualEditionAcronym(game.getEditionId());
		setVirtualEditionTitle((GameRequiresInterface.getInstance().getVirtualEdition(game.getEditionId())).getTitle());

		setOpenAnnotation(game.getOpenAnnotation());
		setDateTime(game.getDateTime().getMillis());
		setVirtualEditionInterGameDto(new VirtualEditionInterGameDto(GameRequiresInterface.getInstance().getVirtualEditionInter(game.getInterId())));
	}

	public String getGameExternalId() {
		return this.gameExternalId;
	}

	public void setGameExternalId(String gameExternalId) {
		this.gameExternalId = gameExternalId;
	}

	public String getVirtualEditionAcronym() {
		return this.virtualEditionAcronym;
	}

	public void setVirtualEditionAcronym(String virtualEditionAcronym) {
		this.virtualEditionAcronym = virtualEditionAcronym;
	}

	public String getVirtualEditionTitle() {
		return this.virtualEditionTitle;
	}

	public void setVirtualEditionTitle(String virtualEditionTitle) {
		this.virtualEditionTitle = virtualEditionTitle;
	}

	public boolean isOpenAnnotation() {
		return this.openAnnotation;
	}

	public void setOpenAnnotation(boolean openAnnotation) {
		this.openAnnotation = openAnnotation;
	}

	public long getDateTime() {
		return this.dateTime;
	}

	public void setDateTime(long dateTime) {
		this.dateTime = dateTime;
	}

	public VirtualEditionInterGameDto getVirtualEditionInterGameDto() {
		return this.virtualEditionInterGameDto;
	}

	public void setVirtualEditionInterGameDto(VirtualEditionInterGameDto virtualEditionInterGameDto) {
		this.virtualEditionInterGameDto = virtualEditionInterGameDto;
	}

}


import pt.ist.socialsoftware.edition.game.domain.ClassificationGameParticipant;

public class ClassificationGameParticipantDto {

    private double score;
    private String playerUsername;

    public ClassificationGameParticipantDto(ClassificationGameParticipant participant) {
        this.score = participant.getScore();
        this.playerUsername = participant.getPlayer().getUser();
    }

    public double getScore() {
        return score;
    }

    public String getPlayerUsername() {
        return playerUsername;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.DateTime;
import pt.ist.socialsoftware.edition.game.api.GameProvidesInterface;
import pt.ist.socialsoftware.edition.game.config.CustomDateTimeDeserializer;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameParticipant;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeSerializer;

import java.util.Collection;
import java.util.List;

public class ClassificationGameDto {

    private final GameProvidesInterface gameProvidesInterface = new GameProvidesInterface();

    private String editionId;
    private String interId;
    private String tagId;
    private String externalId;
    private String description;
    private String responsible;
    private boolean canBeRemoved;
    private boolean isActive;
    private DateTime dateTime;
    private boolean openAnnotation;

    public ClassificationGameDto(ClassificationGame game){
        setEditionId(game.getEditionId());
        setInterId(game.getInterId());
        setTagId(game.getTagId());
        setExternalId(game.getExternalId());
        setDescription(game.getDescription());
        setResponsible(game.getResponsible());
        this.canBeRemoved = game.canBeRemoved();
        this.isActive = game.isActive();
        this.dateTime = game.getDateTime();
        this.openAnnotation = game.getOpenAnnotation();
    }

    public String getEditionId() {
        return editionId;
    }

    public void setEditionId(String editionId) {
        this.editionId = editionId;
    }

    public String getInterId() {
        return interId;
    }

    public void setInterId(String interId) {
        this.interId = interId;
    }

    public String getTagId() {
        return tagId;
    }

    public void setTagId(String tagId) {
        this.tagId = tagId;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getResponsible() {
        return responsible;
    }

    public void setResponsible(String responsible) {
        this.responsible = responsible;
    }

    public boolean canBeRemoved() {
        return canBeRemoved;
    }

    public boolean getCanBeRemoved() { return canBeRemoved; }

    public boolean isActive() {
        return isActive;
    }

    public void setisActive(boolean active) {
        isActive = active;
    }

    public boolean getOpenAnnotation() {
        return openAnnotation;
    }

    public void setOpenAnnotation(boolean openAnnotation) {
        this.openAnnotation = openAnnotation;
    }

    @JsonSerialize(using = CustomDateTimeSerializer.class)
    public DateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(DateTime dateTime) {
        this.dateTime = dateTime;
    }

    public void remove() {
        this.gameProvidesInterface.removeClassificationGame(this.externalId);
    }

    public List<ClassificationGameParticipantDto> getClassificationGameParticipantSet() {
        return this.gameProvidesInterface.getClassificationGameParticipantByExternalId(this.externalId);
    }
}


import pt.ist.socialsoftware.edition.game.domain.Player;

public class PlayerDto {

    private String user;
    private double score;

    public PlayerDto(Player player){
        setUser(player.getUser());
        setScore(player.getScore());
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import org.joda.time.DateTime;
import org.springframework.format.annotation.DateTimeFormat;

import pt.ist.socialsoftware.edition.game.config.CustomDateTimeDeserializer;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;


public class CreateGameWrapper {

    private VirtualEditionDto VirtualEditionDto;
    private String description;
    private DateTime parse;
    private VirtualEditionInterDto inter;
    private String authenticatedUser;

    public CreateGameWrapper(VirtualEditionDto VirtualEditionDto, String description, DateTime parse, VirtualEditionInterDto inter, String authenticatedUser) {
        this.VirtualEditionDto = VirtualEditionDto;
        this.description = description;
        this.parse = parse;
        this.inter = inter;
        this.authenticatedUser = authenticatedUser;
    }

    public CreateGameWrapper() {}

    public VirtualEditionDto getVirtualEditionDto() {
        return VirtualEditionDto;
    }

    public void setVirtualEditionDto(VirtualEditionDto virtualEditionBaseDto) {
        this.VirtualEditionDto = virtualEditionBaseDto;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @JsonDeserialize(using = CustomDateTimeDeserializer.class)
    public DateTime getParse() {
        return parse;
    }

    public void setParse(DateTime parse) {
        this.parse = parse;
    }

    public VirtualEditionInterDto getInter() {
        return inter;
    }

    public void setInter(VirtualEditionInterDto inter) {
        this.inter = inter;
    }

    public String getAuthenticatedUser() {
        return authenticatedUser;
    }

    public void setAuthenticatedUser(String authenticatedUser) {
        this.authenticatedUser = authenticatedUser;
    }
}

//package pt.ist.socialsoftware.edition.game.utils;
//
//public enum Material {
//    PAPER
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//import com.fasterxml.jackson.core.JsonParser;
//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.DeserializationContext;
//import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
//import org.joda.time.DateTime;
//import org.joda.time.format.DateTimeFormat;
//import org.joda.time.format.DateTimeFormatter;
//
//import java.io.IOException;
//
//public class CustomDateTimeDeserializer extends StdDeserializer<DateTime> {
//
//    private static final long serialVersionUID = 1L;
//    private static DateTimeFormatter format = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
//
//    public CustomDateTimeDeserializer() {
//        this(null);
//    }
//
//    public CustomDateTimeDeserializer(Class<DateTime> t) {
//        super(t);
//    }
//
//    @Override
//    public DateTime deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException {
//
//        String date = parser.getText();
//        System.out.println(date);
//        System.out.println(format);
//
//        return format.parseDateTime(date);
//
//    }
//
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//import java.io.Serializable;
//
//public class LdoDException extends RuntimeException implements Serializable {
//
//    private static final long serialVersionUID = 1L;
//
//    protected String message;
//
//    public LdoDException() {
//        this.message = "";
//    }
//
//    public LdoDException(String message) {
//        this.message = message;
//    }
//
//    @Override
//    public String getMessage() {
//        return this.message;
//    }
//
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//
//public class LdoDLoadException extends LdoDException {
//
//    private static final long serialVersionUID = -4087610484821921033L;
//
//    public LdoDLoadException(String message) {
//        this.message = message;
//    }
//
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//public enum Form {
//    LEAF
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//import java.io.IOException;
//import java.util.Properties;
//
//public class PropertiesManager {
//
//	private static final Properties properties = new Properties();
//
//	static {
//		try {
//			properties.load(PropertiesManager.class.getResourceAsStream("/application.properties"));
//			properties.load(PropertiesManager.class.getResourceAsStream("/specific.properties"));
//			properties.load(PropertiesManager.class.getResourceAsStream("/secrete.properties"));
//		} catch (IOException e) {
//			throw new RuntimeException("Unable to load properties files.", e);
//		}
//	}
//
//	public static Properties getProperties() {
//		return properties;
//	}
//}
//package pt.ist.socialsoftware.edition.game.utils;
//
//public enum SourceType {
//    MANUSCRIPT("manuscript"), PRINTED("printed");
//
//    private final String desc;
//
//    SourceType(String desc) {
//        this.desc = desc;
//    }
//
//    public String getDesc() {
//        return this.desc;
//    }
//}


import pt.ist.socialsoftware.edition.game.domain.ClassificationModule;

public class GameBootstrap {

    public static void initializeGameModule() {
        boolean classificationCreate = false;
        if (ClassificationModule.getInstance() == null) {
            new ClassificationModule();
            classificationCreate = true;
        }
    }
}

//package pt.ist.socialsoftware.edition.game.utils;
//
//public enum Medium {
//    PEN("pen"), PENCIL("pencil"), BLUE_INK("blue-ink"), BLACK_INK("black-ink"), VIOLET_INK("violet-ink"), RED_INK(
//            "red-ink"), GREEN_INK("green-ink");
//
//    private final String desc;
//
//    Medium(String desc) {
//        this.desc = desc;
//    }
//
//    public String getDesc() {
//        return this.desc;
//    }
//}

//package pt.ist.socialsoftware.edition.game.utils;
//
//public enum PrecisionType {
//    HIGH("high"), MEDIUM("medium"), LOW("low"), UNKNOWN("unknown");
//
//    private final String desc;
//
//    PrecisionType(String desc) {
//        this.desc = desc;
//    }
//
//    public String getDesc() {
//        return this.desc;
//    }
//}


import org.apache.activemq.ActiveMQConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration
@EnableJms
public class ConsumerConfig {


//    @Value("${activemqbrokerurl}")
//    private String brokerUrl;

    @Primary
    @Bean
    public ActiveMQConnectionFactory activeMQConnectionFactory() {
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
//        activeMQConnectionFactory.setBrokerURL("tcp://localhost:61616");
        activeMQConnectionFactory.setBrokerURL("tcp://activemq:61616");
        activeMQConnectionFactory.setTrustAllPackages(true);
        return activeMQConnectionFactory;
    }

    @Primary
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(activeMQConnectionFactory());
        factory.setPubSubDomain(true);
        return factory;
    }
}

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.support.SimpleThreadScope;

public class CustomScopeRegisteringBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        beanFactory.registerScope("thread", new SimpleThreadScope());
    }
}

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomDateTimeDeserializer extends StdDeserializer<DateTime> {

    private static final long serialVersionUID = 1L;
    private static DateTimeFormatter format = DateTimeFormat.forPattern("yyyy-MM-dd");

    public CustomDateTimeDeserializer() {
        this(null);
    }

    public CustomDateTimeDeserializer(Class<DateTime> t) {
        super(t);
    }

    @Override
    public DateTime deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException {

        String date = parser.getText();

        return format.parseDateTime(date);

    }

}


import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.converter.MessageConverter;
import org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;
import org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandler;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketTransportRegistration;

import java.util.List;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws").setAllowedOrigins("*").withSockJS();

    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry brokerRegistry) {
        brokerRegistry.setApplicationDestinationPrefixes("/ldod-game");
        brokerRegistry.enableSimpleBroker("/topic/ldod-game/");

    }

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
    }

    @Override
    public void configureClientOutboundChannel(ChannelRegistration registration) {
    }

    @Override
    public boolean configureMessageConverters(List<MessageConverter> messageConverters) {
        return true;
    }

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
    }

    @Override
    public void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {
    }

}



import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;

@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.game")
@SpringBootApplication
@Configuration
@EnableJms
public class GameApplication extends SpringBootServletInitializer implements InitializingBean {


    public static void main(String[] args) {
        SpringApplication.run(GameApplication.class, args);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }

}


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.*;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import org.springframework.web.servlet.i18n.SessionLocaleResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;

import java.util.Locale;

@Configuration
@EnableWebMvc
public class MvcConfig implements WebMvcConfigurer {
    @Bean
    public ViewResolver getViewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/jsp/");
        resolver.setSuffix(".jsp");
        return resolver;
    }

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        String facsimilesDir = PropertiesManager.getProperties().getProperty("facsimiles.dir");
        String encodingDir = PropertiesManager.getProperties().getProperty("encoding.dir");
        registry.addResourceHandler("/webjars/**").addResourceLocations("/webjars/");
        registry.addResourceHandler("/facs/**").addResourceLocations("file:" + facsimilesDir);
        registry.addResourceHandler("/encoding/**").addResourceLocations("file:" + encodingDir);
    }

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver slr = new SessionLocaleResolver();
        slr.setDefaultLocale(new Locale("pt", "PT"));
        return slr;
    }

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor lci = new LocaleChangeInterceptor();
        lci.setParamName("lang");
        return lci;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }



}

import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import pt.ist.socialsoftware.edition.game.config.CustomScopeRegisteringBeanFactoryPostProcessor;

@Configuration
public class CustomScopeConfig {

    @Bean
    public static BeanFactoryPostProcessor beanFactoryPostProcessor() {
        return new CustomScopeRegisteringBeanFactoryPostProcessor();
    }
}


import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}


import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;


import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class ClassificationModule extends ClassificationModule_Base {
    private static final Logger logger = LoggerFactory.getLogger(ClassificationModule.class);
    public static String USER_ARS = "ars";


    public static ClassificationModule getInstance() {
        return FenixFramework.getDomainRoot().getClassificationModule();
    }
    
    public ClassificationModule() {
        FenixFramework.getDomainRoot().setClassificationModule(this);
        GameRequiresInterface.getInstance();
    }

    public void remove() {
        getClassificationGameSet().forEach(classificationGame -> classificationGame.remove());

        getPlayerSet().stream().forEach(player -> player.remove());

        setRoot(null);

        deleteDomainObject();
    }

    public Player getPlayerByUsername(String user) {
        return getPlayerSet().stream().filter(player -> player.getUser().equals(user)).findAny().orElse(null);
    }

    public Set<ClassificationGame> getClassificationGamesForEdition(String acronym){
        return getClassificationGameSet().stream().filter(g -> g.getEditionId().equals(acronym)).collect(Collectors.toSet());
    }

    public Set<ClassificationGame> getClassificationGamesForInter(String xmlId){
        return getClassificationGameSet().stream().filter(g -> g.getInterId().equals(xmlId)).collect(Collectors.toSet());
    }

    public Set<ClassificationGame> getPublicClassificationGames() {
        return getClassificationGameSet()
                .stream().filter(c -> c.getOpenAnnotation() && c.isActive()).collect(Collectors.toSet());
    }

    public Set<ClassificationGame> getActiveGames4User(String username) {
        //GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        Set<VirtualEditionDto> virtualEditions4User = GameRequiresInterface.getInstance().getVirtualEditionUserIsParticipant(username);
        Set<String> virtualEditionIds = virtualEditions4User.stream().map(VirtualEditionDto::getAcronym)
                .collect(Collectors.toSet());
        Set<ClassificationGame> classificationGamesOfUser = ClassificationModule.getInstance().getClassificationGameSet().stream()
                .filter(classificationGame -> virtualEditionIds.contains(classificationGame.getEditionId()))
                .filter(ClassificationGame::isActive)
                .collect(Collectors.toSet());

        Set<ClassificationGame> allClassificationGames4User = new HashSet<>(getPublicClassificationGames());
        allClassificationGames4User.addAll(classificationGamesOfUser);
        return allClassificationGames4User;
    }

    public Map<String, Double> getOverallLeaderboard() {
        List<Map<String, Double>> collect = getClassificationGameSet().stream()
                .map(g -> g.getLeaderboard()).collect(Collectors.toList());
        Map<String, Double> result = new LinkedHashMap<>();
        for (Map<String, Double> m : collect) {
            for (Map.Entry<String, Double> e : m.entrySet()) {
                String key = e.getKey();
                Double value = result.get(key);
                result.put(key, value == null ? e.getValue() : e.getValue() + value);
            }
        }
        return result;
    }

    public int getOverallUserPosition(String username) {
        if (!getOverallLeaderboard().containsKey(username)) {
            return -1;
        }

        Map<String, Double> temp = getOverallLeaderboard().entrySet().stream()
                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2, LinkedHashMap::new));

        return new ArrayList<>(temp.keySet()).indexOf(username) + 1;
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public static void manageDailyClassificationGames(DateTime initialDate) {
       // GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        String acronym = "VirtualModule-Jogo-Class";
        VirtualEditionDto virtualEdition = GameRequiresInterface.getInstance().getVirtualEdition(acronym);

        // generate daily games
        for (int i = 0; i < 96; i++) {
            int index = (int) Math.floor(Math.random() * GameRequiresInterface.getInstance().getVirtualEditionInterDtoSet(acronym).size());
            VirtualEditionInterDto inter = GameRequiresInterface.getInstance().getVirtualEditionInterDtoSet(acronym).stream()
                    .sorted((i1, i2) -> i1.getTitle().compareTo(i2.getTitle())).collect(Collectors.toList()).get(index);
            DateTime date = initialDate.plusMinutes(15 * (i + 48));

            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");

            String formatedDate = java.time.LocalDateTime.of(date.getYear(), date.getMonthOfYear(),
                    date.getDayOfMonth(), date.getHourOfDay(), date.getMinuteOfHour()).format(formatter);

           createClassificationGame(virtualEdition,"Jogo " + formatedDate, date, inter, USER_ARS);
        }

        Set<ClassificationGame> games = ClassificationModule.getInstance().getClassificationGameSet().stream()
                .filter(game -> game.getEditionId().equals(acronym)).collect(Collectors.toSet());

        // delete non-played games
        for (ClassificationGame game : games) {
            if (game.getDateTime().isBefore(initialDate) && game.canBeRemoved()) {
                game.remove();
            }
        }

    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public static void createClassificationGame(VirtualEditionDto virtualEdition, String description, DateTime date, VirtualEditionInterDto inter, String
            user) {
        new ClassificationGame(virtualEdition,description,date,inter,user);
    }

}




public class ClassificationGameParticipant extends ClassificationGameParticipant_Base {

    public ClassificationGameParticipant(ClassificationGame classificationGame, String user) {
        setClassificationGame(classificationGame);

        Player player = ClassificationModule.getInstance().getPlayerByUsername(user);

        if (player == null) {
            player = new Player(user);
        }

        setPlayer(player);
    }

    public void remove() {
        setClassificationGame(null);
        setPlayer(null);

        getClassificationGameRoundSet().stream().forEach(g -> g.remove());

        deleteDomainObject();
    }
}


public class ClassificationGameRound extends ClassificationGameRound_Base {
    
    public ClassificationGameRound() {
        super();
    }

    public void remove() {
        setClassificationGameParticipant(null);
        deleteDomainObject();
    }
    
}


import pt.ist.socialsoftware.edition.game.domain.ClassificationModule;

public class Player extends Player_Base {

    public Player(String user) {
        setClassificationModule(ClassificationModule.getInstance());
        setUser(user);
    }

    public void remove() {
        setClassificationModule(null);
        getClassificationGameParticipantSet().stream().forEach(p -> p.remove());

        deleteDomainObject();
    }

    public long score() {
        return 0;
        //return getClassificationGameSet().stream().filter(g -> g.getTag().getContributor() == getUser()).count();
    }

}


import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;

import pt.ist.socialsoftware.edition.notification.dtos.virtual.TagDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;


import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class ClassificationGame extends ClassificationGame_Base {
    private static final Logger logger = LoggerFactory.getLogger(ClassificationGame.class);

    public enum ClassificationGameState {
        CREATED, OPEN, STARTED, TAGGING, VOTING, REVIEWING, ABORTED, FINISHED
    }

    public static final double SUBMIT_TAG = 1;
    public static final double VOTE_CHANGE = -1;
    public static final double SUBMITTER_IS_ROUND_WINNER = 5;
    public static final double SUBMITTED_LIKE_GAME_WINNER = 5;
    public static final double SUBMITTER_IS_GAME_WINNER = 10;
    public static final double VOTED_IN_ROUND_WINNER = 2;
    public static final double VOTED_IN_GAME_WINNER = 5;

    public static final int SUBMISSION_ROUND = 1;
    public static final int VOTING_PARAGRAPH_ROUND = 2;
    public static final int VOTING_FINAL_ROUND = 3;

    public ClassificationGame(VirtualEditionDto virtualEdition, String description, DateTime date,
                              VirtualEditionInterDto inter, String user) {

        //GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        if (!GameRequiresInterface.getInstance().getOpenVocabularyStatus(virtualEdition.getAcronym())) {
            throw new LdoDException("Cannot create game due to close vocabulary");
        }

        setState(ClassificationGameState.CREATED);
        setDescription(description);
        setDateTime(date);


        setInterId(inter.getXmlId());

        setResponsible(user);

        setEditionId(virtualEdition.getAcronym());

        setClassificationModule(ClassificationModule.getInstance());
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        //GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        GameRequiresInterface.getInstance().removeTag(getTagId());

        getClassificationGameParticipantSet().stream().forEach(p -> p.remove());

        setClassificationModule(null);

        deleteDomainObject();
    }

    public boolean getOpenAnnotation() {
        //GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();
        return GameRequiresInterface.getInstance().getOpenAnnotationStatus(getEditionId());
    }

    public boolean isActive() {
        return DateTime.now().isBefore(getDateTime().plusSeconds(55));
    }

    @Atomic(mode = TxMode.WRITE)
    public void addParticipant(String user) {
       // GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        if (!getOpenAnnotation()
                && !GameRequiresInterface.getInstance().isUserParticipant(getEditionId(), user)) {
            new LdoDException("User not allowed to play this game.");
        }

        new ClassificationGameParticipant(this, user);
    }

    @Atomic(mode = TxMode.WRITE)
    public void finish() {
        if (getState().equals(ClassificationGameState.FINISHED)) {
            // CANT RECALCULATE OR FINISH A GAME AFTER GAME FINISHED
            return;
        }
        ClassificationGameParticipant participant = calculateParticipantsScores();
        String winner = participant.getPlayer().getUser();
        String tagName = getCurrentTagWinner();

        getClassificationGameParticipantSet().stream().filter(p -> p.getPlayer().getUser().equals(winner)).findFirst().get()
                .setWinner(true);

        //GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();

        TagDto tag = GameRequiresInterface.getInstance().createTag(getEditionId(), getInterId(), tagName, winner);

        setTagId(tag.getUrlId());

        /*
         * Set<User> users = players.keySet().stream().map(p ->
         * VirtualModule.getInstance().getUser(p)).collect(Collectors.toSet());
         *
         * for (User user : users) { if (user.getPlayer() == null) { new
         * Player(user); }
         *
         * user.getPlayer().addClassificationGame(this); // missing setting up the score
         * user.getPlayer().setScore(players.get(user.getUsername())); }
         */

        getClassificationGameParticipantSet().stream()
                .forEach(p -> p.getPlayer().setScore(p.getPlayer().getScore() + p.getScore()));

        setState(ClassificationGameState.FINISHED);
    }

    public boolean canBeRemoved() {
        return getTagId() == null;
    }

    public Map<String, Double> getLeaderboard() {
        List<ClassificationGameParticipant> participants = getClassificationGameParticipantSet().stream()
                .sorted(Comparator.comparing(ClassificationGameParticipant::getScore)).collect(Collectors.toList());

        Map<String, Double> result = new HashMap<>();
        for (ClassificationGameParticipant participant : participants) {
            if (participant.getPlayer() != null) {
                result.put(participant.getPlayer().getUser(), participant.getScore());
            }
        }

        return result;
    }

    public ClassificationGameParticipant getParticipant(String username) {
        return getClassificationGameParticipantSet().stream()
                .filter(p -> p.getPlayer().getUser().equals(username)).findFirst().orElse(null);
    }

    public Stream<ClassificationGameRound> getAllRounds() {
        return getClassificationGameParticipantSet().stream().flatMap(p -> p.getClassificationGameRoundSet().stream());
    }

    public String getCurrentTagWinner() {
        return getAllRounds().max(Comparator.comparing(ClassificationGameRound::getVote)).map(r -> r.getTag())
                .orElse(null);
    }

    public Set<String> getCurrentTopTags(int numberOfParagraphs) {
        return IntStream.range(0, numberOfParagraphs).mapToObj(p -> getRoundWinnerTag4Paragraph(p).getTag()).distinct()
                .collect(Collectors.toSet());
    }

    public ClassificationGameParticipant getCurrentParticipantWinner() {
        String currentTagWinner = getCurrentTagWinner();

        return getAllRounds().filter(round -> round.getTag().equals(currentTagWinner))
                .sorted(Comparator.comparing(o -> o.getTime().getMillis())).findFirst()
                .map(r -> r.getClassificationGameParticipant()).orElse(null);
    }

    private ClassificationGameParticipant calculateParticipantsScores() {
        String tagWinner = getCurrentTagWinner();

        Set<ClassificationGameRound> roundWinners = getRoundWinners(tagWinner, SUBMISSION_ROUND)
                .collect(Collectors.toSet());

        // Submission round

        // Participant that has submitted GAME winner tag FIRST than anyone receives +
        // 10
        ClassificationGameParticipant gameWinner = roundWinners.stream()
                .min(Comparator.comparing(r -> r.getTime().getMillis())).map(r -> r.getClassificationGameParticipant())
                .orElse(null);
        gameWinner.setScore(gameWinner.getScore() + SUBMITTER_IS_GAME_WINNER);

        // Participant that has submitted GAME winner tag but is NOT the first equals
        // voter receives + 5
        roundWinners.stream().map(r -> r.getClassificationGameParticipant())
                .forEach(p -> p.setScore(p.getScore() + SUBMITTED_LIKE_GAME_WINNER));

        // Paragraph submission and voting
        int numberOfParagraphs = getAllRounds()
                .sorted(Comparator.comparing(ClassificationGameRound::getNumber).reversed()).map(r -> r.getNumber())
                .findFirst().orElse(0);

        for (int paragraph = 0; paragraph < numberOfParagraphs; paragraph++) {
            ClassificationGameRound winnerRoundForParagraph = getRoundWinnerTag4Paragraph(paragraph);

            if (winnerRoundForParagraph != null) {
                // Participant that has submitted ROUND winner tag receives 5
                getRoundWinnersSubmit4Paragraph(winnerRoundForParagraph.getTag(), paragraph)
                        .map(r -> r.getClassificationGameParticipant())
                        .forEach(p -> p.setScore(p.getScore() + SUBMITTER_IS_ROUND_WINNER));

                // Participants that voted in paragraph winner tag receives + 2
                getRoundWinnersVoting4Paragraph(winnerRoundForParagraph.getTag(), paragraph)
                        .map(r -> r.getClassificationGameParticipant())
                        .forEach(p -> p.setScore(p.getScore() + VOTED_IN_ROUND_WINNER));

            }
        }

        // ------------- Round 3 ------------- //
        // Voted on game winner tag + 5
        getRoundWinners(tagWinner, VOTING_FINAL_ROUND).map(r -> r.getClassificationGameParticipant())
                .forEach(p -> p.setScore(p.getScore() + VOTED_IN_GAME_WINNER));

        // Impossible to have bellow zero so every participant gets 1 point
        getClassificationGameParticipantSet().stream().forEach(p -> p.setScore(p.getScore() < 0 ? 1 : p.getScore()));

        return gameWinner;
    }

    private Stream<ClassificationGameRound> getRoundWinners(String tagWinner, int round) {
        return getAllRounds().filter(r -> r.getTag().equals(tagWinner) && r.getRound() == round)
                .sorted(Comparator.comparing(r -> r.getTime().getMillis()));
    }

    private Stream<ClassificationGameRound> getRoundWinnersSubmit4Paragraph(String tagWinner, int paragraph) {
        return getAllRounds().filter(
                r -> r.getTag().equals(tagWinner) && r.getNumber() == paragraph && r.getRound() == SUBMISSION_ROUND);
    }

    private Stream<ClassificationGameRound> getRoundWinnersVoting4Paragraph(String tagWinner, int paragraph) {
        return getAllRounds().filter(r -> r.getTag().equals(tagWinner) && r.getNumber() == paragraph
                && r.getRound() == VOTING_PARAGRAPH_ROUND);
    }

    private ClassificationGameRound getRoundWinnerTag4Paragraph(int paragraph) {
        return getAllRounds().filter(r -> r.getNumber() == paragraph && r.getRound() == VOTING_PARAGRAPH_ROUND)
                .sorted(Comparator.comparing(ClassificationGameRound::getVote).reversed()
                        .thenComparing(Comparator.comparing(o -> o.getTime().getMillis())))
                .findFirst().orElse(null);
    }

    public double getVotesForTagInFinalRound(String tag) {
        return getAllRounds().filter(r -> r.getRound() == VOTING_FINAL_ROUND && r.getTag().equals(tag))
                .sorted((r1, r2) -> r2.getTime().compareTo(r1.getTime())).map(r -> r.getVote()).findFirst().orElse(0.0);
    }

    public double getVotesForTagInParagraph(String tag, int paragraph) {
        return getAllRounds()
                .filter(r -> r.getNumber() == paragraph && r.getRound() == VOTING_PARAGRAPH_ROUND
                        && r.getTag().equals(tag))
                .sorted((r1, r2) -> r2.getTime().compareTo(r1.getTime())).map(r -> r.getVote()).findFirst().orElse(0.0);
    }

}


import org.joda.time.DateTime;
import org.joda.time.Instant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Component;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;


import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Component
@Scope("thread")
public class GameRunner implements Runnable {
    private static final Logger logger = LoggerFactory.getLogger(GameRunner.class);
    private String gameId;
    private DateTime startTime;
    private Set<String> playersInGame;

    @Autowired
    private final SimpMessagingTemplate broker;

    @Autowired
    public GameRunner(SimpMessagingTemplate broker) {
        this.broker = broker;
    }

    public void setGameId(String gameId) {
        this.gameId = gameId;
    }

    @Override
    public void run() {
        if (canOpenGame()) {
            while (Instant.now().isBefore(this.startTime.plusMinutes(1))) {
                try {
                    Thread.sleep(600);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (canGameStart()) {
                logger.debug("running game {}", this.gameId);
                startGame();
                while (!hasGameEnded()) {
                    if (canGameContinue()) {
                        try {
                            Thread.sleep(600);
                            continueGame();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } else {
                abortGame();
            }
        }
    }

    @Atomic(mode = TxMode.WRITE)
    private synchronized boolean canOpenGame() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);

        logger.debug("running game {}", game);

        this.startTime = game.getDateTime();
        if (game.getState().equals(ClassificationGame.ClassificationGameState.CREATED)) {
            game.setState(ClassificationGame.ClassificationGameState.OPEN);
            return true;
        }
        return false;
    }

    @Atomic(mode = TxMode.READ)
    private boolean canGameStart() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);

        // TODO: inform if the game cannot start
        logger.debug("canGameStart size: {}", game.getClassificationGameParticipantSet().size());
        return game.getClassificationGameParticipantSet().size() >= 2;
    }

    @Atomic(mode = TxMode.WRITE)
    private void startGame() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);
        game.setState(ClassificationGame.ClassificationGameState.STARTED);

        this.playersInGame = game.getClassificationGameParticipantSet().stream().map(p -> p.getPlayer().getUser()).collect(Collectors.toSet());

        Map<String, String> payload = new LinkedHashMap<>();
        payload.put("currentUsers", String.valueOf(this.playersInGame.size()));
        payload.put("command", "ready");
        this.broker.convertAndSend("/topic/ldod-game/" + this.gameId + "/register", payload.values());

    }

    @Atomic(mode = TxMode.WRITE)
    private void abortGame() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);
        game.setState(ClassificationGame.ClassificationGameState.ABORTED);

        Map<String, String> payload = new LinkedHashMap<>();
        payload.put("currentUsers", String.valueOf(0));
        payload.put("command", "aborted");
        this.broker.convertAndSend("/topic/ldod-game/" + this.gameId + "/register", payload.values());
    }

    @Atomic(mode = TxMode.READ)
    private boolean canGameContinue() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);
        return game.getSync();
    }

    @Atomic(mode = TxMode.WRITE)
    private void continueGame() {
        Map<String, String> payload = new LinkedHashMap<>();
        payload.put("command", "continue");
        // Game is continuing so we change to not syncing
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);
        game.setSync(false);
        this.broker.convertAndSend("/topic/ldod-game/" + this.gameId + "/sync", payload.values());
    }

    @Atomic(mode = TxMode.READ)
    private boolean hasGameEnded() {
        ClassificationGame game = FenixFramework.getDomainObject(this.gameId);
        return game.getState().equals(ClassificationGame.ClassificationGameState.FINISHED);
    }
}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filters;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;

import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameParticipant;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameRound;
import pt.ist.socialsoftware.edition.game.domain.Player;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;


import java.io.ByteArrayInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class GameXMLImport {
    private static final Logger logger = LoggerFactory.getLogger(GameXMLImport.class);

    private Namespace namespace = null;

    public String importGamesFromTEI(InputStream inputStream) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        Document doc;
        try {
            doc = builder.build(inputStream);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }
        return processImport(doc);
    }

    public void importGamesFromTEI(String fragmentTEI) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        InputStream stream = new ByteArrayInputStream(fragmentTEI.getBytes());

        importGamesFromTEI(stream);
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    private String processImport(Document doc) {
        this.namespace = doc.getRootElement().getNamespace();
        importPlayers(doc);
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:textClass", Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));


        for (Element textClass : xp.evaluate(doc)) {

//            try {
               VirtualEditionInterDto virtualEditionInter = GameRequiresInterface.getInstance().getVirtualEditionInterFromModule(textClass.getAttributeValue("source").substring(1));
               importClassificationGames(textClass, virtualEditionInter);
//            }catch (LdoDException e) {
//
//            }
        }

        return null;
    }

    private void importPlayers(Document doc) {
        Namespace namespace = doc.getRootElement().getNamespace();
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:player", Filters.element(), null,
                Namespace.getNamespace("def", namespace.getURI()));
        for (Element playerElement : xp.evaluate(doc)) {
            String user = playerElement.getAttributeValue("user");
            double score = Double.parseDouble(playerElement.getAttributeValue("score"));
            logger.debug("BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" + user);
            Player player = new Player(user);
            player.setScore(score);
        }
    }

    private void importClassificationGames(Element textClass, VirtualEditionInterDto inter) {
        if (textClass.getChild("classificationGameList", this.namespace) == null) {
            return;
        }

        for (Element gameElement : textClass.getChild("classificationGameList", this.namespace).getChildren()) {
            ClassificationGame.ClassificationGameState state = ClassificationGame.ClassificationGameState
                    .valueOf(gameElement.getAttributeValue("state"));
            String description = gameElement.getAttributeValue("description");
            DateTime dateTime = new DateTime(DateTime.parse(gameElement.getAttributeValue("dateTime")));
            boolean sync = Boolean.parseBoolean(gameElement.getAttributeValue("sync"));
            String responsible = gameElement.getAttributeValue("responsible");
            String winner = gameElement.getAttributeValue("winningUser");

            ClassificationGame game = new ClassificationGame(inter.getVirtualEditionDto(), description, dateTime,
                    inter, responsible);

            game.setState(state);
            game.setSync(sync);
            game.setTagId(gameElement.getAttributeValue("tag"));

            importClassificationGameParticipants(gameElement, game);
            importClassificationGameRounds(gameElement, game);
        }

    }

    private void importClassificationGameRounds(Element gameElement, ClassificationGame game) {
        for (Element roundElement : gameElement.getChild("classificationGameRoundList", this.namespace).getChildren()) {
            String username = roundElement.getAttributeValue("username");

            int paragraphNumber = Integer.parseInt(roundElement.getAttributeValue("paragraphNumber"));
            int roundNumber = Integer.parseInt(roundElement.getAttributeValue("roundNumber"));
            String tag = roundElement.getAttributeValue("tag");
            double vote = Double.parseDouble(roundElement.getAttributeValue("vote"));
            DateTime dateTime = new DateTime(DateTime.parse(roundElement.getAttributeValue("dateTime")));

            ClassificationGameRound gameRound = new ClassificationGameRound();
            gameRound.setNumber(paragraphNumber);
            gameRound.setRound(roundNumber);
            gameRound.setTag(tag);
            gameRound.setVote(vote);
            gameRound.setTime(dateTime);

            ClassificationGameParticipant participant = game.getClassificationGameParticipantSet().stream()
                    .filter(p -> p.getPlayer().getUser().equals(username)).findFirst().get();
            gameRound.setClassificationGameParticipant(participant);
        }

    }

    private void importClassificationGameParticipants(Element element, ClassificationGame game) {
        for (Element participantElement : element.getChild("classificationGameParticipantList", this.namespace)
                .getChildren()) {
            String username = participantElement.getAttributeValue("username");
            boolean winner = Boolean.parseBoolean(participantElement.getAttributeValue("winner"));
            double score = Double.parseDouble(participantElement.getAttributeValue("score"));

            ClassificationGameParticipant participant = new ClassificationGameParticipant(game, username);
            participant.setWinner(winner);
            participant.setScore(score);
        }
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;


import java.io.*;
import java.nio.file.Files;
import java.util.zip.*;

public class WriteGamestoFile {
    private static final Logger logger = LoggerFactory.getLogger(WriteGamestoFile.class);

    @Atomic
    public void exportToVirtualZip(String filename) {
        String exportDir = PropertiesManager.getProperties().getProperty("export.dir");
        File directory = new File(exportDir);
        File virtualZip = new File(directory, filename);

        GameXMLExport gameXMLExport = new GameXMLExport();

        String export = gameXMLExport.export();

        // "inject" game info file into virtual zip export so it becomes invisible to virtual module
        ZipOutputStream zos;
        ZipInputStream zis;
        try {
            // copy contents of export zip file to temp file to facilitate manipulation
            File tempFile = File.createTempFile("temp-zip", ".zip");
            zos = new ZipOutputStream(new FileOutputStream(tempFile));
            zis = new ZipInputStream(new FileInputStream(virtualZip));
            for (ZipEntry ze = zis.getNextEntry(); ze != null; ze = zis.getNextEntry()) {
                    zos.putNextEntry(ze);
                    byte[] buffer = new byte[1024];
                    for (int read = zis.read(buffer); read != -1; read = zis.read(buffer)) {
                        zos.write(buffer, 0, read);
                    }
                    zos.closeEntry();
            }
            zos.close();
            zis.close();

            // delete original zip and create new file with the same name
            Files.deleteIfExists(virtualZip.toPath());
            File newZip = new File(directory, filename);

            // copy all files from the temp zip to the new file and add the new game xml export
            zos = new ZipOutputStream(new FileOutputStream(newZip));
            zis = new ZipInputStream(new FileInputStream(tempFile));
            for (ZipEntry ze = zis.getNextEntry(); ze != null; ze = zis.getNextEntry()) {
                zos.putNextEntry(ze);
                byte[] buffer = new byte[1024];
                for (int read = zis.read(buffer); read != -1; read = zis.read(buffer)) {
                    zos.write(buffer, 0, read);
                }
                zos.closeEntry();
            }
            byte[] exportBytes = export.getBytes();
            ZipEntry ze = new ZipEntry("games.xml");
            zos.putNextEntry(ze);
            zos.write(exportBytes, 0, exportBytes.length);
            zos.closeEntry();

            zos.close();
            zis.close();

        } catch (IOException e) {
            logger.debug(e.getMessage());
            throw new LdoDException("Failed to locate virtual zip export file");
        }
    }
}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGame;
import pt.ist.socialsoftware.edition.game.domain.ClassificationGameParticipant;
import pt.ist.socialsoftware.edition.game.domain.ClassificationModule;
import pt.ist.socialsoftware.edition.game.domain.Player;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;


public class GameXMLExport {
    private static final Logger logger = LoggerFactory.getLogger(GameXMLExport.class);

    private Namespace xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");

    private Document jdomDoc = null;

    @Atomic
    public String export() {
        logger.debug("Exporting classification games.");


        this.jdomDoc = new Document();
        Element rootElement = new Element("teiCorpus");
        rootElement.setNamespace(this.xmlns);
        this.jdomDoc.setRootElement(rootElement);
        Element tei = new Element("TEI", this.xmlns);
        rootElement.addContent(tei);
        Element teiHeader = new Element("teiHeader", this.xmlns);
        teiHeader.setAttribute("type", "text");
        tei.addContent(teiHeader);
        Element fileDesc = new Element("fileDesc", this.xmlns);
        teiHeader.addContent(fileDesc);
        Element sourceDesc = new Element("sourceDesc", this.xmlns);
        fileDesc.addContent(sourceDesc);



        Element listPlayer = generatePlayerList(teiHeader);
        for (Player player : ClassificationModule.getInstance().getPlayerSet()) {
            exportPlayer(listPlayer, player);
        }

        Element profileDesc = new Element("profileDesc", this.xmlns);
        teiHeader.addContent(profileDesc);
        for (VirtualEditionInterDto virtualDto : GameRequiresInterface.getInstance().getVirtualEditionInterDtoSet()) {
            if (!ClassificationModule.getInstance().getClassificationGamesForInter(virtualDto.getXmlId()).isEmpty()) {
                Element textClass = new Element("textClass", this.xmlns);
                textClass.setAttribute("source", "#" + virtualDto.getXmlId());
                profileDesc.addContent(textClass);

                Element gameList = new Element("classificationGameList", this.xmlns);
                textClass.addContent(gameList);
                for (ClassificationGame game : ClassificationModule.getInstance().getClassificationGamesForInter(virtualDto.getXmlId())) {
                    Element gameElement = new Element("classificationGame", this.xmlns);
                    gameElement.setAttribute("state", game.getState().toString());
                    gameElement.setAttribute("description", game.getDescription());
                    gameElement.setAttribute("dateTime", String.valueOf(game.getDateTime()));
                    gameElement.setAttribute("sync", Boolean.toString(game.getSync()));
                    gameElement.setAttribute("responsible", game.getResponsible());
                    if (game.getTagId() != null) {
                        gameElement.setAttribute("tag", game.getTagId());
                    }
                    ClassificationGameParticipant participant = game.getClassificationGameParticipantSet().stream()
                            .filter(ClassificationGameParticipant::getWinner).findFirst().orElse(null);
                    gameElement.setAttribute("winningUser",
                            participant != null ? participant.getPlayer().getUser() : " ");

                    exportClassificationGameRounds(gameElement, game);
                    exportClassificationGameParticipants(gameElement, game);
                    gameList.addContent(gameElement);
                }
            }
        }

        XMLOutputter xml = new XMLOutputter();
        xml.setFormat(Format.getPrettyFormat());
        //logger.debug(xml.outputString(rootElement));

        return xml.outputString(rootElement);
    }

    protected Element generatePlayerList(Element teiHeader) {
        Element playerList = new Element("playerList", this.xmlns);
        teiHeader.addContent(playerList);
        return playerList;
    }

    private void exportPlayer(Element userElement, Player player) {
        Element playerElement = new Element("player");
        playerElement.setAttribute("user", player.getUser());
        playerElement.setAttribute("score", Double.toString(player.getScore()));
        userElement.addContent(playerElement);
    }

    private void exportClassificationGameRounds(Element gameElement, ClassificationGame game) {
        Element classificationRoundList = new Element("classificationGameRoundList", this.xmlns);

        game.getAllRounds().forEach(round -> {
            Element roundElement = new Element("classificationGameRound", this.xmlns);
            roundElement.setAttribute("paragraphNumber", Integer.toString(round.getNumber()));
            roundElement.setAttribute("roundNumber", Integer.toString(round.getRound()));
            roundElement.setAttribute("tag", round.getTag());
            roundElement.setAttribute("vote", Double.toString(round.getVote()));
            roundElement.setAttribute("dateTime", String.valueOf(round.getTime()));
            roundElement.setAttribute("username",
                    round.getClassificationGameParticipant().getPlayer().getUser());
            classificationRoundList.addContent(roundElement);
        });
        gameElement.addContent(classificationRoundList);
    }

    private void exportClassificationGameParticipants(Element element, ClassificationGame game) {
        Element classificationParticipantList = new Element("classificationGameParticipantList", this.xmlns);

        for (ClassificationGameParticipant participant : game.getClassificationGameParticipantSet()) {
            Element participantElement = new Element("classificationGameParticipant", this.xmlns);
            participantElement.setAttribute("username", participant.getPlayer().getUser());
            participantElement.setAttribute("winner", Boolean.toString(participant.getWinner()));
            participantElement.setAttribute("score", Double.toString(participant.getScore()));
            classificationParticipantList.addContent(participantElement);
        }

        element.addContent(classificationParticipantList);
    }
}



import org.apache.lucene.queryparser.classic.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;

import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.text.api.dto.*;

import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.feature.generators.HtmlWriter2CompInters;
import pt.ist.socialsoftware.edition.text.feature.generators.HtmlWriter4Variations;
import pt.ist.socialsoftware.edition.text.feature.generators.PlainHtmlWriter4OneInter;
import pt.ist.socialsoftware.edition.text.feature.generators.PlainTextFragmentWriter;
import pt.ist.socialsoftware.edition.text.feature.indexer.Indexer;
import pt.ist.socialsoftware.edition.text.feature.inout.ExpertEditionTEIExport;
import pt.ist.socialsoftware.edition.text.feature.inout.LoadTEICorpus;
import pt.ist.socialsoftware.edition.text.feature.inout.LoadTEIFragments;
import pt.ist.socialsoftware.edition.text.utils.TextBootstrap;


import javax.jms.Queue;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api")
public class TextProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(TextProvidesInterface.class);


    private static Map<String, String> fragmentMap = new HashMap<>();

    @GetMapping("/cleanFragmentMapCache")
    public static void cleanFragmentMapCache() {
        fragmentMap = new HashMap<>();
    }

    private static Map<String, String> scholarInterMap = new HashMap<>();

    @GetMapping("/cleanScholarInterMapCache")
    public static void cleanScholarInterMapCache() {
        scholarInterMap = new HashMap<>();
    }


    @GetMapping("/heteronym/scholarInter/{scholarInterId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public HeteronymDto getScholarInterHeteronym(@PathVariable("scholarInterId") String scholarInterId) {
        logger.debug("getScholarInterHeteronym: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getHeteronym()).map(HeteronymDto::new).orElse(null);
    }

    @GetMapping("/heteronym/xmlId/{scholarInterId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getHeteronymXmlId(@PathVariable("scholarInterId") String scholarInterId) {
        logger.debug("getHeteronymXmlId: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getHeteronym().getXmlId()).orElse(null);
    }

    @GetMapping("/heteronyms")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<HeteronymDto> getHeteronymDtoSet() {
        logger.debug("getHeteronymDtoSet");
        return TextModule.getInstance().getHeteronymsSet().stream().map(HeteronymDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/sortedHeteronyms")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<HeteronymDto> getSortedHeteronymList() {
        logger.debug("getSortedHeteronymList");
        return TextModule.getInstance().getSortedHeteronyms().stream()
                .map(HeteronymDto::new).collect(Collectors.toList());
    }

    // Due to Visual Module
    public String getScholarInterExternalId(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getExternalId()).orElse(null);
    }

    @GetMapping("/scholarInter/{scholarInterId}/title")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getScholarInterTitle(@PathVariable(name = "scholarInterId") String scholarInterId) {
        logger.debug("getScholarInterTitle: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getTitle()).orElse(null);
    }

    @GetMapping("/scholarInter/{scholarInterId}/date")
    @Atomic(mode = Atomic.TxMode.READ)
    public LdoDDateDto getScholarInterDate(@PathVariable(name = "scholarInterId") String scholarInterId) {
        logger.debug("getScholarInterDate: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getLdoDDate()).map(LdoDDateDto::new).orElse(null);
    }

    public String getScholarInterReference(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).getReference();
    }

    public String getScholarInterEditionReference(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).getEdition().getReference();
    }

    public int getScholarInterNumber(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).getNumber();
    }

    public String getExpertInterCompleteNumber(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).map(ExpertEditionInter.class::cast).orElseThrow(LdoDException::new).getCompleteNumber();
    }

    public String getScholarInterShortName(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).getShortName();
    }

    public String getScholarInterUrlId(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).getUrlId();
    }

    @GetMapping("/scholarInter/{xmlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInter(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getScholarInter: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(ScholarInterDto::new).orElse(null);
    }

    @GetMapping("/scholarInter/{xmlId}/expertEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public ExpertEditionDto getScholarInterExpertEdition(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterExpertEdition: " + xmlId);
        return getExpertEditionByExpertEditionInterId(xmlId).map(ExpertEditionDto::new).orElse(null);
    }

    @GetMapping("/scholarInter/{xmlId}/isExpert")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isExpertInter(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("isExpertInter: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).orElseThrow(LdoDException::new).isExpertInter();
    }

    @GetMapping("/scholarInter/{xmlId}/source")
    @Atomic(mode = Atomic.TxMode.READ)
    public SourceDto getSourceOfSourceInter(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getSourceOfSourceInter: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(SourceInter.class::cast).map(SourceInter::getSource).map(SourceDto::new).orElseThrow(LdoDException::new);
    }

    @GetMapping("/scholarInter/{xmlId}/sourceInterType")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getSourceInterType(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getSourceInterType: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(SourceInter.class::cast).map(sourceInter -> sourceInter.getSource().getType().toString()).orElseThrow(LdoDException::new);
    }

    @GetMapping("/representativeSourceInter/{xmlId}/externalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getRepresentativeSourceInterExternalId(@PathVariable("xmlId") String fragmentXmlId) {
        logger.debug("getRepresentativeSourceInterExternalId: " + fragmentXmlId);
        return getFragmentByFragmentXmlId(fragmentXmlId).orElse(null).getRepresentativeSourceInter().getExternalId();
    }

    @GetMapping("/scholarInter/{xmlId}/editionAcronym")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getEditionAcronymOfInter(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getEditionAcronymOfInter: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> scholarInter.getEdition().getAcronym()).orElse(null);
    }

    @GetMapping("/expertEdition/{xmlId}/acronym")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getExpertEditionAcronym(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getExpertEditionAcronym: " + scholarInterId);

        return getExpertEditionByExpertEditionInterId(scholarInterId).map(expertEdition -> expertEdition.getAcronym()).orElse(null);
    }


    @GetMapping("/expertEdition/{xmlId}/editor")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getExpertEditionEditorByScholarInter(@PathVariable("xmlId") String scholarInterId) {
        logger.debug("getExpertEditionEditorByScholarInter: " + scholarInterId);
        return getExpertEditionByExpertEditionInterId(scholarInterId).map(expertEdition -> expertEdition.getEditor()).orElse(null);
    }

    public String getExpertEditionInterVolume(String xmlId) {
        return getScholarInterByXmlId(xmlId).filter(ExpertEditionInter.class::isInstance)
                .map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getVolume).orElseThrow(LdoDException::new);
    }

    public String getExpertEditionInterNotes(String xmlId) {
        return getScholarInterByXmlId(xmlId).filter(ExpertEditionInter.class::isInstance)
                .map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getNotes).orElseThrow(LdoDException::new);
    }

    public int getExpertEditionInterStartPage(String xmlId) {
        return getScholarInterByXmlId(xmlId).filter(ExpertEditionInter.class::isInstance)
                .map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getStartPage).orElseThrow(LdoDException::new);
    }

    public int getExpertEditionInterEndPage(String xmlId) {
        return getScholarInterByXmlId(xmlId).filter(ExpertEditionInter.class::isInstance)
                .map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getEndPage).orElseThrow(LdoDException::new);
    }

    @GetMapping("/expertEdition/{acronym}/scholarInterList")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ScholarInterDto> getExpertEditionScholarInterDtoList(@PathVariable(name = "acronym") String acronym) {
        logger.debug("getExpertEditionScholarInterDtoList: " + acronym);
        return getExpertEditionByAcronym(acronym).orElseThrow(LdoDException::new).getSortedInterps().stream().map(ScholarInterDto::new).collect(Collectors.toList());
    }

    @GetMapping("/expertEdition/{acronym}/exists")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean acronymExists(@PathVariable(name = "acronym") String acronym) {
        logger.debug("acronymExists: " + acronym);
        return getExpertEditionByAcronym(acronym).orElse(null) != null;
    }

    @GetMapping("/expertEdition/{acronym}/isExpert")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isExpertEdition(@PathVariable(name = "acronym") String acronym) {
        logger.debug("isExpertEdition: " + acronym);
        return getExpertEditionByAcronym(acronym).isPresent() ? getExpertEditionByAcronym(acronym).get().isExpertEdition() : false;
    }

    @GetMapping("/scholarEdition/{xmlId}/citednumber")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getNumberOfTimesCited(@PathVariable(name = "xmlId") String scholarInterId) {
        logger.debug("getNumberOfTimesCited: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId).map(scholarInter -> new Integer(scholarInter.getInfoRangeSet().size())).orElseThrow(LdoDException::new);
    }

    @GetMapping("/scholarEdition/{xmlId}/citednumberPlusretweets")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getNumberOfTimesCitedIncludingRetweets(@PathVariable(name = "xmlId") String scholarInterId) {
        logger.debug("getNumberOfTimesCitedIncludingRetweets: " + scholarInterId);
        return getScholarInterByXmlId(scholarInterId)
                .map(scholarInter -> scholarInter.getInfoRangeSet().stream().map(infoRange -> infoRange.getCitation().getNumberOfRetweets()).count() + 1).orElse(0L).intValue();
    }

    @GetMapping("/twitterScholarInterList")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ScholarInterDto> getScholarInterDtoListTwitterEdition(@RequestParam("beginTime") LocalDateTime editionBeginDateTime) {
        logger.debug("getScholarInterDtoListTwitterEdition: " + editionBeginDateTime);
        return TextModule.getInstance().getRZEdition().getExpertEditionIntersSet().stream()
                .filter(inter -> inter.getNumberOfTwitterCitationsSince(editionBeginDateTime) > 0)
                .sorted((inter1,
                         inter2) -> Math.toIntExact(inter2.getNumberOfTwitterCitationsSince(editionBeginDateTime)
                        - inter1.getNumberOfTwitterCitationsSince(editionBeginDateTime))).map(ScholarInterDto::new)
                .collect(Collectors.toList());
    }

    @GetMapping("/fragment/xmlId/{xmlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public FragmentDto getFragmentByXmlId(@PathVariable(name = "xmlId") String xmlId) {
        logger.debug("getFragmentByXmlId: " + xmlId);
        return getFragmentByFragmentXmlId(xmlId).map(FragmentDto::new).orElse(null);
    }

    @GetMapping("/fragment/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public FragmentDto getFragmentByExternalId(@PathVariable(name = "externalId") String externalId) {
        logger.debug("getFragmentByExternalId: " + externalId);

        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Fragment) {
            return new FragmentDto((Fragment) domainObject);
        } else {
            return null;
        }
    }

    @GetMapping("/scholarInter/fragment/{xmlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public FragmentDto getFragmentOfScholarInterDto(@PathVariable(name = "xmlId") String xmlId) {
        logger.debug("getFragmentOfScholarInterDto: " + xmlId);
        return getFragmentByInterXmlId(xmlId).map(FragmentDto::new).orElse(null);
    }

    @GetMapping("/fragment/{xmlId}/sources")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<SourceDto> getFragmentSourceSet(@PathVariable(name = "xmlId") String xmlId) {
        logger.debug("getFragmentSourceSet: " + xmlId);

        Fragment fragment = getFragmentByFragmentXmlId(xmlId).orElse(null);

        if (fragment == null) {
            return new HashSet<>();
        } else {
            Set<SourceDto> result = new HashSet<>();
            for (Source source : fragment.getSourcesSet()) {
                result.add(new SourceDto(source));
            }
            return result;
        }

        //       return getFragmentByFragmentXmlId(xmlId).orElse(null).getSourcesSet().stream().map(SourceDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/fragment/{xmlId}/scholarInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInterDtoByFragmentXmlIdAndUrlId(@PathVariable(name = "xmlId") String fragmentXmlId, @RequestParam("urlId") String scholarInterUrlId) {
        logger.debug("getScholarInterDtoByFragmentXmlIdAndUrlId: " + fragmentXmlId + "  " + scholarInterUrlId);

        ScholarInter scholarInter = getFragmentByFragmentXmlId(fragmentXmlId).orElse(null).getScholarInterByUrlId(scholarInterUrlId);
        return scholarInter != null ? new ScholarInterDto(scholarInter) : null;
    }

    @GetMapping("/fragment/{xmlId}/title")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getFragmentTitle(@PathVariable(name = "xmlId") String xmlId) {
        logger.debug("getFragmentTitle: " + xmlId );
        return getFragmentByFragmentXmlId(xmlId).map(fragment -> fragment.getTitle()).orElse(null);
    }

    // Only necessary due to manual ordering of virtual edition javascript code
    public String getFragmentExternalId(String xmlId) {
        return getFragmentByFragmentXmlId(xmlId).map(fragment -> fragment.getExternalId()).orElse(null);
    }

    @GetMapping(value = "/fragment/{xmlId}/TFIDF", params = {"terms"})
    @Atomic(mode = Atomic.TxMode.READ)
    public Map<String, Double> getFragmentTFIDF(@PathVariable(name = "xmlId") String xmlId, @RequestParam(name = "terms") List<String> commonTerms) {
        logger.debug("getFragmentTFIDF: " + xmlId + ", " + commonTerms);
        try {
            return Indexer.getIndexer().getTFIDF(getFragmentByFragmentXmlId(xmlId).get(), commonTerms);
        } catch (IOException | ParseException e) {
            throw new LdoDException("IO or Parse exception when getting tfidf from indexer");
        }
    }

    @GetMapping(value = "/fragment/{xmlId}/TFIDF", params = {"numberOfTerms"})
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getFragmentTFIDF(@PathVariable("xmlId") String xmlId, @RequestParam(name = "numberOfTerms") int numberOfTerms) {
        logger.debug("getFragmentTFIDF: " + xmlId + ", " + numberOfTerms);
        try {
            return Indexer.getIndexer().getTFIDFTerms(getFragmentByFragmentXmlId(xmlId).get(), numberOfTerms);
        } catch (IOException | ParseException e) {
            throw new LdoDException("IO or Parse exception when getting tfidf from indexer");
        }
    }

    @GetMapping("/scholarInter/{xmlId}/next")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInterNextNumberInter(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterNextNumberInter: " + xmlId );
        return getScholarInterByXmlId(xmlId).filter(ScholarInter::isExpertInter).map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getNextNumberInter).map(ScholarInterDto::new).orElse(null);
    }

    @GetMapping("/scholarInter/{xmlId}/prev")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInterPrevNumberInter(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterPrevNumberInter: " + xmlId );
        return getScholarInterByXmlId(xmlId).filter(ScholarInter::isExpertInter).map(ExpertEditionInter.class::cast)
                .map(ExpertEditionInter::getNextNumberInter).map(ScholarInterDto::new).orElse(null);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    @GetMapping("/fragments")
    public Set<FragmentDto> getFragmentDtoSet() {
        logger.debug("getFragmentDtoSet: ");
        Set<FragmentDto> result = new HashSet<>();
        for (Fragment fragment : TextModule.getInstance().getFragmentsSet()) {
            result.add(new FragmentDto(fragment));
        }
        return result;
//        return TextModule.getInstance().getFragmentsSet().stream().map(FragmentDto::new).collect(Collectors.toSet());
    }

    @Autowired
    private Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder;

    @Atomic(mode = Atomic.TxMode.READ)
    @GetMapping("/fragmentDtosWithSourceDtos")
    public List<FragmentDto> getFragmentDtosWithSourceDtos() {
        logger.debug("getFragmentDtosWithSourceDtos: ");

        List<FragmentDto> result = new ArrayList<>();
        for (Fragment fragment : TextModule.getInstance().getFragmentsSet()) {
            FragmentDto fragmentDto = new FragmentDto(fragment);
            result.add(fragmentDto);

            Set<SourceDto> sources = new HashSet<>();
            for (Source source : fragment.getSourcesSet()) {
                SourceDto sourceDto = new SourceDto(source);
                sourceDto.setSourceInters(this.getSourceIntersSet(sourceDto.getXmlId()));
                sources.add(sourceDto);
            }
            fragmentDto.setEmbeddedSourceDtos(sources);
        }

        return result;
    }

//    public Set<FragmentDto> getFragmentDtosWithSourceDtos() {
//        Set<FragmentDto> result = new HashSet<>();
//        for (Fragment fragment : TextModule.getInstance().getFragmentsSet()) {
//            FragmentDto fragmentDto = new FragmentDto(fragment);
//            result.add(fragmentDto);
//
//            Set<SourceDto> sources = new HashSet<>();
//            for (Source source : fragment.getSourcesSet()) {
//                sources.add(new SourceDto(source));
//            }
//            fragmentDto.setEmbeddedSourceDtos(sources);
//        }
//
//
//        return result;
//    }

    @GetMapping("/fragmentDtosWithScholarInterDtos")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<FragmentDto> getFragmentDtosWithScholarInterDtos() {
        logger.debug("getFragmentDtosWithScholarInterDtos: ");

        Set<FragmentDto> result = new HashSet<>();
        for (Fragment fragment : TextModule.getInstance().getFragmentsSet()) {
            FragmentDto fragmentDto = new FragmentDto(fragment);
            result.add(fragmentDto);

            Set<ScholarInterDto> scholarInterDtos = new HashSet<>();
            for (ScholarInter scholarInter : fragment.getScholarInterSet()) {
                scholarInterDtos.add(new ScholarInterDto(scholarInter));
            }
            fragmentDto.setEmbeddedScholarInterDtos(scholarInterDtos);
        }

        return result;
    }


    @GetMapping("/fragment/{xmlId}/scholarInters")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ScholarInterDto> getScholarInterDto4FragmentXmlId(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterDto4FragmentXmlId: "+ xmlId);
        return getFragmentByFragmentXmlId(xmlId).map(fragment -> fragment.getScholarInterSet()).orElse(new HashSet<>()).stream().map(ScholarInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/scholarInter/search")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ScholarInterDto> searchScholarInterForWords(@RequestParam("words") String words) {
        logger.debug("searchScholarInterForWords: "+ words);

        Indexer indexer = Indexer.getIndexer();
        return indexer.search(words).stream().map(ScholarInterDto::new).collect(Collectors.toList());
    }

    @GetMapping("/expertEdition/acronym/{acronym}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ExpertEditionDto getExpertEditionDto(@PathVariable(name = "acronym") String acronym) {
        logger.debug("getExpertEditionDto: " + acronym);
        return getExpertEditionByAcronym(acronym).map(ExpertEditionDto::new).orElse(null);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    @GetMapping("/sortedExpertEditions")
    public List<ExpertEditionDto> getSortedExpertEditionsDto() {
        logger.debug("getSortedExpertEditionsDto: ");
        return TextModule.getInstance().getSortedExpertEdition().stream().map(ExpertEditionDto::new).collect(Collectors.toList());
    }

    public String getExpertEditionEditorByEditionAcronym(String acronym) {
        return getExpertEditionByAcronym(acronym).map(expertEdition -> expertEdition.getEditor()).orElse(null);
    }


    @GetMapping("/expertEditionInters")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ExpertEditionInterListDto> getEditionInterListDto() {
        logger.debug("getEditionInterListDto: ");
        return TextModule.getInstance().getExpertEditionsSet().stream()
                .map(expertEdition -> new ExpertEditionInterListDto(expertEdition)).collect(Collectors.toList());
    }

    @GetMapping("/scholarInter/{xmlId}/transcription")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getScholarInterTranscription(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterTranscription: " + xmlId);
        ScholarInter inter = getScholarInterByXmlId(xmlId).orElse(null);
        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(inter);
        writer.write(false);
        return writer.getTranscription();
    }

    @GetMapping("/sourceInter/{xmlId}/transcription")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getSourceInterTranscription(@PathVariable("xmlId") String xmlId, @RequestParam("diff") boolean diff, @RequestParam("del") boolean del, @RequestParam("ins") boolean ins,
                                              @RequestParam("subst") boolean subst, @RequestParam("notes") boolean notes) {

        logger.debug("getSourceInterTranscription: " + xmlId);
        ScholarInter inter = getScholarInterByXmlId(xmlId).orElse(null);
        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(inter);
        writer.write(diff, del, ins, subst, notes, false, null);
        return writer.getTranscription();
    }

    @GetMapping("/expertInter/{xmlId}/transcription")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getExpertInterTranscription(@PathVariable("xmlId") String xmlId, @RequestParam("diff") boolean diff) {

        logger.debug("getExpertInterTranscription: " + xmlId);
        ScholarInter inter = getScholarInterByXmlId(xmlId).orElse(null);
        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(inter);
        writer.write(diff);
        return writer.getTranscription();
    }

    @GetMapping("/multipleInterTranscription")
    @Atomic(mode = Atomic.TxMode.READ)
    public Map<String, String> getMultipleInterTranscription(@RequestParam("externalIds") List<String> externalIds, @RequestParam("lineByLine") boolean lineByLine, @RequestParam("showSpaces") boolean showSpaces) {

        logger.debug("getMultipleInterTranscription: " + externalIds);
        List<ScholarInter> inters = new ArrayList<>();

        for (String id : externalIds) {
            ScholarInter inter = FenixFramework.getDomainObject(id);
            if (inter != null) {
                inters.add(inter);
            }
        }

        HtmlWriter2CompInters writer = new HtmlWriter2CompInters(inters.stream().map(ScholarInterDto::new).collect(Collectors.toList()));

        writer.write(lineByLine, showSpaces);

        Map<String, String> result = new LinkedHashMap<>();

        if (!lineByLine) {
            for (ScholarInter inter : inters) {
                result.put(inter.getExternalId(), writer.getTranscription(inter));
            }
        } else {
            result.put("transcription", writer.getTranscriptionLineByLine());
        }

        return result;
    }

    @GetMapping("/multipleInterVariations")
    @Atomic(mode = Atomic.TxMode.READ)
    public Map<String, List<String>> getMultipleInterVariations(@RequestParam("externalIds") List<String> externalIds) {
        logger.debug("getMultipleInterVariations: " + externalIds);
        List<ScholarInter> inters = new ArrayList<>();

        for (String id : externalIds) {
            ScholarInter inter = FenixFramework.getDomainObject(id);
            if (inter != null) {
                inters.add(inter);
            }
        }

        List<AppText> apps = new ArrayList<>();
        inters.get(0).getFragment().getTextPortion().putAppTextWithVariations(apps, inters);
        Collections.reverse(apps);

        Map<String, List<String>> variations = new HashMap<>();

        for (ScholarInter scholarInter : inters) {
            List<String> interVariation = new ArrayList<>();
            for (AppText app : apps) {
                HtmlWriter4Variations writer4Variations = new HtmlWriter4Variations(scholarInter);
                interVariation.add(writer4Variations.getAppTranscription(app));

            }
            variations.put(scholarInter.getShortName() + "#" + scholarInter.getTitle(), interVariation);
        }

        return variations;
    }

    @GetMapping("/sourceInter/{xmlId}/facUrls")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getSourceInterFacUrls(@PathVariable("xmlId") String xmlId) {
        logger.debug("getSourceInterFacUrls: " + xmlId);
        List<Surface> surfaces = getScholarInterByXmlId(xmlId).map(SourceInter.class::cast).map(SourceInter::getSource)
                .map(Source::getFacsimile).map(Facsimile::getSurfaces).orElse(null);
        return surfaces != null ? surfaces.stream().map(Surface::getGraphic).collect(Collectors.toList()) : new ArrayList<>();
    }

    @GetMapping("/scholarInter/{xmlId}/sortedAnnexNotes")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<AnnexNoteDto> getScholarInterSortedAnnexNotes(@PathVariable("xmlId") String xmlId) {
        logger.debug("getScholarInterSortedAnnexNotes: " + xmlId);
        List<AnnexNote> notes = getScholarInterByXmlId(xmlId).map(ScholarInter::getSortedAnnexNote).orElse(new ArrayList<>());
        return notes.stream().map(AnnexNoteDto::new).collect(Collectors.toList());
    }


    @GetMapping("/scholarInter/{xmlId}/termFrequency")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<Map.Entry<String, Double>> getScholarInterTermFrequency(String xmlId) {
        logger.debug("getScholarInterTermFrequency: " + xmlId);

        ScholarInter scholarInter = getScholarInterByXmlId(xmlId).orElseThrow(LdoDException::new);

        try {
            return Indexer.getIndexer().getTermFrequency(scholarInter).entrySet().stream()
                    .sorted(Comparator.comparing(Map.Entry::getValue)).collect(Collectors.toList());
        } catch (IOException | ParseException e) {
            new LdoDException("Indexer IOException or ParseException");
        }

        return null;
    }

    @GetMapping("/scholarinter/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInterbyExternalId(@PathVariable(name = "externalId") String interId) {
        logger.debug("getScholarInterbyExternalId: " + interId);

        DomainObject domainObject = FenixFramework.getDomainObject(interId);

        if (domainObject instanceof ScholarInter) {
            return new ScholarInterDto((ScholarInter) domainObject);
        }

        return null;
    }


    @GetMapping("/fragment/{xmlId}/scholarInters4Expert")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ScholarInterDto> getFragmentScholarInterDtoSetForExpertEdtion(@PathVariable("xmlId") String fragmentXmlId, @RequestParam("acronym") String acronym) {
        logger.debug("getFragmentScholarInterDtoSetForExpertEdtion: " + fragmentXmlId);

        return getFragmentByFragmentXmlId(fragmentXmlId).map(fragment -> fragment.getScholarInterSet()).orElse(new HashSet<>()).stream()
                .filter(scholarInter -> scholarInter.getEdition().getAcronym().equals(acronym)).map(ScholarInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/expertEdition/{acronym}/firstInterpretation")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getExpertEditionFirstInterpretation(@PathVariable("acronym") String acronym) {
        logger.debug("getExpertEditionFirstInterpretation: " + acronym);
        return getExpertEditionByAcronym(acronym).map(ExpertEdition::getFirstInterpretation).map(ScholarInterDto::new).orElse(null);
    }

    @GetMapping("/fragment/{xmlId}/{urlId}/scholarInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getFragmentScholarInterByUrlId(@PathVariable("xmlId") String fragmentXmlId, @PathVariable("urlId") String urlId) {
        logger.debug("getFragmentScholarInterByUrlId: " + fragmentXmlId);
        return getFragmentByFragmentXmlId(fragmentXmlId).map(fragment -> fragment.getScholarInterByUrlId(urlId)).map(ScholarInterDto::new).orElse(null);
    }

    @GetMapping("/fragment/{xmlId}/expertEditionSortedInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ScholarInterDto> getExpertEditionSortedInter4Frag(@RequestParam("acronym") String acronym, @PathVariable("xmlId") String fragmentXmlId) {
        logger.debug("getExpertEditionSortedInter4Frag: " + fragmentXmlId + ", " + acronym);
        Fragment fragment = getFragmentByFragmentXmlId(fragmentXmlId).orElse(null);
        return getExpertEditionByAcronym(acronym)
                .map(expertEdition -> expertEdition.getSortedInter4Frag(fragment).stream()
                        .map(ScholarInterDto::new).collect(Collectors.toList()))
                .orElse(new ArrayList<>());
    }


    @GetMapping("/fragment/{xmlId}/sortedSourceInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<ScholarInterDto> getFragmentSortedSourceInter(@PathVariable("xmlId") String xmlId) {
        logger.debug("getFragmentSortedSourceInter: " + xmlId);
        return getFragmentByFragmentXmlId(xmlId)
                .map(fragment -> fragment.getSortedSourceInter().stream()
                        .map(ScholarInterDto::new)
                        .collect(Collectors.toList()))
                .orElse(new ArrayList<>());
    }


    @PostMapping("/loadTEICorpus")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void LoadTEICorpus(@RequestBody byte[] bytes) {
        logger.debug("LoadTEICorpus: ");
        InputStream file = new ByteArrayInputStream(bytes);
        new LoadTEICorpus().loadTEICorpus(file);
        logger.debug("yo");
    }

    @PostMapping("/loadFragmentsAtOnce")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public String LoadFragmentsAtOnce(@RequestBody byte[] bytes) {
        logger.debug("LoadFragmentsAtOnce: ");

        InputStream file = new ByteArrayInputStream(bytes);
        return new LoadTEIFragments().loadFragmentsAtOnce(file);
    }

    @PostMapping("/loadFragmentsStepByStep")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public String LoadTEIFragmentsStepByStep(@RequestBody byte[] bytes) {
        logger.debug("LoadTEIFragmentsStepByStep: ");
        InputStream file = new ByteArrayInputStream(bytes);
        return new LoadTEIFragments().loadFragmentsStepByStep(file);
    }

    @GetMapping(value = "/writeFromPlainHtmlWriter4OneInter/", params = {"xmlId", "highlightDiff"})
    @Atomic(mode = Atomic.TxMode.READ)
    public String getWriteFromPlainHtmlWriter4OneInter(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "highlightDiff") boolean highlightDiff) {
        logger.debug("getWriteFromPlainHtmlWriter4OneInter: " + xmlId);
        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(xmlId);
        writer.write(highlightDiff);
        return writer.getTranscription();
    }

    @GetMapping("/appTextWithVariations")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> putAppTextWithVariations(@RequestParam(name = "externalId") String externalId, @RequestParam(name = "scholarInters") List<String> scholarInters) {
        logger.debug("putAppTextWithVariations: " + externalId + ", " + scholarInters);
        List<AppText> apps = new ArrayList<>();
        Fragment fragment = FenixFramework.getDomainObject(externalId);
        fragment.getTextPortion().putAppTextWithVariations(apps, scholarInters.stream()
                        .map(xmlId -> TextModule.getInstance().getScholarInterByXmlId(xmlId))
                        .collect(Collectors.toList()));
        Collections.reverse(apps);
        return apps.stream().map(appText -> appText.getExternalId()).collect(Collectors.toList());

    }

    @GetMapping(value = "/writeFromPlainHtmlWriter4OneInter/", params = {"xmlId", "displayDiff", "displayDel", "highlightIns", "highlightSubst", "showNotes", "showFacs", "pbTextId"})
    @Atomic(mode = Atomic.TxMode.READ)
    public String getWriteFromPlainHtmlWriter4OneInter(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "displayDiff") boolean displayDiff, @RequestParam(name = "displayDel") boolean displayDel, @RequestParam(name = "highlightIns") boolean highlightIns, @RequestParam(name = "highlightSubst") boolean highlightSubst, @RequestParam(name = "showNotes") boolean showNotes, @RequestParam(name = "showFacs") boolean showFacs, @RequestParam(name = "pbTextId") String pbTextId) {
        logger.debug("getWriteFromPlainHtmlWriter4OneInter: " + xmlId);
        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
        }

        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(xmlId);
        writer.write(displayDiff, displayDel, highlightIns, highlightSubst, showNotes, showFacs, pbText);
        return writer.getTranscription();
    }

    @DeleteMapping("/fragment/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeFragmentByExternalId(@PathVariable(name = "externalId") String externalId) {
        logger.debug("removeFragmentByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof Fragment) {
            fragmentMap.remove(((Fragment) domainObject).getXmlId());
            ((Fragment) domainObject).remove();
        }
    }

    @GetMapping("/exportExpertEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportExpertEditionTEI(@RequestParam(name = "query") String query) {
        logger.debug("exportExpertEditionTEI: " + query);

        Map<Fragment, Set<ScholarInter>> searchResult = new HashMap<>();

        for (Fragment frag : TextModule.getInstance().getFragmentsSet()) {
            if (frag.getTitle().contains(query)) {
                Set<ScholarInter> inters = new HashSet<>();
                for (ScholarInter inter : frag.getScholarInterSet()) {
                    inters.add(inter);
                }
                searchResult.put(frag, inters);
            }
        }

        ExpertEditionTEIExport teiGenerator = new ExpertEditionTEIExport();
        teiGenerator.generate(searchResult);
        return teiGenerator.getXMLResult();
    }

    @GetMapping("/exportAllExpertEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportAllExpertEditionTEI() {
        logger.debug("exportAllExpertEditionTEI: ");

        Map<Fragment, Set<ScholarInter>> searchResult = new HashMap<>();
        for (Fragment frag : TextModule.getInstance().getFragmentsSet()) {
            Set<ScholarInter> inters = new HashSet<>();

            for (ScholarInter inter : frag.getScholarInterSet()) {
                inters.add(inter);
            }
            searchResult.put(frag, inters);
        }

        ExpertEditionTEIExport teiGenerator = new ExpertEditionTEIExport();
        teiGenerator.generate(searchResult);
        return teiGenerator.getXMLResult();
    }

    @GetMapping("/exportRandomExpertEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportRandomExpertEditionTEI() {
        logger.debug("exportRandomExpertEditionTEI: ");

        Map<Fragment, Set<ScholarInter>> searchResult = new HashMap<>();
        List<Fragment> fragments = new ArrayList<>(TextModule.getInstance().getFragmentsSet());

        List<String> fragsRandom = new ArrayList<>();

        int size = fragments.size();

        int fragPos = 0;
        Fragment frag = null;

        for (int i = 0; i < 3; i++) {
            fragPos = (int) (Math.random() * size);
            frag = fragments.get(fragPos);

            fragsRandom.add("<a href=\"/fragments/fragment/" + frag.getExternalId() + "\">" + frag.getTitle() + "</a>");

            Set<ScholarInter> inters = new HashSet<>();
            for (ScholarInter inter : frag.getScholarInterSet()) {
                //TODO: fragments have source inters. Should they be ingnored or should the code be rewritten for shcolar inters?
                inters.add(inter);
            }
            searchResult.put(frag, inters);
        }

        ExpertEditionTEIExport teiGenerator = new ExpertEditionTEIExport();
        teiGenerator.generate(searchResult);
        return teiGenerator.getXMLResult();
    }

    @GetMapping("/citations")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<CitationDto> getCitationSet() {
        logger.debug("getCitationSet: ");
        if (TextModule.getInstance() == null) {
            return new HashSet<>();
        }

        return TextModule.getInstance()
                .getFragmentsSet().stream()
                .flatMap(f -> f.getCitationSet().stream()).map(CitationDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/citations/{id}")
    @Atomic(mode = Atomic.TxMode.READ)
    public CitationDto getCitationById(@PathVariable(name = "id") long id) {
        logger.debug("getCitationById: " + id);

        return getCitationSet().stream().filter(citation -> citation.getId() == id).findFirst().orElse(null);
    }

    @GetMapping("/citationsInfoRanges")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CitationDto> getCitationsWithInfoRanges() {
        logger.debug("getCitationsWithInfoRanges: ");

        DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

        return TextModule.getInstance()
                .getFragmentsSet().stream()
                .flatMap(f -> f.getCitationSet().stream()).filter(c -> !c.getInfoRangeSet().isEmpty())
                .sorted((c1, c2) -> LocalDateTime.parse(c2.getDate(), formater)
                        .compareTo(LocalDateTime.parse(c1.getDate(), formater)))
                .map(CitationDto::new)
                .collect(Collectors.toList());
    }

    @DeleteMapping("/removeAllCitations")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeAllCitations() {
        logger.debug("removeAllCitations: ");
        if (TextModule.getInstance() != null) {
            TextModule.getInstance().getFragmentsSet().stream().flatMap(f -> f.getCitationSet().stream()).filter(citation -> citation != null).forEach(citation -> citation.remove());
        }
    }

    @PostMapping("/createInfoRange")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createInfoRange(@RequestParam(name = "id") long id, @RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "s") String s, @RequestParam(name = "htmlStart") int htmlStart, @RequestParam(name = "s1") String s1, @RequestParam(name = "htmlEnd") int htmlEnd, @RequestParam(name = "infoQuote") String infoQuote, @RequestParam(name = "infoText") String infoText) {
        logger.debug("createInfoRange: " + id);
        Citation citation = TextModule.getInstance()
                .getFragmentsSet().stream()
                .flatMap(f -> f.getCitationSet().stream()).filter(c -> c.getId() == id).findFirst().orElse(null);


        ScholarInter sourceInter = TextModule.getInstance().getScholarInterByXmlId(xmlId);

        new InfoRange(citation, sourceInter, s, htmlStart, s1, htmlEnd, infoQuote, infoText, id);

    }

    @PostMapping("/createCitation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createCitation(@RequestParam(name = "fragXmlId") String fragXmlId, @RequestParam(name = "sourceLink") String sourceLink, @RequestParam(name = "date") String date, @RequestParam(name = "fragText") String fragText, @RequestParam(name = "id") long id) {
//        Fragment fragment = getFragmentByFragmentXmlId(fragXmlId).orElse(null);
        new Citation().init(fragXmlId, sourceLink, date, fragText, id);
    }

    @GetMapping("/isScholarInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isDomainObjectScholarInter(@RequestParam("interId") String interId) {
        logger.debug("isDomainObjectScholarInter: " + interId);
        DomainObject domainObject = FenixFramework.getDomainObject(interId);
        if (domainObject instanceof ScholarInter) {
            return true;
        }
        return false;
    }

    @GetMapping("/isScholarEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isDomainObjectScholarEdition(@RequestParam("externalId") String externalId) {
        logger.debug("isDomainObjectScholarEdition: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof ScholarEdition) {
            return true;
        }
        return false;
    }

    @GetMapping("/scholarEdition/acronym/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getScholarEditionAcronymbyExternal(@PathVariable(name = "externalId") String externalId) {
        logger.debug("getScholarEditionAcronymbyExternal: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof ScholarEdition) {
            return ((ScholarEdition) domainObject).getAcronym();
        }
        return null;
    }

    @GetMapping("/expertEdition/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ExpertEditionDto getExpertEditionByExternalId(@PathVariable(name = "externalId") String id1) {
        logger.debug("getExpertEditionByExternalId: " + id1);
        DomainObject domainObject = FenixFramework.getDomainObject(id1);
        if (domainObject instanceof ExpertEdition) {
            return new ExpertEditionDto((ExpertEdition) domainObject);
        }
        return null;
    }

    @GetMapping("/heteronym/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public HeteronymDto getHeteronymByExternalId(@PathVariable(name = "externalId") String id2) {
        logger.debug("getHeteronymByExternalId: " + id2);
        DomainObject domainObject = FenixFramework.getDomainObject(id2);
        if (domainObject instanceof Heteronym) {
            return new HeteronymDto((Heteronym) domainObject);
        }
        return null;
    }

    @GetMapping("/appTranscriptionFromHtmlWriter4Variations")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getAppTranscriptionFromHtmlWriter4Variations(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "externalAppId") String externalAppId) {
        logger.debug("getAppTranscriptionFromHtmlWriter4Variations: " + xmlId);
        HtmlWriter4Variations variations = new HtmlWriter4Variations(xmlId);
        return variations.getAppTranscription(externalAppId);
    }

    @GetMapping("/writeFromHtmlWriter2CompIntersLineByLine")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getWriteFromHtmlWriter2CompIntersLineByLine(@RequestParam(name = "scholarInters") List<String> scholarInters, @RequestParam("lineByLine") boolean lineByLine, @RequestParam("showSpaces") boolean showSpaces) {
        logger.debug("getWriteFromHtmlWriter2CompIntersLineByLine: " + scholarInters);
        HtmlWriter2CompInters writer = new HtmlWriter2CompInters(scholarInters, false);
        writer.write(lineByLine, showSpaces);
        return writer.getTranscriptionLineByLine();
    }

    @GetMapping("/transcriptionFromHtmlWriter2CompInters")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getTranscriptionFromHtmlWriter2CompInters(@RequestParam(name = "scholarInters") List<String> scholarInters, @RequestParam("inter") String inter, @RequestParam("lineByLine") boolean lineByLine, @RequestParam("showSpaces") boolean showSpaces) {
        logger.debug("getTranscriptionFromHtmlWriter2CompInters" + scholarInters);
        HtmlWriter2CompInters writer = new HtmlWriter2CompInters(scholarInters, false);
        writer.write(lineByLine, showSpaces);
        return writer.getTranscription(inter);
    }

    @GetMapping("/surface")
    @Atomic(mode = Atomic.TxMode.READ)
    public SurfaceDto getSurfaceFromPbTextId(@RequestParam(name = "pbTextId") String pbTextId, @RequestParam(name = "interID") String interID) {
        logger.debug("getSurfaceFromPbTextId" + pbTextId);
        SourceInter inter = FenixFramework.getDomainObject(interID);
        SurfaceDto surface = null;
        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
        }

        if (pbText == null) {
            surface = new SurfaceDto(inter.getSource().getFacsimile().getFirstSurface());
        } else {
            surface = new SurfaceDto(pbText.getSurface());
        }
        return surface;
    }

    @GetMapping("/surface/prev")
    @Atomic(mode = Atomic.TxMode.READ)
    public SurfaceDto getPrevSurfaceFromPbTextId(@RequestParam(name = "pbTextId") String pbTextId, @RequestParam(name = "interID") String interID) {
        logger.debug("getPrevSurfaceFromPbTextId" + pbTextId);
        SourceInter inter = FenixFramework.getDomainObject(interID);

        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
            return new SurfaceDto(inter.getPrevSurface(pbText));
        }
        return null;

    }

    @GetMapping("/surface/next")
    @Atomic(mode = Atomic.TxMode.READ)
    public SurfaceDto getNextSurfaceFromPbTextId(@RequestParam(name = "pbTextId") String pbTextId, @RequestParam(name = "interID") String interID) {
        logger.debug("getNextSurfaceFromPbTextId" + pbTextId);
        SourceInter inter = FenixFramework.getDomainObject(interID);

        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
            return new SurfaceDto(inter.getNextSurface(pbText));
        }
        return null;

    }

    @GetMapping("/prevPb/prev/externalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getPrevPbTextExternalId(@RequestParam(name = "pbTextId") String pbTextId, @RequestParam(name = "interID") String interID) {
        logger.debug("getPrevPbTextExternalId" + pbTextId);
        SourceInter inter = FenixFramework.getDomainObject(interID);

        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
        }

        if (inter.getPrevPbText(pbText) != null) {
            return  inter.getPrevPbText(pbText).getExternalId();
        }
        return null;
    }

    @GetMapping("/prevPb/next/externalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getNextPbTextExternalId(@RequestParam(name = "pbTextId") String pbTextId, @RequestParam(name = "interID") String interID) {
        logger.debug("getNextPbTextExternalId" + pbTextId);
        SourceInter inter = FenixFramework.getDomainObject(interID);

        PbText pbText = null;
        if (pbTextId != null && !pbTextId.equals("")) {
            pbText = FenixFramework.getDomainObject(pbTextId);
        }

        if (inter.getNextPbText(pbText) != null) {
            return  inter.getNextPbText(pbText).getExternalId();
        }
        return null;
    }

    @GetMapping("/initializeTextModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public boolean initializeTextModule() {
        logger.debug("initializeTextModule");
        return TextBootstrap.initializeTextModule();
    }

    @GetMapping("/clearTermsTFIDFCache")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void clearTermsTFIDFCache() {
        logger.debug("clearTermsTFIDFCache");
        Indexer.clearTermsTFIDFCache();
    }

    @GetMapping("/cleanLucene")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void cleanLucene() {
        logger.debug("cleanLucene");
        Indexer indexer = Indexer.getIndexer();
        indexer.cleanLucene();
    }

    @GetMapping("/writeFromPlainTextFragmentWriter")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getWriteFromPlainTextFragmentWriter(@RequestParam(name = "xmlId") String xmlId) {
        logger.debug("getWriteFromPlainTextFragmentWriter " + xmlId);
        PlainTextFragmentWriter writer = new PlainTextFragmentWriter(TextModule.getInstance().getScholarInterByXmlId(xmlId));
        writer.write();
        return writer.getTranscription();
    }

    @GetMapping("/fragment/citations/{xmlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<CitationDto> getFragmentCitationSet(@PathVariable(name = "xmlId") String xmlId) {
        logger.debug("getFragmentCitationSet: " + xmlId);
        return TextModule.getInstance().getFragmentByXmlId(xmlId).getCitationSet().stream().map(CitationDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/citation/{id}/infoRange")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<InfoRangeDto> getInfoRangeDtoSetFromCitation(@PathVariable(name = "id") long id) {
        logger.debug("getInfoRangeDtoSetFromCitation " + id);
        Citation citation = TextModule.getInstance()
                .getFragmentsSet().stream()
                .flatMap(f -> f.getCitationSet().stream()).filter(c -> c.getId() == id).findFirst().orElse(null);

        if (citation != null) {
            return citation.getInfoRangeSet().stream().map(InfoRangeDto::new).collect(Collectors.toSet());
        }
        return new HashSet<>();
    }



    @GetMapping("/addDocument")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addDocumentToIndexer(@RequestParam("xmlId") String xmlId) throws IOException {
        logger.debug("addDocumentToIndexer " + xmlId);
        ScholarInterDto interDto = getScholarInter(xmlId);
        Indexer indexer = Indexer.getIndexer();
        indexer.addDocument(interDto);
    }

    @GetMapping("/simpleText/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public SimpleTextDto getSimpleTextFromExternalId(@PathVariable("externalId") String startTextId) {
        logger.debug("getSimpleTextFromExternalId " + startTextId);
        DomainObject domainObject = FenixFramework.getDomainObject(startTextId);

        if (domainObject instanceof SimpleText) {
            return new SimpleTextDto((SimpleText) domainObject);
        }
        return null;
    }


    @GetMapping("/source/{xmlId}/interSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ScholarInterDto> getSourceIntersSet(@PathVariable("xmlId") String xmlId) {
        logger.debug("getSourceIntersSet " + xmlId);
        Set<SourceInter> sourceInters = getSourceByXmlId(xmlId).map(Source::getSourceIntersSet).orElse(new HashSet<>());
        return sourceInters.stream().map(ScholarInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/source/{xmlId}/heteronym")
    @Atomic(mode = Atomic.TxMode.READ)
    public HeteronymDto getHeteronym(@PathVariable("xmlId") String xmlId) {
        logger.debug("getHeteronym " + xmlId);
        return getSourceByXmlId(xmlId)
                .map(Source::getHeteronym)
                .map(HeteronymDto::new)
                .orElse(null);
    }

    @GetMapping("/source/{xmlId}/surfaces")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<SurfaceDto> getSurfaces(@PathVariable("xmlId") String xmlId) {
        logger.debug("getSurfaces " + xmlId);
        List<Surface> surfaces = getSourceByXmlId(xmlId)
                .map(Source_Base::getFacsimile)
                .map(Facsimile::getSurfaces).orElse(new ArrayList<>());
        return surfaces.stream().map(SurfaceDto::new).collect(Collectors.toList());
    }

    @GetMapping("/source/{xmlId}/LdoDDateDto")
    @Atomic(mode = Atomic.TxMode.READ)
    public LdoDDateDto getLdoDDateDto(@PathVariable("xmlId") String xmlId) {
        logger.debug("getLdoDDateDto " + xmlId);
        return getSourceByXmlId(xmlId)
                .map(Source_Base::getLdoDDate)
                .map(LdoDDateDto::new)
                .orElse(null);
    }

    @GetMapping("/source/{xmlId}/LdoDDate")
    @Atomic(mode = Atomic.TxMode.READ)
    public LdoDDateDto getLdoDDate(@PathVariable("xmlId") String xmlId) {
        logger.debug("getLdoDDate " + xmlId);
        return getSourceByXmlId(xmlId)
                .map(source -> source.getLdoDDate() != null ? new LdoDDateDto(source.getLdoDDate()) : null)
                .orElse(null);
    }

    @GetMapping("/source/{xmlId}/typeNotes")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ManuscriptNote> getTypeNoteSet(@PathVariable("xmlId") String xmlId) {
        logger.debug("getTypeNoteSet " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getHandNoteSet)
                .orElse(new HashSet<>())
                .stream().map(ManuscriptNote::new)
                .collect(Collectors.toSet());
    }


    @GetMapping("/source/{xmlId}/formattedTypeNotes")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<AbstractMap.SimpleEntry<String, String>> getFormattedTypeNote(@PathVariable("xmlId") String xmlId) {
        logger.debug("getFormattedTypeNote " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getTypeNoteSet)
                .orElse(new HashSet<>())
                .stream().map(typeNote ->
                        new AbstractMap.SimpleEntry<>((typeNote.getMedium() != null ? typeNote.getMedium().getDesc() : ""), typeNote.getNote()))
                .collect(Collectors.toList());
    }

    @GetMapping("/source/{xmlId}/handNotes")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ManuscriptNote> getHandNoteSet(@PathVariable("xmlId") String xmlId) {
        logger.debug("getHandNoteSet " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getHandNoteSet)
                .orElse(new HashSet<>())
                .stream().map(ManuscriptNote::new)
                .collect(Collectors.toSet());
    }

    @GetMapping("/source/{xmlId}/formattedHandNotes")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<AbstractMap.SimpleEntry<String, String>> getFormattedHandNote(@PathVariable("xmlId") String xmlId) {
        logger.debug("getFormattedHandNote " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getHandNoteSet)
                .orElse(new HashSet<>())
                .stream().map(handNote ->
                        new AbstractMap.SimpleEntry<>((handNote.getMedium() != null ? handNote.getMedium().getDesc() : ""), handNote.getNote()))
                .collect(Collectors.toList());
    }


    @GetMapping("/source/{xmlId}/sortedDimensions")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<DimensionsDto> getSortedDimensionsDto(@PathVariable("xmlId") String xmlId) {
        logger.debug("getSortedDimensionsDto " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getSortedDimensions)
                .orElse(new ArrayList<>())
                .stream().map(DimensionsDto::new)
                .collect(Collectors.toList());
    }

    @GetMapping("/source/{xmlId}/formattedDimensions")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getFormattedDimensions(@PathVariable("xmlId") String xmlId) {
        logger.debug("getFormattedDimensions " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getDimensionsSet)
                .orElse(new HashSet<>())
                .stream().map(dimensions -> dimensions.getHeight() + "x" + dimensions.getWidth())
                .collect(Collectors.joining(";"));
    }

    @GetMapping("/source/{xmlId}/settlement")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getSettlement(@PathVariable("xmlId") String xmlId) {
        logger.debug("getSettlement " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getSettlement)
                .orElse(null);
    }

    @GetMapping("/source/{xmlId}/repository")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getRepository(@PathVariable("xmlId") String xmlId) {
        logger.debug("getRepository " + xmlId);
        return getSourceByXmlId(xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getRepository)
                .orElse(null);
    }

    @PostMapping("/removeModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeTextModule() {
        TextModule textModule = TextModule.getInstance();

        if (textModule != null) {
            textModule.remove();
        }
    }

    //For testing purposes
    @PostMapping("/createFragment")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public FragmentDto createFragment(@RequestParam(name = "title") String title, @RequestParam(name = "xmlId") String xmlId) {
        return new FragmentDto(new Fragment(TextModule.getInstance(), title, xmlId));
    }

    @PostMapping("/createExpertInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public ScholarInterDto createExpertInter(@RequestParam(name = "fragXmlId") String fragXmlId, @RequestParam(name = "acronym") String acronym, @RequestParam(name = "xmlId") String xmlId) {
        ExpertEditionInter expertEditionInter = new ExpertEditionInter();
        expertEditionInter.setFragment(TextModule.getInstance().getFragmentByXmlId(fragXmlId));
        expertEditionInter.setExpertEdition(TextModule.getInstance().getExpertEdition(acronym));
        expertEditionInter.setXmlId(xmlId);
        return new ScholarInterDto(expertEditionInter);
    }

    @PostMapping("/createSourceInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public ScholarInterDto createSourceInter(@RequestParam(name = "fragXmlId") String fragXmlId, @RequestParam(name = "xmlId") String xmlId) {
        SourceInter sourceInter = new SourceInter();
        sourceInter.setFragment(TextModule.getInstance().getFragmentByXmlId(fragXmlId));
        sourceInter.setXmlId(xmlId);
        return new ScholarInterDto(sourceInter);
    }

    @PostMapping("/scholarInter/{xmlId}/remove")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeScholarInter(@PathVariable("xmlId") String xmlId) {
        getScholarInterByXmlId(xmlId).orElse(null).remove();
    }

    @PostMapping("/removeCitation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeCitation(@RequestParam(name = "externalId") String externalId) {
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof Citation) {
            ((Citation) domainObject).remove();
        }
    }

    private static Optional<ScholarInter> getScholarInterByXmlId(String xmlId) {
        if (xmlId == null) {
            return Optional.empty();
        }
        String scholarInterId = scholarInterMap.get(xmlId);
        if (scholarInterId == null) {
            scholarInterId = TextModule.getInstance().getFragmentsSet().stream()
                    //   .peek(fragment -> logger.debug("estou ca dentro"))
                    .flatMap(fragment -> fragment.getScholarInterSet().stream())
                    .filter(sci -> sci.getXmlId().equals(xmlId))
                    .map(sci -> sci.getExternalId())
                    .findAny().orElse(null);

            if (scholarInterId != null) {
                scholarInterMap.put(xmlId, scholarInterId);
            }
        }

        return Optional.ofNullable(scholarInterId != null ? FenixFramework.getDomainObject(scholarInterId) : null);
    }

    private Optional<Fragment> getFragmentByInterXmlId(String scholarInterId) {
        return getScholarInterByXmlId(scholarInterId).map(ScholarInter::getFragment);
    }


    private static Optional<Fragment> getFragmentByFragmentXmlId(String xmlId) {
        if (xmlId == null) {
            return Optional.empty();
        }

        String fragmentId = fragmentMap.get(xmlId);

        if (fragmentId == null) {
            fragmentId = TextModule.getInstance().getFragmentsSet().stream()
                    .filter(f -> f.getXmlId().equals(xmlId))
                    .map(f -> f.getExternalId())
                    .findAny().orElse(null);

            if (fragmentId != null) {
                fragmentMap.put(xmlId, fragmentId);
            }
        }

        return Optional.ofNullable(fragmentId != null ? FenixFramework.getDomainObject(fragmentId) : null) ;
    }

    private Optional<ExpertEdition> getExpertEditionByAcronym(String acronym) {
        return TextModule.getInstance().getExpertEditionsSet().stream().filter(expertEdition -> expertEdition.getAcronym().equals(acronym))
                .findAny();
    }

    private Optional<ExpertEdition> getExpertEditionByExpertEditionInterId(String expertEditionInterId) {
        return TextModule.getInstance().getExpertEditionsSet().stream().filter(expertEdition -> expertEdition.getFragInterByXmlId(expertEditionInterId) != null)
                .findAny();
    }

    private Optional<Source> getSourceByXmlId(String xmlId) {
        return TextModule.getInstance().getFragmentsSet().stream()
                .flatMap(fragment -> fragment.getSourcesSet().stream())
                .filter(source -> source.getXmlId().equals(xmlId))
                .findAny();
    }
}


import org.apache.activemq.command.ActiveMQTopic;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import pt.ist.socialsoftware.edition.notification.event.Event;

import javax.jms.Queue;
import javax.jms.Topic;

@Component
public class TextEventPublisher {
    private static final Logger logger = LoggerFactory.getLogger(TextEventPublisher.class);

    @Autowired
    private final Topic queue = new ActiveMQTopic("test-topic");

    @Autowired
    private JmsTemplate jmsTemplate;


    @GetMapping("/publishEvent")
    public ResponseEntity<Event> publishEvent(Event event){
        jmsTemplate.convertAndSend(queue, event);
        logger.debug("published Event!");
        return new ResponseEntity(event, HttpStatus.OK);
    }
}


import pt.ist.socialsoftware.edition.text.domain.Heteronym;
import pt.ist.socialsoftware.edition.text.domain.NullHeteronym;

public class HeteronymDto {
    private String name;

    private String xmlId;

    private String externalId;

    public HeteronymDto(Heteronym heteronym) {
        setName(heteronym.getName());
        setXmlId(heteronym.getXmlId());
        setExternalId(heteronym.getExternalId());
    }


    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public boolean isNullHeteronym() {
        return this.name.equals(NullHeteronym.NULL_NAME);
    }
}


import pt.ist.socialsoftware.edition.text.domain.SimpleText;

public class SimpleTextDto {

    private String xmlId;
    private String externalId;

    public SimpleTextDto(SimpleText simpleText) {
        this.xmlId = simpleText.getXmlId();
        this.externalId = simpleText.getExternalId();
    }

    public String getXmlId() {
        return xmlId;
    }

    public String getExternalId() {
        return externalId;
    }
}



import pt.ist.socialsoftware.edition.text.domain.Dimensions;

public class DimensionsDto {
    private final float height;
    private final float width;

    public DimensionsDto(Dimensions dimensions) {
        this.height = dimensions.getHeight();
        this.width = dimensions.getWidth();
    }

    public float getHeight() {
        return this.height;
    }

    public float getWidth() {
        return this.width;
    }
}


import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;

import pt.ist.socialsoftware.edition.text.domain.ExpertEditionInter;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;
import pt.ist.socialsoftware.edition.text.domain.SourceInter;
import pt.ist.socialsoftware.edition.text.domain.TextModule;

import java.util.List;


public class ScholarInterDto {

    private static final Logger logger = LoggerFactory.getLogger(ScholarInterDto.class);

    private final TextProvidesInterface textProvidesInterface = new TextProvidesInterface();

    private String acronym;

    private String xmlId;

    //cached attributes
    private String externalId;
    private String title;
    private String urlId;
    private String shortName;
    private boolean isExpertInter;
    private boolean isSourceInter;
    private String reference;
    private String editionReference;
    private int number;
    private String fragXmlId;
    private String volume;
    private int startPage;
    private int endPage;
    private String completeNumber;
    private String notes;

    public ScholarInterDto(String xmlId) {
        setXmlId(xmlId);
        ScholarInter scholarInter = TextModule.getInstance().getScholarInterByXmlId(xmlId);
        this.externalId = scholarInter.getExternalId();
        this.title = scholarInter.getTitle();
        this.urlId = scholarInter.getUrlId();

        if ((scholarInter.isExpertInter() && scholarInter.getEdition() != null) ||
                (!scholarInter.isExpertInter() && ((SourceInter) scholarInter).getSource() != null )) {
            this.shortName = scholarInter.getShortName();
            this.reference = scholarInter.getReference();
        }

        this.isExpertInter = scholarInter.isExpertInter();
        this.isSourceInter = !scholarInter.isExpertInter();

        if (scholarInter.getEdition() != null) {
            this.acronym = scholarInter.getEdition().getAcronym();
            this.editionReference = scholarInter.getEdition().getReference();
        }

        this.number = scholarInter.getNumber();
        this.fragXmlId = scholarInter.getFragment().getXmlId();
        this.volume = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getVolume() : null;
        this.startPage = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getStartPage() : 0;
        this.endPage = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getEndPage() : 0;
        this.notes = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getNotes() : null;
        this.completeNumber = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getCompleteNumber() : null;
    }

    public ScholarInterDto(ScholarInter scholarInter) {

        setXmlId(scholarInter.getXmlId());
        this.externalId = scholarInter.getExternalId();
        this.title = scholarInter.getTitle();
        this.urlId = scholarInter.getUrlId();

        if ((scholarInter.isExpertInter() && scholarInter.getEdition() != null) ||
                (!scholarInter.isExpertInter() && ((SourceInter) scholarInter).getSource() != null )) {
            this.shortName = scholarInter.getShortName();
            this.reference = scholarInter.getReference();
        }

        if (scholarInter.getEdition() != null) {
            this.acronym = scholarInter.getEdition().getAcronym();
            this.editionReference = scholarInter.getEdition().getReference();
        }

        this.isExpertInter = scholarInter.isExpertInter();
        this.isSourceInter = !scholarInter.isExpertInter();

        this.number = scholarInter.getNumber();
        this.fragXmlId = scholarInter.getFragment().getXmlId();
        this.volume = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getVolume() : null;
        this.startPage = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getStartPage() : 0;
        this.endPage = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getEndPage() : 0;
        this.notes = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getNotes() : null;
        this.completeNumber = this.isExpertInter ? ((ExpertEditionInter) scholarInter).getCompleteNumber() : null;

    }

    public String getAcronym() {
        return acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getExternalId() {
       //return this.textProvidesInterface.getScholarInterExternalId(this.xmlId);
        return this.externalId;
    }

    //check
//    public FragInterDto.InterType getType() {
//        //return this.textProvidesInterface.isExpertInter(this.xmlId) ? FragInterDto.InterType.EDITORIAL : FragInterDto.InterType.AUTHORIAL;
//        return this.isExpertInter ? FragInterDto.InterType.EDITORIAL : FragInterDto.InterType.AUTHORIAL;
//    }
    //temp
    public FragScholarInterDto.InterType getType(){
        return this.isExpertInter ? FragScholarInterDto.InterType.EDITORIAL : FragScholarInterDto.InterType.AUTHORIAL;
    }

    public String getFragmentXmlId() {
        //return this.textProvidesInterface.getFragmentOfScholarInterDto(this).getXmlId();
        return this.fragXmlId;
    }

    public String getReference() {
        //return this.textProvidesInterface.getScholarInterReference(this.xmlId);
        return this.reference;
    }

    public String getEditionReference() {
        //return this.textProvidesInterface.getScholarInterEditionReference(this.xmlId);
        return this.editionReference;
    }

    public int getNumber() {
        //return this.textProvidesInterface.getScholarInterNumber(this.xmlId);
        return this.number;
    }

    @JsonProperty(value = "isSourceInter")
    public boolean isSourceInter() {
        //return !this.textProvidesInterface.isExpertInter(this.xmlId);
        return this.isSourceInter;
    }

    @JsonProperty(value = "isExpertInter")
    public boolean isExpertInter() {
        //return !this.textProvidesInterface.isExpertInter(this.xmlId);
        return this.isExpertInter;
    }

//    public SourceDto getSourceDto() {
//        return this.textProvidesInterface.getSourceOfSourceInter(this.xmlId);
//    }


    public String getTitle() {
        //return this.textProvidesInterface.getScholarInterTitle(this.xmlId);
        return this.title;
    }

    public String getUrlId() {
        //return this.textProvidesInterface.getScholarInterUrlId(this.xmlId);
        return this.urlId;
    }

    public String getShortName() {
        //return this.textProvidesInterface.getScholarInterShortName(this.xmlId);
        return this.shortName;
    }

    public String getVolume() {
        //return this.textProvidesInterface.getExpertEditionInterVolume(this.xmlId);
        return this.volume;
    }

    public String getCompleteNumber() {
        //return this.textProvidesInterface.getExpertInterCompleteNumber(this.xmlId);
        return this.completeNumber;
    }

    public int getStartPage() {
        //return this.textProvidesInterface.getExpertEditionInterStartPage(this.xmlId);
        return this.startPage;
    }

    public int getEndPage() {
        //return this.textProvidesInterface.getExpertEditionInterEndPage(this.xmlId);
        return this.endPage;
    }

    public String getNotes() {
        //return this.textProvidesInterface.getExpertEditionInterNotes(this.xmlId);
        return this.notes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ScholarInterDto other = (ScholarInterDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }


    public LdoDDateDto getLdoDDate() {
         return this.textProvidesInterface.getScholarInterDate(this.xmlId);
    }

    public HeteronymDto getHeteronym() {
        return this.textProvidesInterface.getScholarInterHeteronym(this.xmlId);
    }

    public ExpertEditionDto getExpertEdition() {
        return this.textProvidesInterface.getScholarInterExpertEdition(this.xmlId);
    }

    public SourceDto getSourceDto() {
        if (isSourceInter) {
            return new TextProvidesInterface().getSourceOfSourceInter(this.xmlId);
        }
        return null;
    }

    public List<AnnexNoteDto> getSortedAnnexNote() {
           return this.textProvidesInterface.getScholarInterSortedAnnexNotes(this.xmlId);
    }

}




import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.text.domain.Fragment;
import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class FragmentDto {

    private String xmlId;

    //cached attributes
    private String title;
    private String externalId;

    private Set<SourceDto> embeddedSourceDtos = new HashSet<>(  );

    private Set<ScholarInterDto> embeddedScholarInterDtos = new HashSet<>();

    public FragmentDto(Fragment fragment) {
        setXmlId(fragment.getXmlId());
        this.title = fragment.getTitle();
        this.externalId = fragment.getExternalId();
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public Set<SourceDto> getEmbeddedSourceDtos() {
        return embeddedSourceDtos;
    }

    public void setEmbeddedSourceDtos(Set<SourceDto> embeddedSourceDtos) {
        this.embeddedSourceDtos = embeddedSourceDtos;
    }

    public Set<ScholarInterDto> getEmbeddedScholarInterDtos() {
        return embeddedScholarInterDtos;
    }

    public void setEmbeddedScholarInterDtos(Set<ScholarInterDto> embeddedScholarInterDtos) {
        this.embeddedScholarInterDtos = embeddedScholarInterDtos;
    }

    public String getTitle() {
        //return this.textProvidesInterface.getFragmentTitle(getXmlId());
        return this.title;
    }




    // Only necessary due to manual ordering of virtual edition javascript code
    public String getExternalId() {
        //return this.textProvidesInterface.getFragmentExternalId(getXmlId());
        return this.externalId;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FragmentDto other = (FragmentDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }


}


import pt.ist.socialsoftware.edition.text.domain.ScholarInter;

public class FragScholarInterDto {

    public enum InterType {
        AUTHORIAL("authorial"), EDITORIAL("editorial"), VIRTUAL("virtual");

        private final String desc;

        InterType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    private InterType type;
    private String fragmentXmlId;
    private String urlId;
    private String shortName;
    private String externalId;

    public FragScholarInterDto(ScholarInter uses) {
        setType(uses.isExpertInter() ? InterType.EDITORIAL : InterType.AUTHORIAL);
        setFragmentXmlId(uses.getFragment().getXmlId());
        setUrlId(uses.getUrlId());
        setShortName(uses.getShortName());
        setExternalId(uses.getExternalId());
    }

    public InterType getType() {
        return this.type;
    }

    public void setType(InterType type) {
        this.type = type;
    }

    public String getFragmentXmlId() {
        return this.fragmentXmlId;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getExternalId() {
        return this.externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

}


import pt.ist.socialsoftware.edition.text.domain.ExpertEdition;

import java.util.ArrayList;
import java.util.List;

public class ExpertEditionInterListDto {

    private String title;
    private String acronym;
    private String type;
    private boolean pub;
    private int numberOfInters;



    public ExpertEditionInterListDto(ExpertEdition expertEdition) {
        this.setTitle(expertEdition.getTitle() + ", Edição de " + expertEdition.getEditor());
        this.setAcronym(expertEdition.getAcronym());
        this.type = "perito";
        this.setPub(true);
        this.numberOfInters = expertEdition.getIntersSet().size();
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public boolean isPub() {
        return this.pub;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public int getNumberOfInters() {
        return this.numberOfInters;
    }

    public void setNumberOfInters(int numberOfInters) {
        this.numberOfInters = numberOfInters;
    }

    public String getType() {
        return this.type;
    }

    public void setType(String type) {
        this.type = type;
    }

}



import pt.ist.socialsoftware.edition.text.domain.Surface;

public class SurfaceDto {

    private String xmlId;

    private String graphic;

    public SurfaceDto(Surface surface){
        setXmlId(surface.getXmlId());
        setGraphic(surface.getGraphic());
    }

    public String getXmlId() {
        return xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getGraphic() {
        return graphic;
    }

    public void setGraphic(String graphic) {
        this.graphic = graphic;
    }
}



import pt.ist.socialsoftware.edition.text.domain.AnnexNote;

public class AnnexNoteDto {

    private int number;

    private String text;

    public AnnexNoteDto(AnnexNote note){
        setNumber(note.getNumber());
        setText(note.getNoteText().generatePresentationText());
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}


import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;
import pt.ist.socialsoftware.edition.text.domain.Citation;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class CitationDto {

    private final TextProvidesInterface textProvidesInterface = new TextProvidesInterface();


    private long id;
    private String externalId;
    private String date;
    private String fragmentXmlId;
    private String fragmentTitle;
    private String sourceLink;
    private boolean hasNoInfoRange;

    public CitationDto(Citation citation) {
       this.id = citation.getId();
       this.externalId = citation.getExternalId();
       this.date = citation.getDate();
       this.fragmentXmlId = citation.getFragment().getXmlId();
       this.fragmentTitle = citation.getFragment().getTitle();
       this.sourceLink = citation.getSourceLink();
       this.hasNoInfoRange = citation.getInfoRangeSet().isEmpty();
    }

    public long getId() {
        return id;
    }

    public boolean isTwitterCitation() {
        return false;
    }

    public String getExternalId() {
        return externalId;
    }

    public String getDate() {
        return date;
    }

    public String getFragmentXmlId() {
        return fragmentXmlId;
    }

    public String getFragmentTitle() {
        return fragmentTitle;
    }

    public String getSourceLink() {
        return sourceLink;
    }

    public boolean isHasNoInfoRange() {
        return hasNoInfoRange;
    }

//    public LocalDateTime getFormatedDate() {
//        DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
//        return LocalDateTime.parse(getDate(), formater);
//    }

}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.text.domain.ExpertEdition;
import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;

import java.util.List;

public class ExpertEditionDto {

    private final String acronym;

    // cached attributes
    private String editor;
    private String externalId;
    private String author;
    private String title;

    public ExpertEditionDto(ExpertEdition expertEdition) {
        this.acronym = expertEdition.getAcronym();
        this.editor = expertEdition.getEditor();
        this.externalId = expertEdition.getExternalId();
        this.author = expertEdition.getAuthor();
        this.title = expertEdition.getTitle();
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getEditor() {
        //return this.textProvidesInterface.getExpertEditionEditorByEditionAcronym(this.acronym);
        return this.editor;
    }

    public String getAuthor() {
        return author;
    }

    public String getTitle() {
        return title;
    }

    public String getExternalId() {
        return externalId;
    }

    public boolean isExpertEdition() {
        return true;
    }

    public boolean isVirtualEdition() {
        return false;
    }

}



import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;
import pt.ist.socialsoftware.edition.text.domain.*;

import java.util.*;
import java.util.stream.Collectors;

public class SourceDto {

    private final TextProvidesInterface textProvidesInterface = new TextProvidesInterface();

    private String xmlId;
    private Set<ScholarInterDto> sourceInters = new HashSet<>();

    //cached attributes
    private String name;
    private Source.SourceType type;
    private String title;
    private String idno;
    private String altIdentifier;
    private String journal;
    private String issue;
    private String pubPlace;
    private String notes;
    private int startPage;
    private int endPage;
    private ManuscriptSource.Material material;
    private ManuscriptSource.Form form;
    private int columns;
    private boolean ldoDLabel;
    private boolean hasHandNoteSet;
    private boolean hasTypeNoteSet;

    public SourceDto(Source source) {
        setXmlId(source.getXmlId());
        this.name = source.getName();
        this.idno = source.getIdno();
        this.altIdentifier = source.getAltIdentifier();
        this.type = source.getType();

        if(source.getType() == Source.SourceType.MANUSCRIPT){
            ManuscriptSource manuscriptSource = (ManuscriptSource) source;
            this.material = manuscriptSource.getMaterial();
            this.columns = manuscriptSource.getColumns();
            this.ldoDLabel = manuscriptSource.getHasLdoDLabel();
            this.hasHandNoteSet = !manuscriptSource.getHandNoteSet().isEmpty();
            this.hasTypeNoteSet = !manuscriptSource.getTypeNoteSet().isEmpty();
            this.notes = manuscriptSource.getNotes();
            this.form = manuscriptSource.getForm();
        }
        else{
            PrintedSource printedSource = (PrintedSource) source;
            this.title = printedSource.getTitle();
            this.journal = printedSource.getJournal();
            this.issue = printedSource.getIssue();
            this.startPage = printedSource.getStartPage();
            this.endPage = printedSource.getEndPage();
            this.pubPlace = printedSource.getPubPlace();
        }
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getName(){
        return this.name;
    }

    public String getTitle() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(printedSource -> printedSource.getTitle())
                .orElseThrow(LdoDException::new);*/
        return this.title;
    }

    public String getIdno() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getIdno)
                .orElse(null);*/
        return this.idno;
    }

    public ManuscriptSource.Material getMaterial() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getMaterial)
                .orElseThrow(LdoDException::new);*/
        return this.material;
    }


    public int getColumns() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getColumns)
                .orElseThrow(LdoDException::new);*/
       return this.columns;
    }

    public String getJournal() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getJournal)
                .orElse(null);*/
       return this.journal;
    }

    public String getIssue() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getIssue)
                .orElse(null);*/
        return this.issue;
    }

    public String getAltIdentifier() {
       /* return getSourceByXmlId(this.xmlId)
                .map(Source::getAltIdentifier)
                .orElse(null);*/
       return this.altIdentifier;
    }

    public String getNotes() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getNotes)
                .orElse(null);*/
        return this.notes;
    }

    public int getStartPage() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getStartPage)
                .orElseThrow(LdoDException::new);*/
        return this.startPage;
    }

    public int getEndPage() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getEndPage)
                .orElseThrow(LdoDException::new);*/
        return this.endPage;
    }

    public String getPubPlace() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getPubPlace)
                .orElse(null);*/
       return this.pubPlace;
    }

    public boolean getHasLdoDLabel() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getHasLdoDLabel)
                .orElseThrow(LdoDException::new);*/
        return this.ldoDLabel;
    }

    public boolean hasHandNoteSet() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(manuscriptSource -> !manuscriptSource.getHandNoteSet().isEmpty())
                .orElseThrow(LdoDException::new);*/
       return this.hasHandNoteSet;
    }

    public boolean hasTypeNoteSet() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(manuscriptSource -> !manuscriptSource.getTypeNoteSet().isEmpty())
                .orElseThrow(LdoDException::new);*/
        return this.hasTypeNoteSet;
    }

    public Source.SourceType getType() {
        //return getSourceByXmlId(this.xmlId).map(source -> source.getType()).orElse(null);
        return this.type;
    }



    public ManuscriptSource.Form getForm() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getForm)
                .orElse(null);*/
       return this.form;
    }


    @Atomic(mode = Atomic.TxMode.READ)
    public List<DimensionsDto> getSortedDimensionsDto() {
            return this.textProvidesInterface.getSortedDimensionsDto(this.xmlId);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ManuscriptNote> getHandNoteSet() {
        return this.textProvidesInterface.getHandNoteSet(this.xmlId);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ManuscriptNote> getTypeNoteSet() {
          return this.textProvidesInterface.getTypeNoteSet(this.xmlId);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    public LdoDDateDto getLdoDDate() {
           return this.textProvidesInterface.getLdoDDate(this.xmlId);
    }

    public List<SurfaceDto> getSurfaces() {
        return this.textProvidesInterface.getSurfaces(this.xmlId);
    }

    @Atomic(mode = Atomic.TxMode.READ)
    public Set<ScholarInterDto> getSourceIntersSet() {
        return sourceInters;
        //        return this.textProvidesInterface.getSourceIntersSet(this.xmlId);
    }

    public void setSourceInters(Set<ScholarInterDto> sourceInters) {
        this.sourceInters = sourceInters;
    }
}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.text.domain.HandNote;
import pt.ist.socialsoftware.edition.text.domain.ManuscriptSource;
import pt.ist.socialsoftware.edition.text.domain.TypeNote;

public class ManuscriptNote {
    private final ManuscriptSource.Medium medium;
    private final String note;

    public ManuscriptNote(HandNote handNote) {
        this.medium = handNote.getMedium();
        this.note = handNote.getNote();

    }

    public ManuscriptNote(TypeNote typeNote) {
        this.medium = typeNote.getMedium();
        this.note = typeNote.getNote();
    }

    public ManuscriptSource.Medium getMedium() {
        return this.medium;
    }

    public String getNote() {
        return this.note;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.LocalDate;
import pt.ist.socialsoftware.edition.text.config.CustomLocalDateSerializer;
import pt.ist.socialsoftware.edition.text.domain.Fragment;
import pt.ist.socialsoftware.edition.text.domain.LdoDDate;


public class LdoDDateDto {
    private LdoDDate.DateType type;
    private LocalDate date;
    private Fragment.PrecisionType precisionType;

    public LdoDDateDto(LdoDDate ldoDDate) {
        setType(ldoDDate.getType());
        setDate(ldoDDate.getDate());
        setPrecision(ldoDDate.getPrecision());
    }


    public String print() {
        switch (getType()) {
            case YEAR:
                return getDate().toString("yyyy");
            case DAY:
                return getDate().toString("dd-MM-yyyy");
            case MONTH:
                return getDate().toString("MM-yyyy");
            default:
                return "";
        }
    }

    public LdoDDate.DateType getType() {
        return this.type;
    }

    public void setType(LdoDDate.DateType type) {
        this.type = type;
    }

    @JsonSerialize(using = CustomLocalDateSerializer.class)
    public LocalDate getDate() {
        return this.date;
    }

    public void setDate(LocalDate date) {
        this.date = date;
    }

    public Fragment.PrecisionType getPrecision() {
        return precisionType;
    }

    public void setPrecision(Fragment.PrecisionType precisionType) {
        this.precisionType = precisionType;
    }
}


import pt.ist.socialsoftware.edition.text.domain.InfoRange;

public class InfoRangeDto {

    private String externalId;
    private String scholarInterid;
    private String start;
    private String end;
    private String quote;
    private String text;
    private int startOffset;
    private int endOffset;

    public InfoRangeDto (InfoRange infoRange) {
        this.scholarInterid = infoRange.getScholarInter().getXmlId();
        this.externalId = infoRange.getExternalId();
        this.start = infoRange.getStart();
        this.end = infoRange.getEnd();
        this.quote = infoRange.getQuote();
        this.text = infoRange.getText();
        this.startOffset = infoRange.getStartOffset();
        this.endOffset = infoRange.getEndOffset();
    }

    public String getExternalId() {
        return externalId;
    }

    public String getScholarInterid() {
        return scholarInterid;
    }

    public String getStart() {
        return start;
    }

    public String getEnd() {
        return end;
    }

    public String getText() {
        return text;
    }

    public String getQuote() {
        return quote;
    }

    public int getStartOffset() {
        return startOffset;
    }

    public int getEndOffset() {
        return endOffset;
    }
}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

import org.apache.commons.io.FileUtils;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.text.domain.TextModule;
import pt.ist.socialsoftware.edition.text.feature.inout.LoadTEICorpus;
import pt.ist.socialsoftware.edition.text.feature.inout.LoadTEIFragments;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class TextBootstrap {

    @Atomic(mode = TxMode.WRITE)
    public static boolean initializeTextModule() {
        boolean textCreate = false;
        if (TextModule.getInstance() == null) {
            new TextModule();
            cleanCorpusRepository();
            cleanIntersRepository();
            textCreate = true;
        }
        if (textCreate) {
        //    loadTextFromFile();
        }

        return textCreate;
    }

    public static void cleanCorpusRepository() {
        String corpusFilesPath = PropertiesManager.getProperties().getProperty("corpus.files.dir");
        File directory = new File(corpusFilesPath);
        if (directory.exists()) {
            try {
//                FileUtils.deleteDirectory(directory);
                FileUtils.cleanDirectory(directory);
            } catch (IOException e) {
                throw new LdoDException(
                        "Bootstrap.populateDatabaseUsersAndRoles cannot delete directory for corpus.files.dir");
            }
        }
        directory.mkdirs();
    }

    public static void cleanIntersRepository() {
        String intersFilesPath = PropertiesManager.getProperties().getProperty("inters.dir");
        File directory = new File(intersFilesPath);
        if (directory.exists()) {
            try {
                FileUtils.cleanDirectory(directory);
//                FileUtils.deleteDirectory(directory);
            } catch (IOException e) {
                throw new LdoDException(
                        "Bootstrap.populateDatabaseUsersAndRoles cannot delete directory for inters.dir");
            }
        }
        directory.mkdirs();
    }

    private static void loadTextFromFile() {
        String loadDirPath = PropertiesManager.getProperties().getProperty("load.files.dir");

        File directory = new File(loadDirPath, "text");

        File corpus = new File(directory, "001.xml");

        if (!corpus.exists()) {
            return; // File does not exist but that is not a problem. Just move on
        }

        LoadTEICorpus loadTEICorpus = new LoadTEICorpus();
        try {
            loadTEICorpus.loadTEICorpus(new FileInputStream(corpus));
        } catch (FileNotFoundException e) {
            throw new LdoDException("Failed to load text from file");
        }

        File[] files = directory.listFiles();
        if (files == null) {
            return;
        }

        LoadTEIFragments loadTEIFragments = new LoadTEIFragments();
        for (File file : files) {
            try {
                loadTEIFragments.loadFragmentsStepByStep(new FileInputStream(file));
            } catch (FileNotFoundException e) {
                throw new LdoDException("Failed to load virtual fragment");
            }
        }
    }

}


import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomLocalDateSerializer extends JsonSerializer<LocalDate> {

    private static DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");

    @Override
    public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider arg2)
            throws IOException, JsonProcessingException {

        gen.writeString(formatter.print(value));
    }
}


import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;


import javax.jms.Queue;

@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.text")
@SpringBootApplication
@Configuration
@EnableJms
public class TextApplication extends SpringBootServletInitializer implements InitializingBean {

    public static void main(String[] args) {
        SpringApplication.run(TextApplication.class, args);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
    //    TextBootstrap.initializeTextModule();
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }


    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }
}


import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}


public class AnnexNote extends AnnexNote_Base implements Comparable<AnnexNote> {

	public AnnexNote(ScholarInter inter, NoteText noteText) {
		setScholarInter(inter);
		setNoteText(noteText);

		int number = getScholarInter().getNumAnnexNotes() + 1;
		setNumber(number);
		getScholarInter().setNumAnnexNotes(number);
	}

	public AnnexNote(ScholarInter inter) {
		setScholarInter(inter);

		int number = getScholarInter().getNumAnnexNotes() + 1;
		setNumber(number);
		getScholarInter().setNumAnnexNotes(number);
	}

	public void remove() {
		setScholarInter(null);
		setNoteText(null);

		deleteDomainObject();
	}

	@Override
	public int compareTo(AnnexNote o) {
		return getNumber() > o.getNumber() ? +1
				: getNumber() < o.getNumber() ? -1 : 0;
	}

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class SpaceText extends SpaceText_Base {

    public enum SpaceDim {
        VERTICAL("vertical"), HORIZONTAL("horizontal"), UNKNOWN("unknown");

        private final String desc;

        SpaceDim(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public enum SpaceUnit {
        MINIMS("minims"), UNKNOWN("unknown");

        private final String desc;

        SpaceUnit(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public SpaceText(TextPortion parent, SpaceDim dim, int quantity,
					 SpaceUnit unit) {
        parent.addChildText(this);
        setDim(dim);
        setQuantity(quantity);
        setUnit(unit);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

}


import pt.ist.socialsoftware.edition.text.feature.indexer.Indexer;
import pt.ist.socialsoftware.edition.text.feature.topicmodelling.TopicModeler;
//import pt.ist.socialsoftware.edition.ldod.virtual.feature.topicmodeling.TopicModeler;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ExpertEditionInter extends ExpertEditionInter_Base implements Comparable<ExpertEditionInter> {
    public ExpertEditionInter() {
        setNotes("");
        setVolume("");
        setSubNumber("");
    }

    @Override
    public void remove() {

        setExpertEdition(null);

        String externalId = getExternalId();

        // remove from Lucene
        List<String> externalIds = new ArrayList<>();
        externalIds.add(externalId);
        Indexer indexer = Indexer.getIndexer();
        indexer.cleanMissingHits(externalIds);

        // remove from mallet directory
        TopicModeler topicModeler = new TopicModeler();
        topicModeler.deleteFile(externalId);

        super.remove();
    }

    @Override
    public String getShortName() {
        return getExpertEdition().getEditorShortName();
    }

    @Override
    public String getTitle() {
        String fragTitle = super.getTitle();
        if (fragTitle == null || fragTitle.trim().equals("")) {
            return getFragment().getTitle();
        } else {
            return fragTitle;
        }
    }

    @Override
    public boolean isExpertInter() {
        return true;
    }

    @Override
    public int compareTo(ExpertEditionInter other) {
        String myEditor = getExpertEdition().getEditor();
        String otherEditor = other.getExpertEdition().getEditor();

        if (myEditor.equals(otherEditor)) {
            return compareSameEditor(other);
        } else if (myEditor.equals(ExpertEdition.COELHO_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(ExpertEdition.COELHO_EDITION_NAME)) {
            return 1;
        } else if (myEditor.equals(ExpertEdition.CUNHA_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(ExpertEdition.CUNHA_EDITION_NAME)) {
            return 1;
        } else if (myEditor.equals(ExpertEdition.ZENITH_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(ExpertEdition.ZENITH_EDITION_NAME)) {
            return 1;
        } else {
            assert false : "To extend when new expert editions are include";
            return 0;
        }
    }

    public int compareSameEditor(ExpertEditionInter other) {
        int result = comparePage(other);
        if (result == 0) {
            return compareNumber(other);
        } else {
            return result;
        }
    }

    private int comparePage(ExpertEditionInter other) {
        int result = getVolume().compareTo(other.getVolume());
        if (result == 0) {
            return getStartPage() - other.getStartPage();
        } else {
            return result;
        }
    }

    private int compareNumber(ExpertEditionInter other) {
        int result = getNumber() - other.getNumber();
        if (result == 0) {
            return compareSubNumber(other);
        }
        return result;
    }

    private int compareSubNumber(ExpertEditionInter other) {
        return getSubNumber().compareTo(other.getSubNumber());
    }

    @Override
    public ScholarInter getLastUsed() {
        return this;
    }

    @Override
    public ExpertEdition getEdition() {
        return getExpertEdition();
    }

    @Override
    public String getReference() {
        return Integer.toString(getNumber());
    }

    public String getCompleteNumber() {
        return Integer.toString(getNumber()) + (!getSubNumber().equals("") ? "-" + getSubNumber() : getSubNumber());
    }

    public ExpertEditionInter getNextNumberInter() {
        List<ExpertEditionInter> interps = new ArrayList<>(this.getExpertEdition().getIntersSet());

        Collections.sort(interps);

        return findNextElementByNumber(interps);
    }

    public ExpertEditionInter getPrevNumberInter() {
        List<ExpertEditionInter> interps = new ArrayList<>(this.getExpertEdition().getIntersSet());

        Collections.sort(interps, Collections.reverseOrder());

        return findNextElementByNumber(interps);
    }


    private ExpertEditionInter findNextElementByNumber(List<ExpertEditionInter> interps) {
        Boolean stopNext = false;
        for (ExpertEditionInter tmpInter : interps) {
            if (stopNext) {
                return tmpInter;
            }
            if (tmpInter.getNumber() == getNumber() && tmpInter == this) {
                stopNext = true;
            }
        }
        return interps.get(0);
    }
}


public class InfoRange extends InfoRange_Base {


	public InfoRange(Citation citation, ScholarInter scholarInter, String start, int startOffset, String end, int endOffset,
                     String quote, String text, long citationId) {
		setCitation(citation);
		setScholarInter(scholarInter);

		setStart(start);
		setStartOffset(startOffset);
		setEnd(end);
		setEndOffset(endOffset);

		setQuote(quote);
		setText(text);

		setId(citationId);
	}


	// adicionado recentemente, testar
	public void remove() {
		setScholarInter(null);
		setCitation(null);
		deleteDomainObject();
	}
}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class RefText extends RefText_Base {

    public enum RefType {
        GRAPHIC("graphic"), WITNESS("witness"), FRAGMENT("fragment");

        private final String desc;

        RefType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    public RefText(TextPortion parent, RefType type, String target) {
        parent.addChildText(this);
        setType(type);
        setTarget(target);
        setSurface(null);
        setScholarInter(null);
        setRefFrag(null);
    }

    @Override
    public Fragment getRefFrag() {
        Fragment fragment = super.getRefFrag();
        if (fragment == null) {
            fragment = TextModule.getInstance().getFragmentByXmlId(getTarget());
            atomicWriteRefFrag(fragment);
        }
        return fragment;
    }

    @Atomic(mode = TxMode.WRITE)
    private void atomicWriteRefFrag(Fragment fragment) {
        setRefFrag(fragment);
    }

    @Override
    public void remove() {
        setSurface(null);
        setScholarInter(null);
        // it is necessary to avoid lazy reload of refFrag
        setTarget("");
        setRefFrag(null);

        super.remove();
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.text.config.BeanUtil;
import pt.ist.socialsoftware.edition.text.api.TextEventPublisher;
import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

/**
 * Contains the simple text, no line or pages breaks, spaces, formating, etc
 *
 * @author ars
 */
public class SimpleText extends SimpleText_Base {
    private static final Logger logger = LoggerFactory.getLogger(SimpleText.class);

    public SimpleText(TextPortion parent, String value) {
        parent.addChildText(this);
        setValue(value);
    }

    @Override
    public void remove() {

//        EventInterface.getInstance().publish(new Event(Event.EventType.SIMPLE_TEXT_REMOVE, this.getXmlId()));
        TextEventPublisher eventPublisher = BeanUtil.getBean(TextEventPublisher.class);
        eventPublisher.publishEvent(new Event(Event.EventType.SIMPLE_TEXT_REMOVE, this.getExternalId()));

        super.remove();
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);

    }

    @Override
    public SimpleText getNextSimpleText(ScholarInter inter) {
        return this;
    }

    @Override
    public Boolean getBreakWord() {
        return true;
    }

    @Override
    public String getSeparator(ScholarInter inter) {
        if (getInterps().contains(inter)) {
            String separators = ".,?!:;";
            String separator = null;

            String firstChar = getValue().substring(0, 1);

            if (separators.contains(firstChar) || !super.getBreakWord()) {
                separator = "";
            } else {
                separator = " ";
            }
            return separator;
        } else {
            return super.getSeparator(inter);
        }
    }

    @Override
    public SimpleText getSimpleText(ScholarInter inter, int currentOffset, int offset) {
        int nextCurrentOffset = currentOffset + getSeparator(inter).length() + getValue().length();

        logger.debug("getSimpleText value:{}, separator:{}, currentOffset:{}, offset:{}, nextCurrentOffset:{}",
                getValue(), getSeparator(inter), currentOffset, offset, nextCurrentOffset);

        if (nextCurrentOffset >= offset) {
            return this;
        } else {
            return super.getNextSimpleText(inter).getSimpleText(inter, nextCurrentOffset, offset);
        }
    }

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class AddText extends AddText_Base {

    public enum Place {
        ABOVE("above"), BELOW("below"), SUPERIMPOSED("superimposed"), MARGIN("margin"), TOP("top"), BOTTOM(
                "bottom"), INLINE("inline"), INSPACE(
                "inspace"), OVERLEAF("overleaf"), OPPOSITE("opposite"), END("end"), UNSPECIFIED("unspecified");

        private final String desc;

        Place(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public AddText(TextPortion parent, Place place) {
        parent.addChildText(this);
        setPlace(place);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst, ScholarInter fragInter) {
        if (getInterps().contains(fragInter)) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public String getNote() {
        String result = "Adicionado - " + getPlace().toString();

        return result;
    }

}


public class NullHeteronym extends NullHeteronym_Base {
    public static String NULL_NAME = "não atribuído";

    public static NullHeteronym getNullHeteronym() {
        for (Heteronym heteronym : TextModule.getInstance().getHeteronymsSet()) {
            if (heteronym instanceof NullHeteronym) {
                return (NullHeteronym) heteronym;
            }
        }
        return new NullHeteronym();
    }

    public NullHeteronym() {
        setTextModule(TextModule.getInstance());
    }

    @Override
    public boolean isNullHeteronym() {
        return true;
    }

    @Override
    public String getName() {
        return NULL_NAME;
    }

}




public class Dimensions extends Dimensions_Base {

	public Dimensions(Float height, Float width, int position) {
		setHeight(height);
		setWidth(width);
		setPosition(position);
	}

	public void remove() {
		setManuscriptSource(null);
		deleteDomainObject();
	}

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.text.config.BeanUtil;
import pt.ist.socialsoftware.edition.text.api.TextEventPublisher;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public abstract class ScholarInter extends ScholarInter_Base {
    private static final Logger logger = LoggerFactory.getLogger(ScholarInter.class);

    public String getUrlId() {
        return getXmlId().replace(".", "_");
    }

    public abstract String getShortName();

    public abstract int getNumber();

    public abstract String getTitle();

    public abstract ScholarEdition getEdition();

    public abstract boolean isExpertInter();

    public abstract ScholarInter getLastUsed();

    public abstract String getReference();

    public void remove() {

//        EventInterface.getInstance().publish(new Event(Event.EventType.SCHOLAR_INTER_REMOVE, this.getXmlId()));
        TextEventPublisher eventPublisher = BeanUtil.getBean(TextEventPublisher.class);
        eventPublisher.publishEvent(new Event(Event.EventType.SCHOLAR_INTER_REMOVE, this.getXmlId()));

        setFragment(null);
        setHeteronym(null);

        if (getLdoDDate() != null) {
            getLdoDDate().remove();
        }

        for (RdgText rdg : getRdgSet()) {
            removeRdg(rdg);
        }

        for (LbText lb : getLbTextSet()) {
            removeLbText(lb);
        }

        for (PbText pb : getPbTextSet()) {
            removePbText(pb);
        }

        for (AnnexNote annexNote : getAnnexNoteSet()) {
            annexNote.remove();
        }

        for (RefText ref : getRefTextSet()) {
            ref.setScholarInter(null);
        }

        // TODO: it does not belong to this model
        getInfoRangeSet().forEach(infoRange -> infoRange.remove());

        deleteDomainObject();
    }

    public List<AnnexNote> getSortedAnnexNote() {
        List<AnnexNote> results = new ArrayList<>(getAnnexNoteSet());

        Collections.sort(results);

        return results;
    }

    public long getNumberOfTwitterCitationsSince(LocalDateTime editionBeginDateTime) {
        return getInfoRangeSet().stream().map(ir -> ir.getCitation())
                .filter(cit -> cit.getFormatedDate().isAfter(editionBeginDateTime)).count();
    }

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class RdgText extends RdgText_Base implements GraphElement {

    public RdgText(TextPortion parent, TextPortion.VariationType type, Set<ScholarInter> fragInters) {
        parent.addChildText(this);
        setType(type);

        for (ScholarInter inter : fragInters) {
            addScholarInter(inter);
        }

    }

    @Override
    public Set<ScholarInter> getInterps() {
        return getScholarInterSet();
    }

    @Override
    protected TextPortion getNextSibilingText(ScholarInter inter) {
        return null;
    }

    @Override
    protected TextPortion getNextParentText(ScholarInter inter) {
        TextPortion parentText = getParentText();
        if (parentText != null) {
            return parentText.getNextParentText(inter);
        } else {
            return null;
        }
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst, ScholarInter fragInter) {
        return true;
    }

    @Override
    public RdgText getClosestRdg() {
        return this;
    }

    public void removeOnlyThis() {

        for (ScholarInter fragInter : getScholarInterSet()) {
            removeScholarInter(fragInter);
        }

        deleteDomainObject();
    }

    @Override
    public void remove() {
        for (ScholarInter inter : getScholarInterSet()) {
            removeScholarInter(inter);
        }

        super.remove();
    }

    @Override
    public void putAppTextWithVariations(List<AppText> apps, List<ScholarInter> inters) {
        List<ScholarInter> newInters = new ArrayList<>(inters);
        newInters.retainAll(inters);
        super.putAppTextWithVariations(apps, newInters);
    }

    @Override
    public boolean hasVariations(List<ScholarInter> inters) {
        Set<ScholarInter> intersection = new HashSet<>(inters);
        intersection.retainAll(getInterps());
        if (!intersection.isEmpty() && !getInterps().containsAll(inters)) {
            return true;
        }
        return false;
    }
}


import java.util.ArrayList;
import java.util.List;



public class Facsimile extends Facsimile_Base {

	public Facsimile(Source source, String xmlID) {
		setSource(source);
		setXmlId(xmlID);
	}

	public void addSurface(Surface surface) {
		Surface firstSurface = getFirstSurface();
		if (firstSurface == null) {
			setFirstSurface(surface);
			surface.setPrev(null);
			surface.setNext(null);
		} else {
			firstSurface.addSurface(surface);
		}
	}

	public List<Surface> getSurfaces() {
		List<Surface> surfaces = new ArrayList<Surface>();
		Surface surface = getFirstSurface();

		while (surface != null) {
			surfaces.add(surface);
			surface = surface.getNext();
		}

		return surfaces;
	}

	public void remove() {
		setSource(null);

		if (getFirstSurface() != null) {
			getFirstSurface().remove();
		}

		deleteDomainObject();
	}

}


import pt.ist.socialsoftware.edition.text.api.dto.FragmentDto;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Citation extends Citation_Base {

	public void init(Fragment fragment, String sourceLink, String date, String fragText) {
		setFragment(fragment);
		setSourceLink(sourceLink);
		setDate(date);
		setFragText(fragText);
	}

	public void init(String fragmentXmlId, String sourceLink, String date, String fragText, long id) {
		setFragment(TextModule.getInstance().getFragmentByXmlId(fragmentXmlId));
		setSourceLink(sourceLink);
		setDate(date);
		setFragText(fragText);
		setId(id);
	}

	public void remove() {
		setFragment(null);

		//getAwareAnnotationSet().stream().forEach(aa -> aa.remove());

		getInfoRangeSet().stream().forEach(infoRange -> infoRange.remove());

		deleteDomainObject();
	}


	// atualmente está a ser utilizado o método da AwareFactory em vez deste
	// TODO: não deveria ser == inter.getLastUsed() ??
	public InfoRange getInfoRangeByInter(ScholarInter inter) {
		return getInfoRangeSet().stream().filter(infoRange -> infoRange.getScholarInter() == inter).findFirst()
				.orElse(null);
	}

	public int getNumberOfRetweets() {
		return 0;
	}

	public LocalDateTime getFormatedDate() {
		DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
		return LocalDateTime.parse(getDate(), formater);
	}

	public boolean isTwitterCitation() { return false; }
}


import pt.ist.socialsoftware.edition.notification.utils.DateUtils;
import pt.ist.socialsoftware.edition.text.domain.Fragment.PrecisionType;


public class LdoDDate extends LdoDDate_Base {
	public  enum DateType {
		YEAR, MONTH, DAY
	}

	public LdoDDate(String value, PrecisionType precision) {
		setDate(DateUtils.convertDate(value));
		if (value.length() == 4) {
			setType(DateType.YEAR);
		} else if (value.length() == 7) {
			setType(DateType.MONTH);
		} else if (value.length() == 10) {
			setType(DateType.DAY);
		} else {
			setType(null);
		}
		setPrecision(precision);
	}

	public void remove() {
		setScholarInter(null);
		setSource(null);
	}

	public String print() {
		switch (getType()) {
		case YEAR:
			return getDate().toString("yyyy");
		case DAY:
			return getDate().toString("dd-MM-yyyy");
		case MONTH:
			return getDate().toString("MM-yyyy");
		default:
			return "";
		}
	}

}



import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class AppText extends AppText_Base {

    public AppText(TextPortion parent, TextPortion.VariationType type) {
        if (parent != null) {
            parent.addChildText(this);
        }

        setType(type);
    }

    public AppText(TextPortion.VariationType type) {
        setParentText(null);

        setType(type);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    protected TextPortion getNextChildText(ScholarInter inter) {
        if (this.getInterps().contains(inter)) {
            for (TextPortion childText : getChildTextSet()) {
                if (childText.getInterps().contains(inter)) {
                    return childText;
                }
            }
        }
        return null;
    }

    @Override
    public void putAppTextWithVariations(List<AppText> apps, List<ScholarInter> inters) {
        if (hasVariations(inters) && hasNotTransitiveParent(apps)) {
            apps.add(this);
        }

        super.putAppTextWithVariations(apps, inters);
    }

    private boolean hasNotTransitiveParent(List<AppText> apps) {
        for (AppText appText : apps) {
            if (appText.isTransitiveParent(this)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean hasVariations(List<ScholarInter> inters) {
        Set<RdgText> rdgChildSet = getChildRdgTextSet();

        for (RdgText rdg : rdgChildSet) {
            if (rdg.hasVariations(inters)) {
                return true;
            }
        }

        return false;
    }

    private Set<RdgText> getChildRdgTextSet() {
        Set<RdgText> rdgs = new HashSet<>();
        for (TextPortion text : getChildTextSet()) {
            if (text instanceof RdgText) {
                rdgs.add((RdgText) text);
            } else if (text instanceof RdgGrpText) {
                rdgs.addAll(((RdgGrpText) text).getChildRdgTextSet());
            }
        }
        return rdgs;
    }

}


import pt.ist.socialsoftware.edition.text.domain.RefText.RefType;
import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class NoteText extends NoteText_Base {

    public enum NoteType {
        ANNEX("annex");

        private final String desc;

        NoteType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public NoteText(TextPortion parent, NoteType type) {
        parent.addChildText(this);

        setType(type);

        if (type == NoteType.ANNEX) {
            for (ScholarInter inter : getInterps()) {
                new AnnexNote(inter, this);
            }
        }
    }

    public NoteText(AnnexNote annexNote, NoteType type) {
        setParentText(null);
        setType(type);
        addAnnexNote(annexNote);
    }

    @Override
    public void remove() {
        for (AnnexNote annexNote : getAnnexNoteSet()) {
            annexNote.remove();
        }

        super.remove();
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    // TODO: To consider whether a complete generation, without using the
    // visitors will be needed in the future
    public String generatePresentationText() {
        String result = "";

        TextPortion text = getFirstChildText();
        while (text != null) {
            if (text instanceof SimpleText) {
                SimpleText stext = (SimpleText) text;
                result = result + stext.getValue() + " ";
            } else if (text instanceof RefText) {
                RefText refText = (RefText) text;
                String link = "#";
                if (refText.getType() == RefType.GRAPHIC) {
                    link = "/facs/" + refText.getSurface().getGraphic();
                } else if (refText.getType() == RefType.WITNESS) {
                    link = "/fragments/fragment/" + refText.getScholarInter().getFragment().getXmlId() + "/inter/"
                            + refText.getScholarInter().getUrlId();
                } else if (refText.getType() == RefType.FRAGMENT) {
                    if (refText.getRefFrag() != null) {
                        link = "/fragments/fragment/" + refText.getRefFrag().getXmlId();
                    } else {
                        // this situation should never occur if the fragments
                        // were consistently loaded
                        link = "/fragments/fragment/" + refText.getTarget();
                    }
                }
                result = result + "<a href=\"" + link + "\">";
                SimpleText childText = (SimpleText) text.getFirstChildText();
                result = result + childText.getValue() + "</a> ";
            }

            text = text.getNextText();
        }

        return result;
    }
}


public class Surface extends Surface_Base {

	public Surface(Facsimile facsimile, String graphic) {
		facsimile.addSurface(this);
		setGraphic(graphic);
	}

	public Surface(Facsimile facsimile, String graphic, String xmlId) {
		facsimile.addSurface(this);
		setGraphic(graphic);
		setXmlId(xmlId);
	}

	public void addSurface(Surface surface) {
		Surface next = getNext();

		if (next == null) {
			surface.setFacsimile(null);
			surface.setNext(null);
			this.setNext(surface);
		} else {
			next.addSurface(surface);
		}
	}

	public void remove() {
		setFacsimile(null);
		setPrev(null);

		if (getFacsimile() != null) {
			setFacsimile(null);
		}

		if (getNext() != null) {
			getNext().remove();
		}

		for (RefText ref : getRefTextSet()) {
			ref.setSurface(null);
		}

		for (PbText pbText : getPbTextSet()) {
			removePbText(pbText);
		}

		deleteDomainObject();
	}

}



import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class DelText extends DelText_Base {

    public enum HowDel {
        OVERSTRIKE("overstrike"), OVERTYPED("overtyped"), OVERWRITTEN("overwritten"), UNSPECIFIED("unspecified");

        private final String desc;

        HowDel(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public DelText(TextPortion parent, HowDel how) {
        parent.addChildText(this);
        setHow(how);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst, ScholarInter fragInter) {
        if (getInterps().contains(fragInter) && displayDel) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public String getNote() {
        String result = "Retirado - " + getHow().toString();

        return result;
    }

}


import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class ManuscriptSource extends ManuscriptSource_Base {

    public enum Form {
        LEAF
    }

    public enum Material {
        PAPER
    }

    public enum Medium {
        PEN("pen"), PENCIL("pencil"), BLUE_INK("blue-ink"), BLACK_INK("black-ink"), VIOLET_INK("violet-ink"), RED_INK(
                "red-ink"), GREEN_INK("green-ink");

        private final String desc;

        Medium(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    public ManuscriptSource() {
        super();
        setType(Source.SourceType.MANUSCRIPT);
        setHasLdoDLabel(false);
    }

    @Override
    public void remove() {
        getDimensionsSet().stream().forEach(d -> d.remove());

        for (HandNote handNote : getHandNoteSet()) {
            handNote.remove();
        }

        for (TypeNote typeNote : getTypeNoteSet()) {
            typeNote.remove();
        }

        super.remove();
    }

    public List<Dimensions> getSortedDimensions() {
        return getDimensionsSet().stream().sorted(Comparator.comparing(Dimensions::getPosition))
                .collect(Collectors.toList());
    }

}

/**
 *
 */

import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

/**
 * An interface for the text graph elements: Reading, VariationPoint and LdoText
 * and its subclasses
 *
 * @author ars
 *
 */
public interface GraphElement {
    public void accept(TextPortionVisitor visitor);

}




import java.util.HashSet;
import java.util.Set;

public class NullEdition extends NullEdition_Base {

    @Override
    public Boolean getPub() {
        return true;
    }

    public void remove() {
        setTextModule4NullEdition(null);
        deleteDomainObject();
    }

    public Set<ScholarInter> getIntersSet() {
        return new HashSet<>();
    }

    @Override
    public String getReference() {
        return "";
    }

    @Override
    public String getAcronym() {
        return "";
    }
}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.Set;

public class LbText extends LbText_Base {

    public LbText(TextPortion parent, Boolean isBreak, Boolean isHyphenated,
				  Set<ScholarInter> interps) {
        parent.addChildText(this);

        setBreakWord(isBreak);
        setHyphenated(isHyphenated);

        for (ScholarInter inter : interps) {
            addScholarInter(inter);
        }
    }

    @Override
    public Set<ScholarInter> getInterps() {
        return getScholarInterSet();
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);

    }

    @Override
    public void remove() {
        for (ScholarInter inter : getScholarInterSet()) {
            removeScholarInter(inter);
        }

        super.remove();
    }
}



import pt.ist.socialsoftware.edition.text.domain.ManuscriptSource.Medium;

public class TypeNote extends TypeNote_Base {

	public TypeNote(Medium medium, String note) {
		setMedium(medium);
		setNote(note);
	}

	@Override
	public void remove() {
		setManuscript(null);

		super.remove();
	}

}


public abstract class Source extends Source_Base implements Comparable<Source> {

    public enum SourceType {
        MANUSCRIPT("manuscript"), PRINTED("printed");

        private final String desc;

        SourceType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    public Source() {
        setHeteronym(NullHeteronym.getNullHeteronym());
    }

    public String getName() {
        return getAltIdentifier();
    }

    public void remove() {
        setHeteronym(null);
        setFragment(null);

        if (getLdoDDate() != null) {
            getLdoDDate().remove();
        }

        // A source may not have a facsimile ???? - need to be checked with
        // encoders
        if (getFacsimile() != null) {
            getFacsimile().remove();
        }

        for (SourceInter inter : getSourceIntersSet()) {
            removeSourceInters(inter);
        }

        deleteDomainObject();
    }

    @Override
    public int compareTo(Source other) {
        return getName().compareTo(other.getName());
    }

}

import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class SegText extends SegText_Base {

    public SegText(TextPortion parent) {
        parent.addChildText(this);
    }

    @Override
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst,
							ScholarInter fragInter) {
        if (getInterps().contains(fragInter)) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void remove() {
        setAltTextWeight(null);

        super.remove();
    }

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class ParagraphText extends ParagraphText_Base {

    public ParagraphText(TextPortion parent) {
        parent.addChildText(this);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

}


import org.joda.time.LocalDate;


import java.util.*;
import java.util.stream.Collectors;

public class ExpertEdition extends ExpertEdition_Base implements Comparable<ExpertEdition> {
    public static final String COELHO_EDITION_ACRONYM = "JPC";
    public static final String CUNHA_EDITION_ACRONYM = "TSC";
    public static final String ZENITH_EDITION_ACRONYM = "RZ";
    public static final String PIZARRO_EDITION_ACRONYM = "JP";
    public static final String COELHO_EDITION_NAME = "Jacinto do Prado Coelho";
    public static final String CUNHA_EDITION_NAME = "Teresa Sobral Cunha";
    public static final String ZENITH_EDITION_NAME = "Richard Zenith";
    public static final String PIZARRO_EDITION_NAME = "Jerónimo Pizarro";

    public ExpertEdition(TextModule text, String title, String author, String editor, LocalDate date) {
        setTitle(title);
        setAuthor(author);
        setEditor(editor);
        setDate(date);
        setPub(true);

        switch (editor) {
            case COELHO_EDITION_NAME:
                setAcronym(COELHO_EDITION_ACRONYM);
                break;
            case CUNHA_EDITION_NAME:
                setAcronym(CUNHA_EDITION_ACRONYM);
                break;
            case ZENITH_EDITION_NAME:
                setAcronym(ZENITH_EDITION_ACRONYM);
                break;
            case PIZARRO_EDITION_NAME:
                setAcronym(PIZARRO_EDITION_ACRONYM);
                break;
            default:
                assert false : "Nome de editor com erros: " + editor;
        }
        setTextModule4Expert(text);
    }

    public void remove() {
        setTextModule4Expert(null);
        getExpertEditionIntersSet().forEach(i -> i.remove());
        deleteDomainObject();
    }

    public boolean isExpertEdition() {
        return true;
    }

    @Override
    public int compareTo(ExpertEdition other) {
        String myEditor = getEditor();
        String otherEditor = other.getEditor();

        if (myEditor.equals(otherEditor)) {
            return 0;
        } else if (myEditor.equals(COELHO_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(COELHO_EDITION_NAME)) {
            return 1;
        } else if (myEditor.equals(CUNHA_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(CUNHA_EDITION_NAME)) {
            return 1;
        } else if (myEditor.equals(ZENITH_EDITION_NAME)) {
            return -1;
        } else if (otherEditor.equals(ZENITH_EDITION_NAME)) {
            return 1;
        } else {
            assert false : "To extend when new expert editions are include";
            return 0;
        }
    }


    public String getEditorShortName() {
        if (getEditor().equals(COELHO_EDITION_NAME)) {
            return "Coelho";
        } else if (getEditor().equals(CUNHA_EDITION_NAME)) {
            return "Cunha";
        } else if (getEditor().equals(ZENITH_EDITION_NAME)) {
            return "Zenith";
        } else if (getEditor().equals(PIZARRO_EDITION_NAME)) {

            return "Pizarro";
        } else {
            assert false;
            return null;
        }
    }

    public List<ExpertEditionInter> getSortedInter4Frag(Fragment fragment) {
        List<ExpertEditionInter> interps = new ArrayList<>();


        for (ScholarInter inter : fragment.getScholarInterSet()) {
            if (inter.isExpertInter()
                    && ((ExpertEditionInter) inter).getExpertEdition() == this) {
                interps.add((ExpertEditionInter) inter);
            }
        }

        Collections.sort(interps);

        return interps;

    }

    public ExpertEditionInter getNextHeteronymInter(ExpertEditionInter inter, Heteronym heteronym) {
        List<ExpertEditionInter> interps = new ArrayList<>(getExpertEditionIntersSet());

        Collections.sort(interps);

        return findNextElementByHeteronym(inter, heteronym, interps);
    }

    public ExpertEditionInter getPrevHeteronymInter(ExpertEditionInter inter, Heteronym heteronym) {
        List<ExpertEditionInter> interps = new ArrayList<>(getExpertEditionIntersSet());

        Collections.sort(interps, Collections.reverseOrder());

        return findNextElementByHeteronym(inter, heteronym, interps);
    }

    private ExpertEditionInter findNextElementByHeteronym(ExpertEditionInter inter, Heteronym heteronym,
                                                          List<ExpertEditionInter> interps) {
        Boolean stopNext = false;
        for (ExpertEditionInter tmpInter : interps) {
            if (stopNext) {
                return tmpInter;
            }
            if (tmpInter.getHeteronym() == heteronym && tmpInter == inter) {
                stopNext = true;
            }
        }
        return interps.get(0);
    }

    public Set<ExpertEditionInter> getIntersSet() {
        return new HashSet<>(getExpertEditionIntersSet());
    }

    public List<ExpertEditionInter> getSortedInterps() {
        return getIntersSet().stream().map(ExpertEditionInter.class::cast).sorted().collect(Collectors.toList());
    }

    public ExpertEditionInter getFragInterByUrlId(String urlId) {
        return getIntersSet().stream().filter(i -> i.getUrlId().equals(urlId)).findFirst().orElse(null);
    }

    public ExpertEditionInter getFragInterByXmlId(String xmlId) {
        return getIntersSet().stream().filter(i -> i.getXmlId().equals(xmlId)).findFirst().orElse(null);
    }

    @Override
    public String getReference() {
        return getEditor();
    }

    public ExpertEditionInter getFirstInterpretation() {
        List<ExpertEditionInter> interps = new ArrayList<>(getExpertEditionIntersSet());

        Collections.sort(interps);

        return interps.get(0);
    }

}


public abstract class ScholarEdition extends ScholarEdition_Base {

    public abstract String getReference();

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class SubstText extends SubstText_Base {

    public SubstText(TextPortion parent) {
        parent.addChildText(this);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst,
							ScholarInter fragInter) {
        if (getInterps().contains(fragInter) && highlightSubst) {
            return true;
        } else {
            return false;
        }
    }

}


public class AltTextWeight extends AltTextWeight_Base {

	public AltTextWeight() {
		super();
	}

	public AltTextWeight(SegText segText, double weight) {
		setSegText(segText);
		setWeight(weight);
	}

	public void remove() {
		setSegText(null);
		setAltText(null);

		deleteDomainObject();
	}

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.text.config.BeanUtil;
import pt.ist.socialsoftware.edition.text.api.TextEventPublisher;


import java.util.*;


public class Fragment extends Fragment_Base implements Comparable<Fragment> {
    private static final Logger logger = LoggerFactory.getLogger(Fragment.class);


    public enum PrecisionType {
        HIGH("high"), MEDIUM("medium"), LOW("low"), UNKNOWN("unknown");

        private final String desc;

        PrecisionType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    public Fragment(TextModule text, String title, String xmlId) {
        setTextModule(text);
        setTitle(title);
        setXmlId(xmlId);
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {

//        EventInterface.getInstance().publish(new Event(Event.EventType.FRAGMENT_REMOVE, this.getXmlId()));
        TextEventPublisher eventPublisher = BeanUtil.getBean(TextEventPublisher.class);
        eventPublisher.publishEvent(new Event(Event.EventType.FRAGMENT_REMOVE, this.getXmlId()));

        setTextModule(null);

        getTextPortion().remove();

        for (ScholarInter inter : getScholarInterSet()) {
            inter.remove();
        }

        for (Source source : getSourcesSet()) {
            source.remove();
        }

        for (RefText ref : getRefTextSet()) {
            // the reference is removed
            ref.remove();
        }

        // TODO: it does not belong to this model
        getCitationSet().stream().forEach(c -> c.remove());

        deleteDomainObject();
    }

	/*public List<ScholarInter> getSortedInterps() {
		List<ScholarInter> interps = new ArrayList<>(getScholarInterSet());

		Collections.sort(interps);

		return interps;
	}*/

    public List<SourceInter> getSortedSourceInter() {
        List<SourceInter> interps = new ArrayList<>();

        for (ScholarInter inter : getScholarInterSet()) {
            if (!inter.isExpertInter()) {
                interps.add((SourceInter) inter);
            }
        }

        Collections.sort(interps);

        return interps;
    }

    public Set<ExpertEditionInter> getExpertEditionInterSet() {
        Set<ExpertEditionInter> result = new HashSet<>();
        for (ScholarInter inter : getScholarInterSet()) {
            if (inter.isExpertInter()) {
                result.add((ExpertEditionInter) inter);
            }
        }
        return result;
    }

    public Set<ExpertEditionInter> getExpertEditionInters(ExpertEdition expertEdition) {
        // return getScholarInterSet().stream().filter(inter ->
        // inter.getEdition() == expertEdition)
        // .map(ExpertEditionInter.class::cast).collect(Collectors.toSet());

        Set<ExpertEditionInter> result = new HashSet<>();
        for (ScholarInter inter : getScholarInterSet()) {
            if (inter.getEdition() == expertEdition) {
                result.add((ExpertEditionInter) inter);
            }
        }
        return result;
    }

    public Surface getSurface(String xmlId) {
        for (Source source : getSourcesSet()) {
            if (source.getFacsimile() != null) {
                for (Surface surface : source.getFacsimile().getSurfaces()) {
                    if (xmlId.equals(surface.getXmlId())) {
                        return surface;
                    }
                }
            }
        }
        return null;
    }

    public ScholarInter getScholarInterByXmlId(String xmlId) {
        for (ScholarInter inter : getScholarInterSet()) {
            if (xmlId.equals(inter.getXmlId())) {
                return inter;
            }
        }
        return null;
    }

    public ScholarInter getScholarInterByUrlId(String urlId) {
        for (ScholarInter inter : getScholarInterSet()) {
            if (urlId.equals(inter.getUrlId())) {
                return inter;
            }
        }
        return null;
    }

    public SourceInter getRepresentativeSourceInter() {
        // get the last one, since it is ordered, it will be printed, or
        // dactiloscript, or manuscript
        List<SourceInter> sourceInters = getSortedSourceInter();
        return sourceInters.get(sourceInters.size() - 1);
    }

    @Override
    public int compareTo(Fragment fragment) {
        return this.getXmlId().compareTo(fragment.getXmlId());
    }

    public Citation getCitationById(long id) {
        return getCitationSet().stream().filter(citation -> citation.getId() == id).findFirst().orElse(null);
    }
}




public class Rend extends Rend_Base {

	public enum Rendition {
		RIGHT("right"), LEFT("left"), CENTER("center"), BOLD("bold"), ITALIC(
				"i"), RED("red"), GREEN("green"), UNDERLINED("u"), SUPERSCRIPT(
				"super"), SUBSCRIPT("sub");

		private String desc;

		Rendition(String desc) {
			this.desc = desc;
		}

		public String getDesc() {
			return desc;
		}
	};

	public Rend(Rendition rend) {
		setRend(rend);
	}

	public void remove() {
		setText(null);

		deleteDomainObject();
	}

}




public class PrintedSource extends PrintedSource_Base {

	public PrintedSource() {
		super();
		setType(Source.SourceType.PRINTED);
	}

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.Set;

public class PbText extends PbText_Base {

    public PbText(TextPortion parent, Set<ScholarInter> interps, int pbOrder) {
        parent.addChildText(this);
        setSurface(null);
        setOrder(pbOrder);

        for (ScholarInter inter : interps) {
            addScholarInter(inter);
        }
    }

    @Override
    public Set<ScholarInter> getInterps() {
        return getScholarInterSet();
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void remove() {
        setSurface(null);

        for (ScholarInter inter : getScholarInterSet()) {
            removeScholarInter(inter);
        }

        super.remove();
    }

    public PbText getPrevPbText(ScholarInter inter) {
        PbText prevPbText = null;
        for (PbText pbText : inter.getPbTextSet()) {
            if ((pbText.getOrder() < this.getOrder())
                    && ((prevPbText == null) || (pbText.getOrder() > prevPbText
                    .getOrder()))) {
                prevPbText = pbText;
            }
        }
        return prevPbText;
    }

    public PbText getNextPbText(ScholarInter inter) {
        PbText nextPbText = null;
        for (PbText pbText : inter.getPbTextSet()) {
            if ((pbText.getOrder() > this.getOrder())
                    && ((nextPbText == null) || (pbText.getOrder() < nextPbText
                    .getOrder()))) {
                nextPbText = pbText;
            }
        }
        return nextPbText;
    }
}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class RdgGrpText extends RdgGrpText_Base {

    public RdgGrpText(TextPortion parent, TextPortion.VariationType type) {
        parent.addChildText(this);
        setType(type);
    }

    @Override
    protected TextPortion getNextChildText(ScholarInter inter) {
        if (this.getInterps().contains(inter)) {
            for (TextPortion childText : getChildTextSet()) {
                if (childText.getInterps().contains(inter)) {
                    return childText;
                }
            }
        }
        return null;
    }

    @Override
    protected TextPortion getNextSibilingText(ScholarInter inter) {
        return null;
    }

    @Override
    protected TextPortion getNextParentText(ScholarInter inter) {
        TextPortion parentText = getParentText();
        if (parentText != null) {
            return parentText.getNextParentText(inter);
        } else {
            return null;
        }
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void putAppTextWithVariations(List<AppText> apps, List<ScholarInter> inters) {
        List<ScholarInter> newInters = new ArrayList<>(inters);
        newInters.retainAll(inters);
        super.putAppTextWithVariations(apps, newInters);
    }

    public Set<RdgText> getChildRdgTextSet() {
        Set<RdgText> rdgs = new HashSet<>();
        for (TextPortion text : getChildTextSet()) {
            if (text instanceof RdgText) {
                rdgs.add((RdgText) text);
            } else if (text instanceof RdgGrpText) {
                rdgs.addAll(((RdgGrpText) text).getChildRdgTextSet());
            }
        }
        return rdgs;
    }

}


public class PhysNote extends PhysNote_Base {

	public PhysNote() {
		super();
	}

	public void remove() {
		for (TextPortion text : getTextPortionSet()) {
			removeTextPortion(text);
		}

		deleteDomainObject();
	}

}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class UnclearText extends UnclearText_Base {

    public enum UnclearReason {
        IRRELEVANT("irrelevant"), ILLEGIABLE("illegible"), BACKGROUND_NOISE(
                "background noise"), ECCENTRIC_DUCTUS("eccentric ductus"), INK_BLOT(
                "ink blot"), FADED("faded"), NONSPECIFIED("nonspecified");

        private final String desc;

        UnclearReason(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public UnclearText(TextPortion parent, UnclearReason reason) {
        parent.addChildText(this);

        setReason(reason);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.text.domain.*;

import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class TextModule extends TextModule_Base {
    public static Logger logger = LoggerFactory.getLogger(TextModule.class);

    public static TextModule getInstance() {
        return FenixFramework.getDomainRoot().getTextModule();
    }

    public TextModule() {
        FenixFramework.getDomainRoot().setTextModule(this);
        setNullEdition(new NullEdition());
    }

    public void remove() {
        getNullEdition().remove();
        getExpertEditionsSet().forEach(e -> e.remove());
        getFragmentsSet().forEach(f -> f.remove());
        getHeteronymsSet().forEach(h -> h.remove());

        setRoot(null);

        deleteDomainObject();
    }

    public List<Heteronym> getSortedHeteronyms() {
        return getHeteronymsSet().stream().sorted(Comparator.comparing(Heteronym_Base::getName))
                .collect(Collectors.toList());
    }

    public List<ExpertEdition> getSortedExpertEdition() {
        return getExpertEditionsSet().stream().sorted().collect(Collectors.toList());
    }

    public ExpertEdition getExpertEdition(String acronym) {
        for (ExpertEdition edition : getExpertEditionsSet()) {
            if (edition.getAcronym().toUpperCase().equals(acronym.toUpperCase())) {
                return edition;
            }
        }
        return null;
    }

    public ExpertEdition getJPCEdition() {
        return getExpertEditionsSet().stream().filter(ve -> ve.getAcronym().equals(ExpertEdition.COELHO_EDITION_ACRONYM))
                .findFirst().orElse(null);
    }

    public ExpertEdition getTSCEdition() {
        return getExpertEditionsSet().stream().filter(ve -> ve.getAcronym().equals(ExpertEdition.CUNHA_EDITION_ACRONYM))
                .findFirst().orElse(null);
    }

    public ExpertEdition getRZEdition() {
        return getExpertEditionsSet().stream().filter(ve -> ve.getAcronym().equals(ExpertEdition.ZENITH_EDITION_ACRONYM))
                .findFirst().orElse(null);
    }

    public ExpertEdition getJPEdition() {
        return getExpertEditionsSet().stream().filter(ve -> ve.getAcronym().equals(ExpertEdition.PIZARRO_EDITION_ACRONYM))
                .findFirst().orElse(null);
    }

    public Fragment getFragmentByXmlId(String target) {
        for (Fragment fragment : getFragmentsSet()) {
            if (fragment.getXmlId().equals(target)) {
                return fragment;
            }
        }
        return null;
    }

    public Set<SourceInter> getFragmentRepresentatives() {
        return getFragmentsSet().stream().map(f -> f.getRepresentativeSourceInter()).collect(Collectors.toSet());
    }

    public ScholarInter getScholarInterByXmlId(String scholarInterId) {
        return getFragmentsSet().stream().filter(fragment -> fragment.getScholarInterByXmlId(scholarInterId) != null)
                .map(fragment -> fragment.getScholarInterByXmlId(scholarInterId)).findAny().orElse(null);
    }

}




public class HandNote extends HandNote_Base {

	public HandNote(ManuscriptSource.Medium medium, String note) {
		setMedium(medium);
		setNote(note);
	}

	@Override
	public void remove() {
		setManuscript(null);

		super.remove();
	}

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.List;
import java.util.Set;

public abstract class TextPortion extends TextPortion_Base implements GraphElement {
    private static final Logger logger = LoggerFactory.getLogger(TextPortion.class);

    public enum VariationType {
        ORTHOGRAPHIC("orthographic"), SUBSTANTIVE("substantive"), STYLE("style"), PARAGRAPH("paragraph"), PUNCTUATION(
                "punctuation"), UNSPECIFIED("unspecified");

        private final String desc;

        VariationType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public TextPortion() {
        super();
        setNextText(null);
        setFragment(null);
    }

    @Override
    public void addChildText(TextPortion child) {
        super.addChildText(child);

        if (getFirstChildText() == null) {
            child.setPrevText(null);
            child.setNextText(null);
            setFirstChildText(child);
            setLastChildText(child);
        } else {
            child.setPrevText(getLastChildText());
            child.setNextText(null);
            setLastChildText(child);
        }
    }

    // it is a template method that is redefined in AppText, RdgGrpText, and
    // RdgText
    public TextPortion getNextDepthFirstText(ScholarInter inter) {
        TextPortion nextDepthFirstText = null;

        // check children
        nextDepthFirstText = getNextChildText(inter);
        if (nextDepthFirstText != null) {
            return nextDepthFirstText;
        }

        // check next
        nextDepthFirstText = getNextSibilingText(inter);
        if (nextDepthFirstText != null) {
            return nextDepthFirstText;
        }

        // check next of parent
        return getNextParentText(inter);
    }

    // it is redefined in AppText and RdgGrpText
    protected TextPortion getNextChildText(ScholarInter inter) {
        if (this.getInterps().contains(inter)) {
            TextPortion childText = getFirstChildText();
            if (childText != null) {
                if (childText.getInterps().contains(inter)) {
                    return childText;
                } else {
                    return childText.getNextDepthFirstText(inter);
                }
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    // it is redefined in RdgGrpText and RdgText
    protected TextPortion getNextSibilingText(ScholarInter inter) {
        TextPortion nextText = getNextText();
        if (nextText != null) {
            if (nextText.getInterps().contains(inter)) {
                return nextText;
            } else {
                return nextText.getNextDepthFirstText(inter);
            }
        } else {
            return null;
        }
    }

    // it is redefined in RdgGrpText and RdgText
    protected TextPortion getNextParentText(ScholarInter inter) {
        TextPortion parentText = getParentText();
        if (parentText != null) {
            TextPortion nextText = getNextSibilingText(inter);
            if (nextText != null) {
                return nextText;
            }
            return parentText.getNextParentText(inter);
        } else {
            return null;
        }
    }

    // it is redefined in RdgGrpText and RdgText
    protected TextPortion getBacktrackingNextOfParentText(ScholarInter inter) {
        // check next
        TextPortion nextText = getNextSibilingText(inter);
        if (nextText != null) {
            return nextText;
        }

        return getNextParentText(inter);
    }

    protected boolean isTransitiveParent(TextPortion textPortion) {
        if (textPortion.getParentText() == null) {
            return false;
        }
        if (textPortion.getParentText() == this) {
            return true;
        }
        return isTransitiveParent(textPortion.getParentText());

    }

    @Override
    public abstract void accept(TextPortionVisitor visitor);

    public Set<ScholarInter> getInterps() {
        if (getParentText() == null) {
            return getFragment().getScholarInterSet();
        } else {
            return getParentText().getInterps();
        }
    }

    // check if the object is responsible for formating, AddText, DelText, and
    // SegText
    public Boolean isFormat(Boolean displayDel, Boolean highlightSubst, ScholarInter fragInter) {
        return false;
    }

    // write the separator if this object is the first responsible for formating
    // a SimpleText
    public String writeSeparator(Boolean displayDel, Boolean highlightSubst, ScholarInter fragInter) {
        if ((getParentOfFirstText() != null)
                && (getParentOfFirstText().isFormat(displayDel, highlightSubst, fragInter))) {
            return "";
        } else {
            return getSeparator(fragInter);
        }
    }

    public SimpleText getNextSimpleText(ScholarInter inter) {
        TextPortion nextText = getNextDepthFirstText(inter);
        if (nextText != null) {
            return nextText.getNextSimpleText(inter);
        }

        return null;
    }

    // returns the value of getBreakWord() of the closest predecessor lbText of
    // a simpleText and true if there is another simpleText between
    public Boolean getBreakWord() {
        if (getPrevText() != null) {
            return getPrevText().getBreakWord();
        }

        if (getParentText() != null) {
            return getParentText().getBreakWord();
        }

        return true;
    }

    // goes through the tree of text to find the next instance of SimpleText and
    // requests the separator
    public String getSeparator(ScholarInter inter) {
        SimpleText simpleText = getNextSimpleText(inter);

        if (simpleText != null) {
            return simpleText.getSeparator(inter);
        } else {
            return "";
        }
    }

    public RdgText getClosestRdg() {
        return getParentText().getClosestRdg();
    }

    public void remove() {
        for (TextPortion text : getChildTextSet()) {
            text.remove();
        }

        for (PhysNote physNote : getPhysNoteSet()) {
            removePhysNote(physNote);
        }

        for (Rend rend : getRendSet()) {
            rend.remove();
        }

        setFragment(null);
        setPrevText(null);
        setNextText(null);
        setParentOfFirstText(null);
        setParentOfLastText(null);
        setParentText(null);

        deleteDomainObject();
    }

    public String getNote() {
        return null;
    }

    public void putAppTextWithVariations(List<AppText> apps, List<ScholarInter> inters) {
        for (TextPortion text : getChildTextSet()) {
            text.putAppTextWithVariations(apps, inters);
        }
    }

    public boolean hasVariations(List<ScholarInter> inters) {
        return false;
    }

    public TextPortion getTopParent() {
        if (getParentText() != null) {
            return getParentText().getTopParent();
        } else {
            return this;
        }
    }

    public SimpleText getSimpleText(ScholarInter inter, int currentOffset, int offset) {
        logger.debug("getSimpleText currentOffset:{}, offset:{}", currentOffset, offset);

        if (getNextSimpleText(inter) != null) {
            return getNextSimpleText(inter).getSimpleText(inter, currentOffset, offset);
        } else {
            return null;
        }
    }
}


import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

public class GapText extends GapText_Base {

    public enum GapReason {
        IRRELEVANT("irrelevant"), ILLEGIABLE("illegible"), NONSPECIFIED(
                "nonspecified");

        private final String desc;

        GapReason(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public enum GapUnit {
        WORD("word"), CHAR("char"), NONSPECIFIED("nonspecified");

        private final String desc;

        GapUnit(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public GapText(TextPortion parent, GapReason reason, int extent,
				   GapUnit unit) {
        parent.addChildText(this);

        setReason(reason);
        setExtent(extent);
        setUnit(unit);
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public String getSeparator(ScholarInter inter) {
        if (getInterps().contains(inter)) {
            String separator = null;

            if (!super.getBreakWord()) {
                separator = "";
            } else {
                separator = " ";
            }
            return separator;
        } else {
            return super.getSeparator(inter);
        }
    }

    public String getGapValue() {
        String gapValue = "<span style=\"color: rgb(0,0,255);\">[ileg.]</span>";
        // String gapValue = "<";
        // String symbol = getUnit() == GapUnit.WORD ? "######" : "#";
        //
        // for (int i = 0; i < getExtent(); i++) {
        // if (getUnit() == GapUnit.WORD) {
        // gapValue = gapValue + symbol;
        // if (i + 1 != getExtent()) {
        // gapValue = gapValue + " ";
        // }
        // } else {
        // gapValue = gapValue + symbol;
        // }
        // }
        // gapValue = gapValue + ">";

        return gapValue;
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Heteronym extends Heteronym_Base implements Comparable<Heteronym> {
    public static Logger logger = LoggerFactory.getLogger(Heteronym.class);

    public Heteronym() {
        super();
    }

    public Heteronym(TextModule text, String name) {
        setTextModule(text);
        setName(name);
    }

    public void remove() {
        setTextModule(null);

        getSourceSet().stream().forEach(s -> removeSource(s));
        getScholarInterSet().stream().forEach(i -> removeScholarInter(i));

        deleteDomainObject();
    }

    @Override
    public int compareTo(Heteronym o) {
        return this.getXmlId().compareTo(o.getXmlId());
    }

    public boolean isNullHeteronym() {
        return false;
    }

}



import pt.ist.socialsoftware.edition.text.feature.generators.TextPortionVisitor;

import java.util.List;

public class AltText extends AltText_Base {

    public enum AltMode {
        EXCL("excl"), INCL("incl"), NONSPECIFIED("nonspecified");

        private final String desc;

        AltMode(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

	public AltText(TextPortion parent, SegText segTextOne, SegText segTextTwo,
				   AltMode mode, double weightOne, double weightTwo) {
        parent.addChildText(this);
    }

    public AltText(TextPortion parent, List<SegText> segTextList, AltMode mode,
				   String[] weightList) {
        parent.addChildText(this);
        setMode(mode);

        int i = 0;
        for (SegText segText : segTextList) {
            double weight = Double.parseDouble(weightList[i]);
            addAltTextWeight(new AltTextWeight(segText, weight));
            i++;
        }
    }

    @Override
    public void accept(TextPortionVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void remove() {
        for (AltTextWeight weight : getAltTextWeightSet()) {
            weight.remove();
        }
        super.remove();
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.text.domain.Source.SourceType;

public class SourceInter extends SourceInter_Base implements Comparable<SourceInter> {
    private static final Logger logger = LoggerFactory.getLogger(SourceInter.class);

    public SourceInter() {
    }

    @Override
    public Heteronym getHeteronym() {
        return getSource().getHeteronym();
    }

    @Override
    public String getShortName() {
        return getSource().getName();
    }

    @Override
    public String getTitle() {
        return getFragment().getTitle();
    }

    @Override
    public LdoDDate getLdoDDate() {
        if (getSource() == null) {
            return null;
        }
        return getSource().getLdoDDate();
    }

    @Override
    public boolean isExpertInter() {
        return false;
    }

    @Override
    public int compareTo(SourceInter other) {
        SourceType thisType = getSource().getType();
        SourceType otherType = other.getSource().getType();

        if (thisType.equals(SourceType.MANUSCRIPT) && otherType.equals(SourceType.MANUSCRIPT)) {
            boolean thisIsManuscript = !((ManuscriptSource) this.getSource()).getHandNoteSet().isEmpty();
            boolean thisIsDactiloscript = !((ManuscriptSource) this.getSource()).getTypeNoteSet().isEmpty();
            boolean otherIsManuscript = !((ManuscriptSource) other.getSource()).getHandNoteSet().isEmpty();
            boolean otherIsDactiloscript = !((ManuscriptSource) other.getSource()).getTypeNoteSet().isEmpty();

            if (thisIsDactiloscript && otherIsDactiloscript) {
                return getShortName().compareTo(other.getShortName());
            }

            if (thisIsManuscript && otherIsManuscript) {
                return getShortName().compareTo(other.getShortName());
            }

            if (thisIsManuscript) {
                return -1;
            } else {
                // dactiloscript
                return 1;
            }
        }

        if (thisType.equals(SourceType.PRINTED) && otherType.equals(SourceType.PRINTED)) {
            return getShortName().compareTo(other.getShortName());
        }

        if (thisType.equals(SourceType.MANUSCRIPT)) {
            return -1;
        } else {
            // printed
            return 1;
        }
    }

    @Override
    public void remove() {
        setSource(null);

        super.remove();
    }

    @Override
    public int getNumber() {
        return 0;
    }


    @Override
    public ScholarInter getLastUsed() {
        return this;
    }

    @Override
    public ScholarEdition getEdition() {
        return TextModule.getInstance().getNullEdition();
    }

    @Override
    public String getReference() {
        return getShortName();
    }

    public Surface getPrevSurface(PbText pbText) {
        if (pbText == null) {
            return null;
        } else {
            PbText prevPbText = pbText.getPrevPbText(this);
            if (prevPbText == null) {
                return getSource().getFacsimile().getFirstSurface();
            } else {
                return prevPbText.getSurface();
            }
        }
    }

    public Surface getNextSurface(PbText pbText) {
        if (pbText == null) {
            if (getFirstPbText() == null) {
                return null;
            } else {
                return getFirstPbText().getSurface();
            }
        } else {
            PbText nextPbText = pbText.getNextPbText(this);
            if (nextPbText == null) {
                return null;
            } else {
                return nextPbText.getSurface();
            }
        }
    }

    private PbText getFirstPbText() {
        PbText firstPbText = null;
        for (PbText pbText : getPbTextSet()) {
            if ((firstPbText == null) || (firstPbText.getOrder() > pbText.getOrder())) {
                firstPbText = pbText;
            }
        }
        return firstPbText;
    }

    public PbText getPrevPbText(PbText pbText) {
        if (pbText == null) {
            return null;
        } else {
            return pbText.getPrevPbText(this);
        }
    }

    public PbText getNextPbText(PbText pbText) {
        if (pbText == null) {
            return getFirstPbText();
        } else {
            return pbText.getNextPbText(this);
        }
    }

}



import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.text.domain.*;

public class HtmlWriter4Variations extends PlainHtmlWriter4OneInter {

    public String getAppTranscription(AppText appText) {
        this.transcription = "";


        if (!appText.getType().equals(TextPortion.VariationType.UNSPECIFIED)) {
            this.transcription = this.transcription + "(" + generateType(appText.getType()) + ") ";
        }

        appText.getFirstChildText().accept(this);

        return this.transcription;
    }

    public String getAppTranscription(String externalId) {

        AppText appText = FenixFramework.getDomainObject(externalId);

        if (appText == null) { return ""; }

        this.transcription = "";


        if (!appText.getType().equals(TextPortion.VariationType.UNSPECIFIED)) {
            this.transcription = this.transcription + "(" + generateType(appText.getType()) + ") ";
        }

        appText.getFirstChildText().accept(this);

        return this.transcription;
    }

    public HtmlWriter4Variations(ScholarInter fragInter) {
        super(fragInter);
        this.highlightDiff = false;
        this.displayDel = true;
        this.highlightIns = true;
        this.highlightSubst = false;
        this.showNotes = true;
    }

    public HtmlWriter4Variations(String scholarInterXmlId) {
        this(TextModule.getInstance().getScholarInterByXmlId(scholarInterXmlId));
    }

    @Override
    public void visit(AppText appText) {
        if (!appText.getType().equals(TextPortion.VariationType.UNSPECIFIED)) {
            this.transcription = this.transcription + " (" + generateType(appText.getType()) + ") ";
        }

        super.visit(appText);
    }

    @Override
    public void visit(RdgGrpText rdgGrpText) {
        if (!rdgGrpText.getType().equals(TextPortion.VariationType.UNSPECIFIED)) {
            this.transcription = this.transcription + " (" + generateType(rdgGrpText.getType()) + ") ";
        }

        super.visit(rdgGrpText);

    }

    private String generateType(TextPortion.VariationType type) {
        switch (type) {
            case SUBSTANTIVE:
                return "<strong>" + type.getDesc() + "</strong>";
            default:
                return type.getDesc();
        }
    }

}


import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.domain.SpaceText.SpaceDim;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;
import pt.ist.socialsoftware.edition.text.domain.TextModule;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PlainHtmlWriter4OneInter implements TextPortionVisitor {
    protected ScholarInter fragInter = null;
    protected String transcription = "";

    private void append2Transcription(String generated) {
        if (this.generate) {
            this.transcription = this.transcription + generated;
        }
    }

    protected Boolean highlightDiff = false;
    protected Boolean displayDel = false;
    protected Boolean highlightIns = true;
    protected Boolean highlightSubst = false;
    protected Boolean showNotes = true;

    private boolean generate = true;
    private PbText startPbText = null;
    private PbText stopPbText = null;

    private final Map<ScholarInter, Integer> interpsChar = new HashMap<>();
    private int totalChar = 0;

    public String getTranscription() {
        return this.transcription;
    }

    public Integer getInterPercentage(ScholarInter inter) {
        return (this.interpsChar.get(inter) * 100) / this.totalChar;
    }

    public PlainHtmlWriter4OneInter(ScholarInter fragInter) {
        this.fragInter = fragInter;
        this.transcription = "";

        for (ScholarInter inter : fragInter.getFragment().getScholarInterSet()) {
            this.interpsChar.put(inter, 0);
        }
    }

    public PlainHtmlWriter4OneInter(String scholarInterXmlId) {
        this(TextModule.getInstance().getScholarInterByXmlId(scholarInterXmlId));
    }

    public void write(Boolean highlightDiff) {
        this.highlightDiff = highlightDiff;
        visit((AppText) this.fragInter.getFragment().getTextPortion());
    }

    public void write(Boolean highlightDiff, Boolean displayDel, Boolean highlightIns, Boolean highlightSubst,
                      Boolean showNotes, Boolean showFacs, PbText pbText) {
        this.highlightDiff = highlightDiff;
        this.displayDel = displayDel;
        this.highlightIns = highlightIns;
        this.highlightSubst = highlightSubst;
        this.showNotes = showNotes;

        if (showFacs) {

            this.startPbText = pbText;
            if (this.startPbText != null) {
                this.generate = false;
            }

            this.stopPbText = ((SourceInter) this.fragInter).getNextPbText(this.startPbText);

        }

        visit((AppText) this.fragInter.getFragment().getTextPortion());
    }

    @Override
    public void visit(AppText appText) {
        propagate2FirstChild(appText);

        propagate2NextSibling(appText);
    }

    @Override
    public void visit(RdgGrpText rdgGrpText) {
        if (rdgGrpText.getInterps().contains(this.fragInter)) {
            propagate2FirstChild(rdgGrpText);
        }

        propagate2NextSibling(rdgGrpText);
    }

    @Override
    public void visit(RdgText rdgText) {
        if (rdgText.getInterps().contains(this.fragInter)) {

            Boolean color = false;
            if (this.highlightDiff) {
                int size = this.fragInter.getFragment().getScholarInterSet().size();
                if (rdgText.getInterps().size() < size) {
                    color = true;
                    int colorValue = 255 - (255 / size) * (size - rdgText.getInterps().size() - 1);
                    String colorCode = "<span style=\"background-color: rgb(0," + colorValue + ",255);\">";

                    append2Transcription(rdgText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter) + colorCode);
                }
            }

            if (!color) {
                append2Transcription(rdgText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter));
            }

            propagate2FirstChild(rdgText);

            if (color) {
                append2Transcription("</span>");
            }
        }

        propagate2NextSibling(rdgText);
    }

    @Override
    public void visit(ParagraphText paragraphText) {
        // append2Transcription("<p align=\"justify\">");
        append2Transcription("<p class=\"text-xs-left text-sm-justify text-md-justify text-lg-justify\">");

        propagate2FirstChild(paragraphText);

        append2Transcription("</p>");

        propagate2NextSibling(paragraphText);
    }

    @Override
    public void visit(SegText segText) {
        List<Rend> renditions = new ArrayList<>(segText.getRendSet());
        String preRend = generatePreRendition(renditions);
        String postRend = generatePostRendition(renditions);

        String altRend = "";
        if (segText.getAltTextWeight() != null) {
            altRend = "<span class=\"text-warning\">" + "<abbr title=\""
                    + segText.getAltTextWeight().getAltText().getMode().getDesc() + " "
                    + segText.getAltTextWeight().getWeight() + "\">";
        }

        append2Transcription(segText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter) + preRend + altRend);

        propagate2FirstChild(segText);

        if (segText.getAltTextWeight() != null) {
            altRend = "</abbr></span>";
        }

        append2Transcription(altRend + postRend);

        propagate2NextSibling(segText);
    }

    @Override
    public void visit(AltText altText) {
        // do nothing, the segTextOne and segTextTwo will do
        propagate2NextSibling(altText);
    }

    @Override
    public void visit(SimpleText simpleText) {
        String value = simpleText.getValue();

        this.totalChar = this.totalChar + value.length();
        for (ScholarInter inter : simpleText.getInterps()) {
            Integer number = this.interpsChar.get(inter);
            number = number + value.length();
            this.interpsChar.put(inter, number);
        }

        append2Transcription(simpleText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter) + value);

        propagate2NextSibling(simpleText);
    }

    @Override
    public void visit(LbText lbText) {
        if (lbText.getInterps().contains(this.fragInter)) {
            String hyphen = "";
            if (lbText.getHyphenated()) {
                hyphen = "-";
            }

            append2Transcription(hyphen + "<br>");
        }

        propagate2NextSibling(lbText);
    }

    @Override
    public void visit(PbText pbText) {
        if (pbText.getInterps().contains(this.fragInter)) {
            if ((this.startPbText != pbText) && (this.stopPbText != pbText)) {
                append2Transcription("<hr size=\"8\" color=\"black\">");
            }
        }

        if (this.startPbText == pbText) {
            this.generate = true;
        }

        if (this.stopPbText == pbText) {
            this.generate = false;
        }

        propagate2NextSibling(pbText);
    }

    @Override
    public void visit(SpaceText spaceText) {
        String separator = "";
        if (spaceText.getDim() == SpaceDim.VERTICAL) {
            separator = "<br>";
            // the initial line break is for a new line
            append2Transcription(separator);
        } else if (spaceText.getDim() == SpaceDim.HORIZONTAL) {
            separator = "&nbsp; ";
        }

        for (int i = 0; i < spaceText.getQuantity(); i++) {
            append2Transcription(separator);
        }

        propagate2NextSibling(spaceText);
    }

    @Override
    public void visit(AddText addText) {
        List<Rend> renditions = new ArrayList<>(addText.getRendSet());
        String preRendition = generatePreRendition(renditions);
        String postRendition = generatePostRendition(renditions);

        String prePlaceFormat = "";
        String postPlaceFormat = "";
        switch (addText.getPlace()) {
            case INLINE:
            case INSPACE:
            case OVERLEAF:
            case SUPERIMPOSED:
            case MARGIN:
            case OPPOSITE:
            case BOTTOM:
            case END:
            case UNSPECIFIED:
                prePlaceFormat = "<small>";
                postPlaceFormat = "</small>";
                break;
            case ABOVE:
            case TOP:
                prePlaceFormat = "<span style=\"position:relative; top:-3px;\">";
                postPlaceFormat = "</span>";
                // prePlaceFormat = "<sup>";
                // postPlaceFormat = "</sup>";
                break;
            case BELOW:
                prePlaceFormat = "<span style=\"position:relative; top:3px;\">";
                postPlaceFormat = "</span>";
                // prePlaceFormat = "<sub>";
                // postPlaceFormat = "</sub>";
                break;
        }

        if (this.highlightIns) {
            String insertSymbol = "<span style=\"color: rgb(128,128,128);\"><small>&and;</small></span>";
            if (this.showNotes) {
                insertSymbol = "<abbr title=\"" + addText.getNote() + "\">" + insertSymbol + "</abbr>";
            }

            append2Transcription(addText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter) + preRendition
                    + prePlaceFormat + insertSymbol);
        } else {
            append2Transcription(addText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter));
        }

        propagate2FirstChild(addText);

        if (this.highlightIns) {
            append2Transcription(postPlaceFormat + postRendition);
        }

        propagate2NextSibling(addText);
    }

    @Override
    public void visit(DelText delText) {
        if (this.displayDel) {
            append2Transcription(delText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter)
                    + "<del><span style=\"color: rgb(128,128,128);\">");
            if (this.showNotes) {
                append2Transcription("<abbr title=\"" + delText.getNote() + "\">");
            }

            propagate2FirstChild(delText);

            if (this.showNotes) {
                append2Transcription("</abbr>");
            }

            append2Transcription("</span></del>");
        }

        propagate2NextSibling(delText);
    }

    @Override
    public void visit(SubstText substText) {
        if (this.displayDel && this.highlightSubst) {
            append2Transcription(substText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter)
                    + "<span style=\"color: rgb(0,0,255);\">[</span>");
        }

        propagate2FirstChild(substText);

        if (this.displayDel && this.highlightSubst) {
            append2Transcription("<span style=\"color: rgb(0,0,255);\">]" + "<sub>subst</sub></span>");
        }

        propagate2NextSibling(substText);
    }

    @Override
    public void visit(GapText gapText) {
        String gapValue = gapText.getGapValue();

        this.totalChar = this.totalChar + gapValue.length();
        for (ScholarInter inter : gapText.getInterps()) {
            Integer number = this.interpsChar.get(inter);
            number = number + gapValue.length();
            this.interpsChar.put(inter, number);
        }

        append2Transcription(gapText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter) + "<abbr title=\""
                + gapText.getReason().getDesc() + ", " + gapText.getExtent() + " " + gapText.getUnit() + "\">"
                + gapValue + "</abbr>");

        propagate2NextSibling(gapText);
    }

    @Override
    public void visit(UnclearText unclearText) {
        append2Transcription(unclearText.writeSeparator(this.displayDel, this.highlightSubst, this.fragInter)
                + "<span style=\"text-shadow: black 0.0em 0.0em 0.1em; -webkit-filter: blur(0.005em);\">"
                + "<abbr title=\"" + unclearText.getReason().getDesc() + "\">");

        propagate2FirstChild(unclearText);

        append2Transcription("</abbr>" + "</span>");

        propagate2NextSibling(unclearText);
    }

    @Override
    public void visit(NoteText noteText) {
        append2Transcription("<abbr title=\"");

        propagate2FirstChild(noteText);

        int number = 0;
        for (AnnexNote annexNote : noteText.getAnnexNoteSet()) {
            if (annexNote.getScholarInter() == this.fragInter) {
                number = annexNote.getNumber();
            }
        }

        append2Transcription("\">(" + number + ")</abbr>");

        propagate2NextSibling(noteText);

    }

    @Override
    public void visit(RefText refText) {
        propagate2FirstChild(refText);
        propagate2NextSibling(refText);
    }

    private String generatePreRendition(List<Rend> renditions) {
        String preRend = "";
        for (Rend rend : renditions) {
            // the order matters
            if (rend.getRend() == Rend.Rendition.RIGHT) {
                preRend = "<div class=\"text-right\">" + preRend;
            } else if (rend.getRend() == Rend.Rendition.LEFT) {
                preRend = "<div class=\"text-left\">" + preRend;
            } else if (rend.getRend() == Rend.Rendition.CENTER) {
                preRend = "<div class=\"text-center\">" + preRend;
            } else if (rend.getRend() == Rend.Rendition.BOLD) {
                preRend = preRend + "<strong>";
            } else if (rend.getRend() == Rend.Rendition.ITALIC) {
                preRend = preRend + "<em>";
            } else if (rend.getRend() == Rend.Rendition.RED) {
                preRend = preRend + "<span style=\"color: rgb(255,0,0);\">";
            } else if (rend.getRend() == Rend.Rendition.GREEN) {
                preRend = preRend + "<span style=\"color: rgb(0,255,0);\">";
            } else if (rend.getRend() == Rend.Rendition.UNDERLINED) {
                preRend = preRend + "<u>";
            } else if (rend.getRend() == Rend.Rendition.SUPERSCRIPT) {
                preRend = preRend + "<sup>";
            } else if (rend.getRend() == Rend.Rendition.SUBSCRIPT) {
                preRend = preRend + "<sub>";
            }
        }
        return preRend;
    }

    private String generatePostRendition(List<Rend> renditions) {
        String postRend = "";
        for (Rend rend : renditions) {
            if (rend.getRend() == Rend.Rendition.RIGHT) {
                postRend = postRend + "</div>";
            } else if (rend.getRend() == Rend.Rendition.LEFT) {
                postRend = postRend + "</div>";
            } else if (rend.getRend() == Rend.Rendition.CENTER) {
                postRend = postRend + "</div>";
            } else if (rend.getRend() == Rend.Rendition.BOLD) {
                postRend = "</strong>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.ITALIC) {
                postRend = "</em>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.RED) {
                postRend = "</span>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.GREEN) {
                postRend = "</span>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.UNDERLINED) {
                postRend = "</u>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.SUPERSCRIPT) {
                postRend = "</sup>" + postRend;
            } else if (rend.getRend() == Rend.Rendition.SUBSCRIPT) {
                postRend = "</sub>" + postRend;
            }
        }
        return postRend;
    }

}

import pt.ist.socialsoftware.edition.text.domain.*;

public interface TextPortionVisitor {
    default void propagate2FirstChild(TextPortion text) {
        TextPortion firstChild = text.getFirstChildText();
        if (firstChild != null) {
            firstChild.accept(this);
        }
    }

    default void propagate2NextSibling(TextPortion text) {
        if (text.getNextText() != null) {
            text.getNextText().accept(this);
        }
    }

    public void visit(AppText appText);

    public void visit(RdgGrpText rdgGrpText);

    public void visit(RdgText rdgText);

    public void visit(ParagraphText paragraphText);

    public void visit(SimpleText text);

    public void visit(SegText segText);

    public void visit(LbText lbText);

    public void visit(PbText pbText);

    public void visit(SpaceText spaceText);

    public void visit(AddText addText);

    public void visit(DelText delText);

    public void visit(SubstText substText);

    public void visit(GapText gapText);

    public void visit(UnclearText unclearText);

    public void visit(AltText altText);

    public void visit(NoteText noteText);

    public void visit(RefText refText);
}


import org.jdom2.Attribute;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.socialsoftware.edition.text.domain.*;

import java.util.Set;

public class JDomTEITextPortionWriter implements TextPortionVisitor {
    private final static Logger logger = LoggerFactory.getLogger(JDomTEITextPortionWriter.class);

    // create the jdom
    // Document jdomDoc = new Document();
    // create root element

    private final Namespace xmlns;

    // List<String> fragInterSelectedSet = new ArrayList<String>();

    private Element rootElement = null;
    private Set<ScholarInter> fragInterSelectedList = null;

    // jdomDoc.setRootElement(rootElement);

    public JDomTEITextPortionWriter(Element rootElement) {
        this.rootElement = rootElement;
        this.xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");
    }

    public JDomTEITextPortionWriter(Element rootElement, Set<ScholarInter> expertEditionInterSelectedList) {
        // TODO Auto-generated constructor stub
        this.rootElement = rootElement;
        this.fragInterSelectedList = expertEditionInterSelectedList;
        this.xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");
    }

    private Element generateElement(Element rootElement, String name) {
        Element newElement = new Element(name, this.xmlns);
        rootElement.addContent(newElement);
        return newElement;
    }

    @Override
    public void visit(AppText appText) {
        this.rootElement = generateElement(this.rootElement, "app");

        propagate2FirstChild(appText);

        if (!appText.getType().getDesc().equalsIgnoreCase("UNSPECIFIED")) {
            Attribute typeAtt = new Attribute("type", appText.getType().getDesc());
            this.rootElement.setAttribute(typeAtt);
        }

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(appText);
    }

    @Override
    public void visit(RdgGrpText rdgGrpText) {
        this.rootElement = generateElement(this.rootElement, "rdgGrp");

        if (rdgGrpText.getType() != null) {
            if (rdgGrpText.getType().getDesc().compareTo("unspecified") != 0) {
                Attribute typeAtt = new Attribute("type", rdgGrpText.getType().getDesc());
                this.rootElement.setAttribute(typeAtt);
            }
        }

        propagate2FirstChild(rdgGrpText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(rdgGrpText);
    }

    @Override
    public void visit(RdgText rdgText) {

        String wit = "";
        boolean selected = false;

        for (ScholarInter inter : rdgText.getInterps()) {
            if (this.fragInterSelectedList.contains(inter)) {
                selected = true;
                wit = wit + "#" + inter.getXmlId() + " ";
            }
        }

        if (selected) {
            this.rootElement = generateElement(this.rootElement, "rdg");

            if (!wit.equals("")) {
                Attribute witAtt = new Attribute("wit", wit.trim());
                this.rootElement.setAttribute(witAtt);
            }

            propagate2FirstChild(rdgText);

            this.rootElement = this.rootElement.getParentElement();
        }

        propagate2NextSibling(rdgText);
    }

    @Override
    public void visit(ParagraphText paragraphText) {
        this.rootElement = generateElement(this.rootElement, "p");

        propagate2FirstChild(paragraphText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(paragraphText);
    }

    @Override
    public void visit(SegText segText) {
        String rendition = "";
        for (Rend rend : segText.getRendSet()) {
            rendition = rendition + "#" + rend.getRend().getDesc() + " ";
        }

        this.rootElement = generateElement(this.rootElement, "seg");

        if (!rendition.equals("")) {
            Attribute witAtt = new Attribute("rendition", rendition.trim());
            this.rootElement.setAttribute(witAtt);
        }

        if (segText.getXmlId() != null) {
            Attribute ids = new Attribute("id", segText.getXmlId(), Namespace.XML_NAMESPACE);
            this.rootElement.setAttribute(ids);
        }

        propagate2FirstChild(segText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(segText);
    }

    @Override
    public void visit(SimpleText simpleText) {
        this.rootElement.addContent(simpleText.getValue());

        propagate2NextSibling(simpleText);
    }

    @Override
    public void visit(LbText lbText) {

        String ed = "";
        boolean selected = false;

        for (ScholarInter inter : lbText.getInterps()) {
            if (this.fragInterSelectedList.contains(inter)) {
                ed = ed + "#" + inter.getXmlId() + " ";
                selected = true;
            }
        }

        if (selected) {
            this.rootElement = generateElement(this.rootElement, "lb");

            Attribute edAtt = new Attribute("ed", ed.trim());
            this.rootElement.setAttribute(edAtt);

            if (lbText.getHyphenated()) {
                Attribute hyphAtt = new Attribute("type", "hyphenated");
                this.rootElement.setAttribute(hyphAtt);
            }

            if (!lbText.getBreakWord()) {
                Attribute breakAtt = new Attribute("break", "no");
                this.rootElement.setAttribute(breakAtt);
            }

            this.rootElement = this.rootElement.getParentElement();
        }

        propagate2NextSibling(lbText);
    }

    @Override
    public void visit(PbText pbText) {

        String ed = "";
        String facs = "";
        boolean selected = false;

        for (ScholarInter inter : pbText.getInterps()) {
            if (this.fragInterSelectedList.contains(inter)) {
                ed = ed + "#" + inter.getXmlId() + " ";
                selected = true;
            }
        }

        if (selected) {
            this.rootElement = generateElement(this.rootElement, "pb");

            Attribute edAtt = new Attribute("ed", ed.trim());
            this.rootElement.setAttribute(edAtt);

            if (pbText.getSurface() != null) {
                facs = pbText.getSurface().getGraphic();
                Attribute facsAtt = new Attribute("facs", facs);
                this.rootElement.setAttribute(facsAtt);
            }

            this.rootElement = this.rootElement.getParentElement();

        }

        propagate2NextSibling(pbText);
    }

    @Override
    public void visit(SpaceText spaceText) {
        this.rootElement = generateElement(this.rootElement, "space");

        Attribute dimAtt = new Attribute("dim", spaceText.getDim().getDesc());
        this.rootElement.setAttribute(dimAtt);

        Attribute quantityAtt = new Attribute("quantity", Integer.toString(spaceText.getQuantity()));
        this.rootElement.setAttribute(quantityAtt);

        Attribute unitAtt = new Attribute("unit", spaceText.getUnit().getDesc());
        this.rootElement.setAttribute(unitAtt);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(spaceText);
    }

    @Override
    public void visit(AddText addText) {
        this.rootElement = generateElement(this.rootElement, "add");

        if (addText.getPlace() != AddText.Place.UNSPECIFIED) {
            Attribute placeAtt = new Attribute("place", addText.getPlace().getDesc());
            this.rootElement.setAttribute(placeAtt);
        }

        propagate2FirstChild(addText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(addText);
    }

    @Override
    public void visit(DelText delText) {
        this.rootElement = generateElement(this.rootElement, "del");

        if (delText.getHow() != DelText.HowDel.UNSPECIFIED) {
            Attribute delAtt = new Attribute("rend", delText.getHow().getDesc());
            this.rootElement.setAttribute(delAtt);
        }

        propagate2FirstChild(delText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(delText);
    }

    @Override
    public void visit(SubstText substText) {
        this.rootElement = generateElement(this.rootElement, "subst");

        propagate2FirstChild(substText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(substText);
    }

    @Override
    public void visit(GapText gapText) {
        this.rootElement = generateElement(this.rootElement, "gap");

        Attribute reasonAtt = new Attribute("reason", gapText.getReason().getDesc());
        Attribute extentAtt = new Attribute("extent", String.valueOf(gapText.getExtent()));
        Attribute unitAtt = new Attribute("unit", gapText.getUnit().getDesc());

        this.rootElement.setAttribute(reasonAtt);
        this.rootElement.setAttribute(extentAtt);
        this.rootElement.setAttribute(unitAtt);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(gapText);
    }

    @Override
    public void visit(UnclearText unclearText) {
        this.rootElement = generateElement(this.rootElement, "unclear");

        Attribute reasonAtt = new Attribute("reason", unclearText.getReason().getDesc());
        this.rootElement.setAttribute(reasonAtt);

        propagate2FirstChild(unclearText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(unclearText);
    }

    @Override
    public void visit(AltText altText) {
        String valueTarget = "";
        String valueWeight = "";

        for (AltTextWeight weight : altText.getAltTextWeightSet()) {
            valueTarget = valueTarget + "#" + weight.getSegText().getXmlId() + " ";
            valueWeight = valueWeight + " " + weight.getWeight();
        }

        valueTarget = valueTarget.trim();
        valueWeight = valueWeight.trim();

        this.rootElement = generateElement(this.rootElement, "alt");

        Attribute targetAtt = new Attribute("target", valueTarget);
        Attribute modeAtt = new Attribute("mode", altText.getMode().getDesc());
        Attribute weightsAtt = new Attribute("weights", valueWeight);

        this.rootElement.setAttribute(targetAtt);
        this.rootElement.setAttribute(modeAtt);
        this.rootElement.setAttribute(weightsAtt);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(altText);
    }

    @Override
    public void visit(NoteText noteText) {
        this.rootElement = generateElement(this.rootElement, "note");

        Attribute typeAtt = new Attribute("type", noteText.getType().getDesc());
        this.rootElement.setAttribute(typeAtt);

        propagate2FirstChild(noteText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(noteText);
    }

    @Override
    public void visit(RefText refText) {
        this.rootElement = generateElement(this.rootElement, "ref");

        Attribute typeAtt = new Attribute("type", refText.getType().getDesc());
        Attribute targetAtt = new Attribute("target", "#" + refText.getTarget());

        this.rootElement.setAttribute(typeAtt);
        this.rootElement.setAttribute(targetAtt);

        propagate2FirstChild(refText);

        this.rootElement = this.rootElement.getParentElement();

        propagate2NextSibling(refText);
    }

}


import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.api.dto.ScholarInterDto;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;

import java.util.*;
import java.util.stream.Collectors;

public class HtmlWriter2CompInters implements TextPortionVisitor {
    private final Map<ScholarInter, String> transcriptionsMap = new HashMap<>();
    private final Map<ScholarInter, Integer> transcriptionsLengthMap = new HashMap<>();
    private final List<ScholarInter> interps;

    private Boolean lineByLine = false;
    private Boolean showSpaces = false;

    public Boolean getShowSpaces() {
        return this.showSpaces;
    }

    private String lineByLineTranscription = "";

    public HtmlWriter2CompInters(List<ScholarInterDto> interps) {
        this.interps = interps.stream()
                .map(scholarInterDto -> (ScholarInter) FenixFramework.getDomainObject(scholarInterDto.getExternalId()))
                .collect(Collectors.toList());
    }

    public HtmlWriter2CompInters(List<String> externalIds, boolean optional) {
        this.interps = externalIds.stream()
                .map(externalId -> (ScholarInter) FenixFramework.getDomainObject(externalId))
                .collect(Collectors.toList());
    }

    public void write(Boolean lineByLine, Boolean showSpaces) {
        this.lineByLine = lineByLine;
        this.showSpaces = showSpaces;

        for (ScholarInter inter : this.interps) {
            this.transcriptionsMap.put(inter, "");
            this.transcriptionsLengthMap.put(inter, 0);
        }

        visit((AppText) this.interps.iterator().next().getFragment().getTextPortion());
    }

    public String getTranscription(ScholarInterDto interDto) {
        return getTranscription((ScholarInter) FenixFramework.getDomainObject(interDto.getExternalId()));
    }

    public String getTranscription(String externalId) {
        return getTranscription((ScholarInter) FenixFramework.getDomainObject(externalId));
    }

    public String getTranscription(ScholarInter inter) {
        return this.transcriptionsMap.get(inter);
    }

    public String getTranscriptionLineByLine() {
        // add the last line
        for (ScholarInter inter : this.interps) {
            this.lineByLineTranscription = this.lineByLineTranscription + this.transcriptionsMap.get(inter) + "<br>";
            this.transcriptionsMap.put(inter, "");
            this.transcriptionsLengthMap.put(inter, 0);
        }

        return this.lineByLineTranscription;
    }

    @Override
    public void visit(AppText appText) {
        alignSpaces(appText);

        generateLineByLine(appText);

        propagate2FirstChild(appText);

        alignSpaces(appText);

        propagate2NextSibling(appText);
    }

    private void generateLineByLine(AppText appText) {
        if (this.lineByLine && (appText.getInterps().containsAll(this.interps))) {
            int lineLength = 66;

            int longestLength = 0;
            for (ScholarInter inter : this.interps) {
                longestLength = Math.max(longestLength, this.transcriptionsLengthMap.get(inter));
            }

            if (longestLength >= lineLength) {
                for (ScholarInter inter : this.interps) {
                    this.lineByLineTranscription = this.lineByLineTranscription + this.transcriptionsMap.get(inter) + "<br>";
                    this.transcriptionsMap.put(inter, "");
                    this.transcriptionsLengthMap.put(inter, 0);
                }
            }
        }
    }

    private void alignSpaces(AppText appText) {
        if (this.showSpaces) {
            Set<ScholarInter> appInterps = new HashSet<>(this.interps);
            appInterps.retainAll(appText.getInterps());

            int longestLength = 0;
            for (ScholarInter inter : appInterps) {
                longestLength = Math.max(longestLength, this.transcriptionsLengthMap.get(inter));
            }

            for (ScholarInter inter : appInterps) {
                String addSpace = "";
                int diff = longestLength - this.transcriptionsLengthMap.get(inter);
                for (int i = 0; i < diff; i++) {
                    addSpace = addSpace + "&nbsp;";
                }
                String newTranscription = this.transcriptionsMap.get(inter) + addSpace;

                this.transcriptionsMap.put(inter, newTranscription);
                this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + diff);
            }
        }
    }

    @Override
    public void visit(RdgGrpText rdgGrpText) {
        propagate2FirstChild(rdgGrpText);

        propagate2NextSibling(rdgGrpText);
    }

    @Override
    public void visit(RdgText rdgText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(rdgText.getInterps());

        if (!intersection.isEmpty()) {

            Boolean color = false;

            int size = this.interps.size();
            String colorCode = "";
            if (intersection.size() < size) {
                color = true;
                int colorValue = 255 - (255 / size) * (size - intersection.size() - 1);
                colorCode = "<span style=\"background-color: rgb(0," + colorValue + ",255);\">";
            }

            for (ScholarInter inter : intersection) {
                String separator = rdgText.writeSeparator(true, false, inter);

                String newTranscription = this.transcriptionsMap.get(inter) + separator;

                if (color) {
                    newTranscription = newTranscription + colorCode;
                }

                this.transcriptionsMap.put(inter, newTranscription);
                this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + separator.length());
            }

            propagate2FirstChild(rdgText);

            if (color) {
                for (ScholarInter inter : intersection) {
                    String newTranscription = this.transcriptionsMap.get(inter) + "</span>";
                    this.transcriptionsMap.put(inter, newTranscription);
                }
            }

        }

        propagate2NextSibling(rdgText);
    }

    @Override
    public void visit(ParagraphText paragraphText) {
        propagate2FirstChild(paragraphText);

        propagate2NextSibling(paragraphText);
    }

    @Override
    public void visit(SegText segText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(segText.getInterps());

        for (ScholarInter inter : intersection) {
            String separator = segText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator;
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + separator.length());
        }

        propagate2FirstChild(segText);

        propagate2NextSibling(segText);
    }

    @Override
    public void visit(SimpleText simpleText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(simpleText.getInterps());

        String value = simpleText.getValue();

        for (ScholarInter inter : intersection) {
            String separator = simpleText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator + value;
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter,
                    this.transcriptionsLengthMap.get(inter) + value.length() + separator.length());
        }

        propagate2NextSibling(simpleText);
    }

    @Override
    public void visit(LbText lbText) {
        propagate2NextSibling(lbText);
    }

    @Override
    public void visit(PbText pbText) {
        propagate2NextSibling(pbText);
    }

    @Override
    public void visit(SpaceText spaceText) {
        propagate2NextSibling(spaceText);
    }

    @Override
    public void visit(AddText addText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(addText.getInterps());

        for (ScholarInter inter : intersection) {
            String separator = addText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator + "<ins>";
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + separator.length());
        }

        propagate2FirstChild(addText);

        for (ScholarInter inter : intersection) {
            String newTranscription = this.transcriptionsMap.get(inter) + "</ins>";
            this.transcriptionsMap.put(inter, newTranscription);
        }

        propagate2NextSibling(addText);
    }

    @Override
    public void visit(DelText delText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(delText.getInterps());

        for (ScholarInter inter : intersection) {
            String separator = delText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator + "<del>";
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + separator.length());
        }

        propagate2FirstChild(delText);

        for (ScholarInter inter : intersection) {
            String newTranscription = this.transcriptionsMap.get(inter) + "</del>";
            this.transcriptionsMap.put(inter, newTranscription);
        }

        propagate2NextSibling(delText);
    }

    @Override
    public void visit(SubstText substText) {
        propagate2FirstChild(substText);

        propagate2NextSibling(substText);
    }

    @Override
    public void visit(GapText gapText) {
        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(gapText.getInterps());

        String value = gapText.getGapValue();

        for (ScholarInter inter : intersection) {
            String separator = gapText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator + value;
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter,
                    this.transcriptionsLengthMap.get(inter) + value.length() + separator.length());
        }

        propagate2NextSibling(gapText);
    }

    @Override
    public void visit(UnclearText unclearText) {

        Set<ScholarInter> intersection = new HashSet<>(this.interps);
        intersection.retainAll(unclearText.getInterps());

        for (ScholarInter inter : intersection) {
            String separator = unclearText.writeSeparator(true, false, inter);
            String newTranscription = this.transcriptionsMap.get(inter) + separator
                    + "<span style=\"text-shadow: black 0.0em 0.0em 0.1em; -webkit-filter: blur(0.005em);\">";
            this.transcriptionsMap.put(inter, newTranscription);
            this.transcriptionsLengthMap.put(inter, this.transcriptionsLengthMap.get(inter) + separator.length());
        }

        propagate2FirstChild(unclearText);

        for (ScholarInter inter : intersection) {
            String newTranscription = this.transcriptionsMap.get(inter) + "</span>";
            this.transcriptionsMap.put(inter, newTranscription);
        }

        propagate2NextSibling(unclearText);
    }

    @Override
    public void visit(AltText altText) {
        propagate2NextSibling(altText);
    }

    @Override
    public void visit(NoteText noteText) {
        propagate2NextSibling(noteText);
    }

    @Override
    public void visit(RefText refText) {
        propagate2FirstChild(refText);
        propagate2NextSibling(refText);
    }

}


import pt.ist.socialsoftware.edition.text.api.dto.ScholarInterDto;
import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;

public class PlainTextFragmentWriter implements TextPortionVisitor {

    protected ScholarInter fragInter = null;
    protected String transcription = "";

    private void append2Transcription(String generated) {
		this.transcription = this.transcription + generated;
    }

    public String getTranscription() {
        return this.transcription;
    }

    public PlainTextFragmentWriter(ScholarInter fragInter) {
        this.fragInter = fragInter;
		this.transcription = "";
    }

    public PlainTextFragmentWriter(ScholarInterDto fragInter) {
        this.fragInter = TextModule.getInstance().getScholarInterByXmlId(fragInter.getXmlId());
        this.transcription = "";
    }

    public void write() {
        visit((AppText) this.fragInter.getFragment().getTextPortion());
    }

    @Override
    public void visit(AppText appText) {
        propagate2FirstChild(appText);

        propagate2NextSibling(appText);
    }

    @Override
    public void visit(RdgGrpText rdgGrpText) {
        if (rdgGrpText.getInterps().contains(this.fragInter)) {
            propagate2FirstChild(rdgGrpText);
        }

        propagate2NextSibling(rdgGrpText);
    }

    @Override
    public void visit(RdgText rdgText) {
        if (rdgText.getInterps().contains(this.fragInter)) {
            append2Transcription(rdgText.writeSeparator(true, false, this.fragInter));

            propagate2FirstChild(rdgText);
        }

        propagate2NextSibling(rdgText);
    }

    @Override
    public void visit(ParagraphText paragraphText) {
        propagate2FirstChild(paragraphText);
        propagate2NextSibling(paragraphText);
    }

    @Override
    public void visit(SegText segText) {
        propagate2FirstChild(segText);
        propagate2NextSibling(segText);
    }

    @Override
    public void visit(AltText altText) {
        propagate2NextSibling(altText);
    }

    @Override
    public void visit(SimpleText simpleText) {
        String value = simpleText.getValue();
        append2Transcription(simpleText.writeSeparator(true, false, this.fragInter) + value);

        propagate2NextSibling(simpleText);
    }

    @Override
    public void visit(LbText lbText) {
        propagate2NextSibling(lbText);
    }

    @Override
    public void visit(PbText pbText) {
        propagate2NextSibling(pbText);
    }

    @Override
    public void visit(SpaceText spaceText) {
        propagate2NextSibling(spaceText);
    }

    @Override
    public void visit(AddText addText) {
        append2Transcription(addText.writeSeparator(true, false, this.fragInter));

        propagate2FirstChild(addText);

        propagate2NextSibling(addText);
    }

    @Override
    public void visit(DelText delText) {
        propagate2FirstChild(delText);
        propagate2NextSibling(delText);
    }

    @Override
    public void visit(SubstText substText) {
        propagate2FirstChild(substText);
        propagate2NextSibling(substText);
    }

    @Override
    public void visit(GapText gapText) {
        propagate2NextSibling(gapText);
    }

    @Override
    public void visit(UnclearText unclearText) {
        propagate2FirstChild(unclearText);
        propagate2NextSibling(unclearText);
    }

    @Override
    public void visit(NoteText noteText) {
        propagate2FirstChild(noteText);
        propagate2NextSibling(noteText);
    }

    @Override
    public void visit(RefText refText) {
        propagate2FirstChild(refText);
        propagate2NextSibling(refText);
    }

}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathFactory;
import org.joda.time.LocalDate;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.DateUtils;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.text.domain.ExpertEdition;
import pt.ist.socialsoftware.edition.text.domain.Heteronym;
import pt.ist.socialsoftware.edition.text.domain.TextModule;


import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class LoadTEICorpus {

    private Element ldoDTEI = null;
    private Namespace namespace = null;
   // private VirtualModule virtualModule = null;
    private TextModule text = null;

    private Document doc = null;

    private final Map<String, List<Object>> xmlIDMap = new HashMap<>();

    private void putObjectByXmlID(String xmlID, Object object) {

        List<Object> list = this.xmlIDMap.get(xmlID);
        if (list == null) {
            list = new ArrayList<>();
        }
        list.add(object);

        this.xmlIDMap.put(xmlID, list);
    }

    private List<Object> getObjectsByXmlID(String xmlID) {
        List<Object> objects = this.xmlIDMap.get(xmlID);
        return objects;
    }

    XPathFactory xpfac = XPathFactory.instance();

    private void parseTEIFile(InputStream file) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);
        try {
            // TODO: create a config variable for the xml file
            this.doc = builder.build(file);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (this.doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        this.ldoDTEI = this.doc.getRootElement();
        this.namespace = this.ldoDTEI.getNamespace();
    }

    @Atomic(mode = TxMode.WRITE)
    public void loadTEICorpus(InputStream file) {
        parseTEIFile(file);

       // this.virtualModule = VirtualModule.getInstance();
        this.text = TextModule.getInstance();

       // loadTitleStmt();

        loadListBibl();

        loadHeteronyms();

    }

    private void loadHeteronyms() {
        Element corpusHeteronyms = this.ldoDTEI.getChild("teiHeader", this.namespace)
                .getChild("profileDesc", this.namespace).getChild("particDesc", this.namespace)
                .getChild("listPerson", this.namespace);

        for (Element heteronymTEI : corpusHeteronyms.getChildren("person", this.namespace)) {
            String heteronymXmlID = heteronymTEI.getAttributeValue("id", heteronymTEI.getNamespace("xml"));

            if (getObjectsByXmlID(heteronymXmlID) != null) {
                throw new LdoDLoadException("xml:id:" + heteronymXmlID + " já foi declarado");
            }

            assert getObjectsByXmlID(heteronymXmlID) == null : "xml:id:" + heteronymXmlID + " IS ALREADY DECLARED";

            String name = heteronymTEI.getChildText("persName", this.namespace);

            List<Heteronym> heteronymList = this.text.getHeteronymsSet().stream().filter(heteronym -> heteronym.getName().equals(name))
                    .collect(Collectors.toList());

            if (heteronymList.isEmpty()) {
                Heteronym heteronym = new Heteronym(this.text, name);

                putObjectByXmlID(heteronymXmlID, heteronym);

                heteronym.setXmlId(heteronymXmlID);
            }

        }
    }

    private void loadListBibl() {
        Element corpusHeaderListBibl = this.ldoDTEI.getChild("teiHeader", this.namespace)
                .getChild("fileDesc", this.namespace).getChild("sourceDesc", this.namespace)
                .getChild("listBibl", this.namespace);

        String listEditionsXmlID = corpusHeaderListBibl.getAttributeValue("id",
                corpusHeaderListBibl.getNamespace("xml"));

        if (getObjectsByXmlID(listEditionsXmlID) != null) {
            throw new LdoDLoadException("xml:id:" + listEditionsXmlID + " já foi declarado");
        }

        assert getObjectsByXmlID(listEditionsXmlID) == null : "xml:id:" + listEditionsXmlID + " IS ALREADY DECLARED";

        for (Element bibl : corpusHeaderListBibl.getChildren("bibl", this.namespace)) {
            String editionXmlID = bibl.getAttributeValue("id", bibl.getNamespace("xml"));

            if (getObjectsByXmlID(editionXmlID) != null) {
                throw new LdoDLoadException("xml:id:" + editionXmlID + " já foi declarado");
            }

            assert getObjectsByXmlID(editionXmlID) == null : "xml:id:" + editionXmlID + " IS ALREADY DECLARED";

            String author = bibl.getChild("author", this.namespace).getChild("persName", this.namespace).getText();
            String title = bibl.getChild("title", this.namespace).getText();
            String editor = bibl.getChild("editor", this.namespace).getChild("persName", this.namespace).getText();
            LocalDate date = DateUtils.convertDate(bibl.getChild("date", this.namespace).getAttributeValue("when"));

            ExpertEdition edition = new ExpertEdition(this.text, title, author, editor, date);

            edition.setXmlId(editionXmlID);

            putObjectByXmlID(editionXmlID, edition);
            putObjectByXmlID(listEditionsXmlID, edition);

        }
    }

//    private void loadTitleStmt() {
//        Element corpusHeaderTitleStmt = this.ldoDTEI.getChild("teiHeader", this.namespace)
//                .getChild("fileDesc", this.namespace).getChild("titleStmt", this.namespace);
//
////        this.virtualModule.setTitle(corpusHeaderTitleStmt.getChild("title", this.namespace).getText());
////        this.virtualModule.setAuthor(corpusHeaderTitleStmt.getChild("author", this.namespace).getText());
////        this.virtualModule.setEditor(corpusHeaderTitleStmt.getChild("editor", this.namespace).getText());
////        this.virtualModule.setSponsor(corpusHeaderTitleStmt.getChild("sponsor", this.namespace).getText());
////        this.virtualModule.setFunder(corpusHeaderTitleStmt.getChild("funder", this.namespace).getText());
////        this.virtualModule.setPrincipal(corpusHeaderTitleStmt.getChild("principal", this.namespace).getText());
//    }

}

import org.apache.commons.io.IOUtils;
import org.jdom2.Attribute;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.domain.Fragment;
import pt.ist.socialsoftware.edition.text.domain.NullHeteronym;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;
import pt.ist.socialsoftware.edition.text.feature.generators.JDomTEITextPortionWriter;

import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.Set;

public class ExpertEditionTEIExport {

    Document jdomDoc = null;

    // Element rootElement = null;

    JDomTEITextPortionWriter writer = null;
    Set<ScholarInter> scholarInterSelectedSet;

    Namespace xmlns;

    // List<String> scholarInterSelectedSet = new ArrayList<String>();

    public ExpertEditionTEIExport() {
        this.xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");
    }

    public void generate(Map<Fragment, Set<ScholarInter>> fragmentMap) {
        // TODO Auto-generated method stub

        Element rootElement = generateCorpus();
        generateCorpusHeader(rootElement);

        Fragment fragment;

        for (Map.Entry<Fragment, Set<ScholarInter>> entry : fragmentMap.entrySet()) {

            fragment = entry.getKey();
            this.scholarInterSelectedSet = entry.getValue();

            generateFragment(rootElement, fragment, this.scholarInterSelectedSet);
        }
    }

    private Element generateCorpus() {
        this.jdomDoc = new Document();
        Element rootElement = new Element("teiCorpus");

        rootElement.setNamespace(this.xmlns);

        rootElement.addNamespaceDeclaration(Namespace.getNamespace("svg", "http://www.w3.org/2000/svg"));

        rootElement.addNamespaceDeclaration(Namespace.getNamespace("xi", "http://www.w3.org/2001/XInclude"));

        this.jdomDoc.setRootElement(rootElement);
        return rootElement;
    }

    private void generateCorpusHeader(Element rootElement) {
        Element newElement = new Element("teiHeader", this.xmlns);
        Attribute type = new Attribute("type", "corpus");
        newElement.setAttribute(type);
        rootElement.addContent(newElement);
    }

    private void generateFragment(Element rootElement, Fragment fragment, Set<ScholarInter> expertEditionInterSelectedSet) {

        // Namespace xmlns = Namespace.XML_NAMESPACE;
        // .getNamespace("http://www.tei-c.org/ns/1.0");

        // Namespace xmlns =
        // Namespace.getNamespace("http://www.tei-c.org/ns/1.0");

        Element fragElement = new Element("TEI", this.xmlns);

        // fragElement.addNamespaceDeclaration(Namespace
        // .getNamespace("http://www.tei-c.org/ns/1.0"));
        // //
        // fragElement.setNamespace(Namespace
        // .getNamespace("http://www.tei-c.org/ns/1.0"));

        // fragElement.addNamespaceDeclaration(Namespace.getNamespace("",
        // fragment.getXmlId()));

        // Attribute type = new Attribute("xmlns",
        // "http://www.tei-c.org/ns/1.0");
        // fragElement.setAttribute(type);

        Attribute id = new Attribute("id", fragment.getXmlId(), Namespace.XML_NAMESPACE);
        fragElement.setAttribute(id);

        generateTextHeader(fragment, fragElement);
        generateFacsimiles(fragment, fragElement);
        generateTranscription(fragElement, fragment, expertEditionInterSelectedSet);

        rootElement.addContent(fragElement);
    }

    private void generateTextHeader(Fragment fragment, Element rootElement) {

        Element headerElement = new Element("teiHeader", this.xmlns);
        Attribute type = new Attribute("type", "text");
        headerElement.setAttribute(type);
        rootElement.addContent(headerElement);

        Element fileDescElement = new Element("fileDesc", this.xmlns);
        headerElement.addContent(fileDescElement);

        // titleStmt codification

        Element titleStmtElement = new Element("titleStmt", this.xmlns);
        fileDescElement.addContent(titleStmtElement);

        Element titleElement = new Element("title", this.xmlns);
        titleStmtElement.addContent(titleElement);
        titleElement.addContent(fragment.getTitle());

        Element authorElement = new Element("author", this.xmlns);
        titleStmtElement.addContent(authorElement);
       // authorElement.addContent(VirtualModule.getInstance().getAuthor());

        Element respStmtElement = new Element("respStmt", this.xmlns);
        titleStmtElement.addContent(respStmtElement);

        Element respElement = new Element("resp", this.xmlns);
        respStmtElement.addContent(respElement);
        respElement.addContent("encoding");

        // TODO: coder's name
        Element nameElement = new Element("name", this.xmlns);
        respStmtElement.addContent(nameElement);

        // publicationStmt codification

        Element publicationStmtElement = new Element("publicationStmt", this.xmlns);
        fileDescElement.addContent(publicationStmtElement);

        Element publisherElement = new Element("publisher", this.xmlns);
        publicationStmtElement.addContent(publisherElement);
        publisherElement.addContent("University of Coimbra");

        Element pubPlaceElement = new Element("pubPlace", this.xmlns);
        publicationStmtElement.addContent(pubPlaceElement);
        pubPlaceElement.addContent("Coimbra");

        Element availabilityElement = new Element("availability", this.xmlns);
        publicationStmtElement.addContent(availabilityElement);
        availabilityElement.setAttribute("status", "restricted");

        Element licenceElement = new Element("licence", this.xmlns);
        availabilityElement.addContent(licenceElement);
        licenceElement.setAttribute("target", "http://creativecommons.org/licenses/by-sa/3.0/");
        // TODO: <p>xpto</p> ?

        Element dateElement = new Element("date", this.xmlns);
        publicationStmtElement.addContent(dateElement);
        dateElement.setAttribute("when", "2014");

        Element sourceDescElement = new Element("sourceDesc", this.xmlns);
        fileDescElement.addContent(sourceDescElement);

        generateSources(fragment, sourceDescElement);
        generateWitnesses(fragment, sourceDescElement);
    }

    private void generateSources(Fragment fragment, Element rootElement) {

        Element listBibl = new Element("listBibl", this.xmlns);
        // listBibl.addNamespaceDeclaration(Namespace.getNamespace("id",
        // fragment.getXmlId() + ".SRC"));

        Attribute id = new Attribute("id", fragment.getXmlId() + ".SRC", Namespace.XML_NAMESPACE);
        listBibl.setAttribute(id);

        Element listBibl2 = new Element("listBibl", this.xmlns);
        // listBibl2.addNamespaceDeclaration(Namespace.getNamespace("id",
        // fragment.getXmlId() + ".SRC.MS"));

        Attribute id2 = new Attribute("id", fragment.getXmlId() + ".SRC.MS", Namespace.XML_NAMESPACE);
        listBibl2.setAttribute(id2);

        rootElement.addContent(listBibl);
        listBibl.addContent(listBibl2);

        // generate HeaderSources

        ManuscriptSource manuscript = null;

        Element msDescElement = null;
        Element msIdentifierElement = null;

        Element settlementElement = null;
        Element repositoryElement = null;
        Element idnoElement = null;
        Element altIdentifierElement = null;
        Element idnoAltElement = null;

        Element physDescElement = null;
        Element objectDescElement = null;
        Element supportDescElement = null;
        Element layoutDescElement = null;
        Element layoutElement = null;

        Element handDescElement = null;
        Element pElement = null;
        Element additionsElement = null;
        Element bindingDescElement = null;
        Element bindingElement = null;

        Element historyElement = null;
        Element originElement = null;
        Element origdateElement = null;

        for (Source source : fragment.getSourcesSet()) {

            // TODO: outros tipos de fontes
            manuscript = (ManuscriptSource) source;

            msDescElement = new Element("msDesc", this.xmlns);

            Attribute idms = new Attribute("id", manuscript.getXmlId(), Namespace.XML_NAMESPACE);
            msDescElement.setAttribute(idms);

            msIdentifierElement = new Element("msIdentifier", this.xmlns);
            physDescElement = new Element("physDesc", this.xmlns);

            msDescElement.addContent(msIdentifierElement);
            msDescElement.addContent(physDescElement);

            settlementElement = new Element("settlement", this.xmlns);
            settlementElement.addContent(manuscript.getSettlement());
            msIdentifierElement.addContent(settlementElement);

            repositoryElement = new Element("repository", this.xmlns);
            repositoryElement.addContent(manuscript.getRepository());
            msIdentifierElement.addContent(repositoryElement);

            idnoElement = new Element("idno", this.xmlns);
            idnoElement.addContent(manuscript.getIdno());
            msIdentifierElement.addContent(idnoElement);

            altIdentifierElement = new Element("altIdentifier", this.xmlns);
            altIdentifierElement.setAttribute("type", "SC");
            msIdentifierElement.addContent(altIdentifierElement);

            idnoAltElement = new Element("idno", this.xmlns);
            idnoAltElement.addContent(source.getName());
            altIdentifierElement.addContent(idnoAltElement);

            // physDesc // TODO: strings
            objectDescElement = new Element("objectDesc", this.xmlns);
            objectDescElement.setAttribute("form", manuscript.getForm().toString().toLowerCase());
            physDescElement.addContent(objectDescElement);

            supportDescElement = new Element("supportDesc", this.xmlns);
            supportDescElement.setAttribute("material", manuscript.getMaterial().name().toLowerCase());
            objectDescElement.addContent(supportDescElement);

            layoutDescElement = new Element("layoutDesc", this.xmlns);
            objectDescElement.addContent(layoutDescElement);

            layoutElement = new Element("layout", this.xmlns);
            layoutElement.setAttribute("columns", Integer.toString(manuscript.getColumns()));
            layoutDescElement.addContent(layoutElement);

            handDescElement = new Element("handDesc", this.xmlns);
            physDescElement.addContent(handDescElement);

            pElement = new Element("p", this.xmlns);
            pElement.addContent(manuscript.getNotes());
            handDescElement.addContent(pElement);

            additionsElement = new Element("additions", this.xmlns);

            if (manuscript.getHasLdoDLabel()) {
                additionsElement.addContent("VirtualModule");
            }
            physDescElement.addContent(additionsElement);

            bindingDescElement = new Element("bindingDesc", this.xmlns);
            physDescElement.addContent(bindingDescElement);

            bindingElement = new Element("binding", this.xmlns);
            bindingDescElement.addContent(bindingElement);

            // TODO: to update
            pElement = new Element("p", this.xmlns);
            // pElement.addContent(manuscript.getNotes());
            bindingElement.addContent(pElement);

            if (manuscript.getLdoDDate() != null) {
                historyElement = new Element("history", this.xmlns);
                msDescElement.addContent(historyElement);

                originElement = new Element("origin", this.xmlns);
                historyElement.addContent(originElement);

                String date = manuscript.getLdoDDate().print();

                origdateElement = new Element("origDate", this.xmlns);
                origdateElement.setAttribute("when", date);

                if (manuscript.getLdoDDate() != null) {
                    origdateElement.setAttribute("precision", manuscript.getLdoDDate().getPrecision().getDesc());
                }

                origdateElement.addContent(date);
                originElement.addContent(origdateElement);
            }

            listBibl2.addContent(msDescElement);

        }

    }

    private void generateWitnesses(Fragment fragment, Element rootElement) {

        // generate Sources Interp
        Element listWitElement = null;
        Element listWitAuthElement = null;
        Element listWitEdElement = null;
        Element witnessElement = null;
        Element refElement = null;

        // listWitEd
        Element headListWitElement = null;
        Element listWitEdCritElement = null;

        Element biblElement = null;
        Element respStmtElement = null;
        Element respElement = null;
        Element persNameElement = null;

        Element titleElement = null;
        Element biblScopeElement = null;

        Element noteElement = null;
        Element dateElement = null;

        listWitElement = new Element("listWit", this.xmlns);

        Attribute idlw = new Attribute("id", fragment.getXmlId() + ".WIT", Namespace.XML_NAMESPACE);
        listWitElement.setAttribute(idlw);

        // listWitElement.addNamespaceDeclaration(Namespace.getNamespace("id",
        // fragment.getXmlId() + ".WIT"));

        listWitAuthElement = new Element("listWit", this.xmlns);

        // listWitAuthElement.addNamespaceDeclaration(Namespace.getNamespace("id",
        // fragment.getXmlId() + ".WIT.MS"));

        Attribute idlwa = new Attribute("id", fragment.getXmlId() + ".WIT.MS", Namespace.XML_NAMESPACE);
        listWitAuthElement.setAttribute(idlwa);

        // manuscripts
        boolean selected = false;
        for (SourceInter sourceInter : fragment.getSortedSourceInter()) {

            // TODO selecionar as edicoes autorais ?
            if (this.scholarInterSelectedSet.contains(sourceInter)) {

                witnessElement = new Element("witness", this.xmlns);
                // witnessElement.addNamespaceDeclaration(Namespace.getNamespace(
                // "id", sourceInter.getXmlId()));

                Attribute idw = new Attribute("id", sourceInter.getXmlId(), Namespace.XML_NAMESPACE);
                witnessElement.setAttribute(idw);

                refElement = new Element("ref", this.xmlns);
                refElement.setAttribute("target", "#" + sourceInter.getSource().getXmlId());
                witnessElement.addContent(refElement);

                listWitAuthElement.addContent(witnessElement);
                selected = true;
            }
        }

        if (selected) {
            listWitElement.addContent(listWitAuthElement);
        }

        // editorial witness

        listWitEdElement = new Element("listWit", this.xmlns);
        // listWitEdElement.addNamespaceDeclaration(Namespace.getNamespace("id",
        // fragment.getXmlId() + ".WIT.ED"));

        Attribute idlwe = new Attribute("id", fragment.getXmlId() + ".WIT.ED", Namespace.XML_NAMESPACE);
        listWitEdElement.setAttribute(idlwe);

        headListWitElement = new Element("head", this.xmlns);
        listWitEdElement.addContent(headListWitElement);

        listWitEdCritElement = new Element("listWit", this.xmlns);

        // listWitEdCritElement.addNamespaceDeclaration(Namespace.getNamespace(
        // "id", fragment.getXmlId() + ".WIT.ED.CRIT"));

        Attribute idlwec = new Attribute("id", fragment.getXmlId() + ".WIT.ED.CRIT", Namespace.XML_NAMESPACE);
        listWitEdCritElement.setAttribute(idlwec);

        listWitEdElement.addContent(listWitEdCritElement);

        ExpertEditionInter expertEditionInter = null;

        for (ScholarInter scholarInter : fragment.getScholarInterSet()) {

            // TODO: confirm: type EDITORIAL && selected
            if (scholarInter.isExpertInter()
                    && this.scholarInterSelectedSet.contains(scholarInter)) {

                expertEditionInter = (ExpertEditionInter) scholarInter;

                witnessElement = new Element("witness", this.xmlns);

                Attribute idwe = new Attribute("id", expertEditionInter.getXmlId(), Namespace.XML_NAMESPACE);
                witnessElement.setAttribute(idwe);

                refElement = new Element("ref", this.xmlns);
                refElement.setAttribute("target", "#" + expertEditionInter.getEdition().getXmlId());

                witnessElement.addContent(refElement);

                biblElement = new Element("bibl", this.xmlns);
                witnessElement.addContent(biblElement);

                // heteronimo nao declarado (!=null)
                if (scholarInter.getHeteronym().getName().compareTo(NullHeteronym.getNullHeteronym().getName()) != 0) {

                    respStmtElement = new Element("respStmt", this.xmlns);
                    biblElement.addContent(respStmtElement);

                    respElement = new Element("resp", this.xmlns);
                    respElement.addContent("heterónimo");
                    respStmtElement.addContent(respElement);

                    String name = scholarInter.getHeteronym().getName();
                    String corresp = "";

                    persNameElement = new Element("persName", this.xmlns);
                    persNameElement.addContent(name);

                    if (name.compareTo("Bernardo Soares") == 0) {
                        corresp = "BS";
                    } else {
                        corresp = "VG";
                    }

                    persNameElement.setAttribute("corresp", "#HT." + corresp);
                    respStmtElement.addContent(persNameElement);
                }

                titleElement = new Element("title", this.xmlns);
                titleElement.setAttribute("level", "a");
                titleElement.addContent(scholarInter.getTitle());
                biblElement.addContent(titleElement);

                biblScopeElement = new Element("biblScope", this.xmlns);
                biblScopeElement.setAttribute("unit", "number");
                biblScopeElement.addContent(expertEditionInter.getNumber() + "");
                biblElement.addContent(biblScopeElement);

                if (expertEditionInter.getVolume() != null) {
                    biblScopeElement = new Element("biblScope", this.xmlns);
                    biblScopeElement.setAttribute("unit", "vol");
                    biblScopeElement.addContent(expertEditionInter.getVolume() + "");
                    biblElement.addContent(biblScopeElement);
                }

                biblScopeElement = new Element("biblScope", this.xmlns);
                biblScopeElement.setAttribute("from", expertEditionInter.getStartPage() + "");
                biblScopeElement.setAttribute("to", expertEditionInter.getEndPage() + "");

                // TODO confirm
                biblScopeElement.setAttribute("unit", "pp");
                biblElement.addContent(biblScopeElement);

                if (expertEditionInter.getNotes().compareTo("") != 0) {
                    noteElement = new Element("note", this.xmlns);
                    noteElement.setAttribute("type", "physDesc");
                    noteElement.addContent(expertEditionInter.getNotes());
                    biblElement.addContent(noteElement);
                }

                if (expertEditionInter.getLdoDDate() != null) {

                    dateElement = new Element("date", this.xmlns);
                    dateElement.addContent(expertEditionInter.getLdoDDate().print());

                    dateElement.setAttribute("when", expertEditionInter.getLdoDDate().print());

                    biblElement.addContent(dateElement);
                }

                listWitEdCritElement.addContent(witnessElement);

            }

        }

        listWitElement.addContent(listWitEdElement);
        rootElement.addContent(listWitElement);
    }

    private void generateFacsimiles(Fragment fragment, Element fragElement) {
        // TODO Auto-generated method stub
        for (Source source : fragment.getSourcesSet()) {
            generateFacsimile(source.getFacsimile(), fragElement);
        }

    }

    private void generateFacsimile(Facsimile facsimile, Element fragElement) {

        Element facElement = new Element("facsimile", this.xmlns);

        Attribute idf = new Attribute("id", facsimile.getXmlId(), Namespace.XML_NAMESPACE);
        facElement.setAttribute(idf);

        Attribute corresp = new Attribute("corresp", "#" + facsimile.getSource().getXmlId());
        facElement.setAttribute(corresp);

        int i = 0;

        for (Surface surface : facsimile.getSurfaces()) {
            i++;
            Element surfaceElement = new Element("surface", this.xmlns);
            Element graphElement = new Element("graphic", this.xmlns);

            Attribute graphAtt = new Attribute("url", surface.getGraphic());
            graphElement.setAttribute(graphAtt);

            Attribute idg = new Attribute("id", facsimile.getXmlId() + "-" + i, Namespace.XML_NAMESPACE);
            graphElement.setAttribute(idg);

            surfaceElement.addContent(graphElement);
            facElement.addContent(surfaceElement);
        }

        fragElement.addContent(facElement);
    }

    private void generateTranscription(Element parentElement, Fragment fragment, Set<ScholarInter> scholarInterSelectedSet) {

        Element textElement = new Element("text", this.xmlns);
        parentElement.addContent(textElement);

        Element bodyElement = new Element("body", this.xmlns);
        textElement.addContent(bodyElement);

        Element divElement = new Element("div", this.xmlns);
        bodyElement.addContent(divElement);

        Attribute iddiv = new Attribute("id", fragment.getXmlId() + ".TEXT", Namespace.XML_NAMESPACE);
        divElement.setAttribute(iddiv);

        this.writer = new JDomTEITextPortionWriter(divElement, this.scholarInterSelectedSet);
        // writer.visit((AppText) fragment.getTextPortion());
        AppText app = (AppText) fragment.getTextPortion();
        RdgText rdg = (RdgText) app.getFirstChildText();

        if (rdg.getFirstChildText() instanceof ParagraphText) {
            this.writer.visit((ParagraphText) rdg.getFirstChildText());
        } else if (rdg.getFirstChildText() instanceof PbText) {
            this.writer.visit((PbText) rdg.getFirstChildText());
        }

    }

    // TODO: to remove
    public JDomTEITextPortionWriter getWriter() {
        return this.writer;
    }

    public String updateTeiHeader(String xml) {
        String header = "";
        String result = "";
        Resource resource = new ClassPathResource("teiCorpusHeader.xml");

        try {
            InputStream resourceInputStream = resource.getInputStream();
            header = IOUtils.toString(resourceInputStream, "UTF-8");
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        result = xml.subSequence(0, xml.indexOf("<teiHeader")) + header + "\n" + xml.substring(xml.indexOf("<TEI"));

        return result;
    }

    public String getXMLResult() {
        XMLOutputter xml = new XMLOutputter();
        // we want to format the xml. This is used only for demonstration.
        // pretty formatting adds extra spaces and is generally not required.
        xml.setFormat(Format.getPrettyFormat());
        return updateTeiHeader(xml.outputString(this.jdomDoc));
    }

}


import org.jdom2.*;
import org.jdom2.Content.CType;
import org.jdom2.filter.Filters;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;
import pt.ist.socialsoftware.edition.text.api.dto.ScholarInterDto;
import pt.ist.socialsoftware.edition.text.domain.*;
import pt.ist.socialsoftware.edition.text.domain.AddText.Place;
import pt.ist.socialsoftware.edition.text.domain.AltText.AltMode;
import pt.ist.socialsoftware.edition.text.domain.Fragment.PrecisionType;
import pt.ist.socialsoftware.edition.text.domain.GapText.GapReason;
import pt.ist.socialsoftware.edition.text.domain.GapText.GapUnit;
import pt.ist.socialsoftware.edition.text.domain.ManuscriptSource.Medium;
import pt.ist.socialsoftware.edition.text.domain.RefText.RefType;
import pt.ist.socialsoftware.edition.text.domain.SpaceText.SpaceDim;
import pt.ist.socialsoftware.edition.text.domain.SpaceText.SpaceUnit;




import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

public class LoadTEIFragments {
    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(LoadTEIFragments.class);

    private Element ldoDTEI = null;
    private Namespace namespace = null;
    private TextModule text = null;

    private Document doc = null;

    // to define an order among page breaks
    private int pbOrder = 0;

    private final Map<String, List<Object>> directIdMap = new HashMap<>();

    private void putObjectDirectIdMap(String xmlID, Object object) {

        List<Object> list = this.directIdMap.get(xmlID);
        if (list == null) {
            list = new ArrayList<>();
        }
        list.add(object);

        this.directIdMap.put(xmlID, list);
    }

    private List<Object> getObjectDirectIdMap(String xmlID) {
        List<Object> objects = this.directIdMap.get(xmlID);
        return objects;
    }

    private List<Object> getObjectDirectIdsMap(String[] listXmlId) {
        List<Object> objects = new ArrayList<>();
        for (String xmlId : listXmlId) {
            List<Object> objects2 = getObjectDirectIdMap(xmlId.substring(1));
            if (objects2 == null) {
                throw new LdoDLoadException("identificador não declarado " + xmlId);
            }
            objects.addAll(objects2);
        }
        return objects;
    }

    private Set<ScholarInter> getFragItersByListXmlID(String[] listInterXmlId) {
        List<Object> objects = getObjectDirectIdsMap(listInterXmlId);
        Set<ScholarInter> fragIters = new HashSet<>();
        for (Object object : objects) {
            try {
                fragIters.add((ScholarInter) object);
            } catch (ClassCastException ex) {
                throw new LdoDLoadException(
                        "um dos identificadores desta lista não é um identificador válido de witness: "
                                + Arrays.toString(listInterXmlId));
            }
        }
        return fragIters;
    }

    private final Map<String, Set<Object>> inverseIdMap = new HashMap<>();

    private Set<Object> getObjectInverseIdMap(String xmlID) {
        if (this.inverseIdMap.get(xmlID) == null) {
            return new HashSet<>();
        } else {
            Set<Object> objects = this.inverseIdMap.get(xmlID);
            return objects;
        }
    }

    private void putObjectInverseIdMap(String xmlID, Object object) {

        Set<Object> list = this.inverseIdMap.get(xmlID);
        if (list == null) {
            list = new HashSet<>();
        }
        list.add(object);

        this.inverseIdMap.put(xmlID, list);
    }

    private void getCorpusXmlIds() {
        for (ExpertEdition edition : this.text.getExpertEditionsSet()) {
            putObjectDirectIdMap(edition.getXmlId(), edition);
        }

        for (Heteronym heteronym : this.text.getHeteronymsSet()) {
            putObjectDirectIdMap(heteronym.getXmlId(), heteronym);
        }
    }

    XPathFactory xpfac = XPathFactory.instance();

    private void parseTEIFile(InputStream file) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);
        try {
            // TODO: create a config variable for the xml file
            this.doc = builder.build(file);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato: " + e.getMessage());
        }

        if (this.doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        this.ldoDTEI = this.doc.getRootElement();
        this.namespace = this.ldoDTEI.getNamespace();
    }

    @Atomic(mode = TxMode.WRITE)
    public String loadFragmentsAtOnce(InputStream file) throws LdoDLoadException {
        String message = null;

        parseTEIFile(file);

//        this.virtualModule = VirtualModule.getInstance();
        this.text = TextModule.getInstance();
        getCorpusXmlIds();
        XPathExpression<Element> xp = this.xpfac.compile("//def:TEI/def:teiHeader", Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element element : xp.evaluate(this.doc)) {
            String xmlId = getFragmentXmlId(element);
            String title = getFragmentTitle(element);

            Fragment oldFragment = null;
            for (Fragment frag : this.text.getFragmentsSet()) {
                if (frag.getXmlId().equals(xmlId)) {
                    oldFragment = frag;
                    break;
                }
            }

            try {
                loadFragment(title, xmlId);
            } catch (LdoDLoadException e) {
                throw new LdoDLoadException("[" + title + "(" + xmlId + ")]: " + e.getMessage());
                // Warning: using the code below inconsistent data can be
                // committed
                // message = e.getMessage();
                // if (oldFragment != null) {
                // oldFragment.remove();
                // }
                // break;
            }

            if (oldFragment != null) {
                oldFragment.remove();
            }
        }
        return message;
    }

    public String loadFragmentsStepByStep(InputStream file) throws LdoDLoadException {
        String result = null;

        parseTEIFile(file);

        XPathExpression<Element> xp = this.xpfac.compile("//def:TEI/def:teiHeader", Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element element : xp.evaluate(this.doc)) {
  //          this.virtualModule = VirtualModule.getInstance();
            this.text = TextModule.getInstance();

            String xmlId = getFragmentXmlId(element);
            String title = getFragmentTitle(element);

            result = "CARREGAR: [" + xmlId + "(" + title + ")] <br>";

            Boolean exists = false;
            for (Fragment frag : this.text.getFragmentsSet()) {
                if (frag.getXmlId().equals(xmlId)) {
                    result = result + "------------> FRAG-ID JÁ EXISTE LOGO NÃO FOI CARREGADO <br>";
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                try {
                    atomicLoadFragment(title, xmlId);
                } catch (LdoDLoadException e) {
                    throw new LdoDLoadException("[" + title + "(" + xmlId + ")]: " + e.getMessage());
                }
            }
        }
        return result;
    }

    @Atomic(mode = TxMode.WRITE)
    private void atomicLoadFragment(String title, String xmlId) {
        this.directIdMap.clear();
        this.inverseIdMap.clear();
        getCorpusXmlIds();
        loadFragment(title, xmlId);
    }

    private void loadFragment(String title, String xmlId) {
        Fragment fragment = new Fragment(this.text, title, xmlId);

        putObjectDirectIdMap(xmlId, fragment);

        loadSourceManuscripts(fragment, xmlId);
        loadPrintedSources(fragment, xmlId);
        loadWitnesses(fragment, xmlId);
        loadFacsimile(xmlId);

        loadFragmentText(fragment, xmlId);

    }

    private void loadFragmentText(Fragment fragment, String fragmentXmlID) {
        String selectThisFragment = "[@xml:id='" + fragmentXmlID + "']";
        String queryExpression = "//def:TEI" + selectThisFragment + "/def:text/def:body";

        XPathExpression<Element> xp = this.xpfac.compile(queryExpression, Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        Set<ScholarInter> fragInters = fragment.getScholarInterSet().stream().map(ScholarInter.class::cast).collect(Collectors.toSet());

        AppText app = new AppText(TextPortion.VariationType.UNSPECIFIED);
        app.setFragment(fragment);
        RdgText rdg = new RdgText(app, TextPortion.VariationType.UNSPECIFIED, fragInters);

        Element element = xp.evaluate(this.doc).get(0);

        loadElement(element, rdg);
    }

    private void loadElement(Element element, TextPortion parent) {
        for (Content content : element.getContent()) {
            if (content.getCType() == CType.Text) {
                loadSimpleText((Text) content, parent);
            } else if (content.getCType() == CType.Comment) {
                // ignore comments
            } else if (content.getCType() == CType.Element) {
                Element element2 = (Element) content;
                if (element2.getName().equals("div")) {
                    loadDiv(element2, parent);
                } else if (element2.getName().equals("p")) {
                    loadParagraph(element2, parent);
                } else if (element2.getName().equals("lb")) {
                    loadLb(element2, parent);
                } else if (element2.getName().equals("pb")) {
                    loadPb(element2, parent);
                } else if (element2.getName().equals("app")) {
                    loadApp(element2, parent);
                } else if (element2.getName().equals("space")) {
                    loadSpace(element2, parent);
                } else if (element2.getName().equals("seg")) {
                    loadSeg(element2, parent);
                } else if (element2.getName().equals("add")) {
                    loadAdd(element2, parent);
                } else if (element2.getName().equals("del")) {
                    loadDel(element2, parent);
                } else if (element2.getName().equals("subst")) {
                    loadSubst(element2, parent);
                } else if (element2.getName().equals("gap")) {
                    loadGap(element2, parent);
                } else if (element2.getName().equals("unclear")) {
                    loadUnclear(element2, parent);
                } else if (element2.getName().equals("alt")) {
                    loadAlt(element2, parent);
                } else if (element2.getName().equals("note")) {
                    loadNote(element2, parent);
                } else if (element2.getName().equals("ref")) {
                    loadRef(element2, parent);
                } else {
                    throw new LdoDLoadException("DOES NOT HANDLE LOAD OF:" + element2 + " OF TYPE:"
                            + element2.getCType().toString() + " VALOR=" + element.getText());
                }
            }
        }
    }

    private void loadRef(Element element, TextPortion parent) {
        RefType type = getRefType(element);
        String target = getRefTarget(element);

        RefText refText = new RefText(parent, type, target);

        switch (type) {
            case GRAPHIC:
                // considering that it only refers to surfaces in the same fragment
                Surface surface = parent.getTopParent().getFragment().getSurface(target);
                if (surface != null) {
                    refText.setSurface(surface);
                } else {
                    throw new LdoDLoadException("o valor " + target
                            + " do atributo xml:id do elemento ref não corresponde ao id the nenhum elemento graphic");
                }
                break;
            case WITNESS:
                // considers that it only refers to interpretations in the same
                // fragment
                ScholarInter inter = parent.getFragment().getScholarInterByXmlId(target);
                if (inter != null) {
                    refText.setScholarInter(inter);
                } else {
                    throw new LdoDLoadException("o valor " + target
                            + " do atributo xml:id do elemento ref não corresponde ao id the nenhum elemento witness");
                }
                break;
            case FRAGMENT:
                Fragment fragment = TextModule.getInstance().getFragmentByXmlId(target);
                // if (fragment != null) {
                // if fragment == null is deal in class RefText
                refText.setRefFrag(fragment);
                // } else {
                // throw new LdoDLoadException(
                // "o valor "
                // + target
                // +
                // " do atributo xml:id do elemento ref não corresponde ao id the
                // nenhum elemento fragment."
                // + " NOTA: PODERÁ TER QUE CARREGAR ESSE FRAGMENTO PRIMEIRO");
                // }
                break;
        }

        List<Content> contentList = element.getContent();

        loadSimpleText((Text) contentList.get(0), refText);
    }

    private void loadNote(Element element, TextPortion parent) {
        NoteText.NoteType type = getNoteType(element);

        NoteText noteText = new NoteText(parent, type);

        for (Content content : element.getContent()) {
            if (content.getCType() == CType.Text) {
                if (content.getValue().trim() != "") {
                    loadSimpleText((Text) content, noteText);
                } else {
                    // empty text
                }
            } else if (content.getCType() == CType.Comment) {
                // ignore comments
            } else if (content.getCType() == CType.Element) {
                Element element2 = (Element) content;
                if (element2.getName().equals("ref")) {
                    loadRef(element2, noteText);
                } else {
                    throw new LdoDLoadException("não carrega elementos: " + element2 + " do tipo:" + element2.getName()
                            + " dentro de note " + " _VALOR=" + element.getText());
                }
            }
        }
    }

    private void loadAlt(Element element, TextPortion parent) {
        // get targets
        String[] targetList = getTarget(element);

        List<SegText> segTextList = new ArrayList<>();
        for (String xmlId : targetList) {
            List<Object> listSegTextList = getObjectDirectIdMap(xmlId.substring(1));
            if (listSegTextList == null) {
                throw new LdoDLoadException(
                        "Não está declarado xml:id associado a um identicador target do elemento alt. Valor="
                                + xmlId.substring(1));
            }
            SegText segText = (SegText) listSegTextList.get(0);
            if (segText == null) {
                throw new LdoDLoadException(
                        "Não há elemento seg associado a um identicador target do elemento alt. Valor="
                                + xmlId.substring(1));
            }
            segTextList.add(segText);
        }

        // get mode
        AltMode altMode = getAltMode(element);

        // get weights
        String[] weightList = getAltWeights(element);

        new AltText(parent, segTextList, altMode, weightList);
    }

    private void loadUnclear(Element element, TextPortion parent) {
        List<Content> contentList = element.getContent();

        if (contentList.size() != 1) {
            throw new LdoDLoadException("unclear não contém apenas texto" + element.getText());
        }

        if (contentList.get(0).getCType() != CType.Text) {
            throw new LdoDLoadException("unclear não contém apenas texto" + element.getText());
        }

        UnclearText.UnclearReason reason = getUnclearReasonAttribute(element);
        if (reason == UnclearText.UnclearReason.NONSPECIFIED) {
            throw new LdoDLoadException("O elemento unclear no contexto " + element.getParent().getContent()
                    + " deve ter valor para o atributo reason");
        }

        UnclearText unclearText = new UnclearText(parent, reason);

        loadSimpleText((Text) contentList.get(0), unclearText);
    }

    private void loadGap(Element element, TextPortion parent) {
        GapReason reason = getGapReasonAttribute(element);
        if (reason == GapReason.NONSPECIFIED) {
            throw new LdoDLoadException("O elemento gap no contexto " + element.getParent().getContent()
                    + " deve ter valor para o atributo reason");
        }

        int extent = getExtentAttribute(element);
        if (extent == 0) {
            throw new LdoDLoadException("O elemento gap no contexto " + element.getParent().getContent()
                    + " deve ter valor para o atributo extent");
        }

        GapUnit unit = getGapUnitAttribute(element);
        if (unit == GapUnit.NONSPECIFIED) {
            throw new LdoDLoadException("O elemento gap no contexto " + element.getParent().getContent()
                    + " deve ter valor para o atributo unit");
        }

        new GapText(parent, reason, extent, unit);
    }

    private void loadSubst(Element element, TextPortion parent) {
        SubstText substText = new SubstText(parent);

        for (Content content : element.getContent()) {
            if (content.getCType() == CType.Text) {
                // ignore text
            } else if (content.getCType() == CType.Comment) {
                // ignore comments
            } else if (content.getCType() == CType.Element) {
                Element element2 = (Element) content;
                if (element2.getName().equals("add")) {
                    loadAdd(element2, substText);
                } else if (element2.getName().equals("del")) {
                    loadDel(element2, substText);
                } else {
                    throw new LdoDLoadException("não carrega elementos: " + element2 + " do tipo:" + element2.getName()
                            + " dentro de subst" + " _VALOR=" + element.getText());
                }
            }
        }
    }

    private void loadDel(Element element, TextPortion parent) {
        Attribute howDelAttribute = element.getAttribute("rend");
        DelText.HowDel how = getHowDelAttribute(howDelAttribute);

        DelText delText = new DelText(parent, how);

        for (Content content : element.getContent()) {
            if (content.getCType() == CType.Text) {
                if (content.getValue().trim() != "") {
                    loadSimpleText((Text) content, delText);
                } else {
                    // empty text
                }
            } else if (content.getCType() == CType.Comment) {
                // ignore comments
            } else if (content.getCType() == CType.Element) {
                Element element2 = (Element) content;
                if (element2.getName().equals("add")) {
                    loadAdd(element2, delText);
                } else if (element2.getName().equals("lb")) {
                    loadLb(element2, delText);
                } else if (element2.getName().equals("gap")) {
                    loadGap(element2, delText);
                } else if (element2.getName().equals("unclear")) {
                    loadUnclear(element2, delText);
                } else if (element2.getName().equals("note")) {
                    loadNote(element2, parent);
                } else if (element2.getName().equals("space")) {
                    loadSpace(element2, delText);
                } else {
                    throw new LdoDLoadException("não carrega elementos: " + element2 + " do tipo:" + element2.getName()
                            + " dentro de del " + " _VALOR=" + element.getText());
                }
            }
        }
    }

    private void loadAdd(Element element, TextPortion parent) {
        Attribute placeAttribute = element.getAttribute("place");
        Place place = getPlaceAttribute(placeAttribute);

        AddText addText = new AddText(parent, place);

        setRenditions(element, addText);

        for (Content content : element.getContent()) {
            if (content.getCType() == CType.Text) {
                if (content.getValue().trim() != "") {
                    loadSimpleText((Text) content, addText);
                } else {
                    // empty text
                }
            } else if (content.getCType() == CType.Comment) {
                // ignore comments
            } else if (content.getCType() == CType.Element) {
                Element element2 = (Element) content;
                if (element2.getName().equals("add")) {
                    loadAdd(element2, addText);
                } else if (element2.getName().equals("del")) {
                    loadDel(element2, addText);
                } else if (element2.getName().equals("subst")) {
                    loadSubst(element2, addText);
                } else if (element2.getName().equals("gap")) {
                    loadGap(element2, addText);
                } else if (element2.getName().equals("unclear")) {
                    loadUnclear(element2, addText);
                } else if (element2.getName().equals("lb")) {
                    loadLb(element2, addText);
                } else if (element2.getName().equals("seg")) {
                    loadSeg(element2, addText);
                } else if (element2.getName().equals("note")) {
                    loadNote(element2, parent);
                } else {
                    throw new LdoDLoadException("não carrega elementos: " + element2 + " do tipo:" + element2.getName()
                            + " dentro de add" + "_VALOR=" + element.getText());

                }
            }
        }
    }

    /**
     * In this project a <seg> element can only contain simple text, it is used for
     * formating and cross referencing
     */
    private void loadSeg(Element element, TextPortion parent) {
        List<Content> contentList = element.getContent();

        if (contentList.size() != 1) {
            throw new LdoDLoadException("seg não contém apenas texto" + element.getText());
        }

        if (contentList.get(0).getCType() != CType.Text) {
            throw new LdoDLoadException("seg não contém apenas texto" + element.getText());
        }

        SegText segText = new SegText(parent);

        Attribute xmlIdAttribute = element.getAttribute("id", element.getNamespace("xml"));
        if (xmlIdAttribute != null) {
            segText.setXmlId(xmlIdAttribute.getValue());
            putObjectDirectIdMap(xmlIdAttribute.getValue(), segText);
        }

        setRenditions(element, segText);

        loadSimpleText((Text) contentList.get(0), segText);
    }

    private void loadSpace(Element element, TextPortion parent) {
        SpaceText.SpaceDim dim = getDimAttribute(element);
        SpaceText.SpaceUnit unit = getUnitAttribute(element);
        int quantity = getQuantityAttribute(element);

        new SpaceText(parent, dim, quantity, unit);
    }

    private void loadRdgGrp(Element rdgGrpElement, TextPortion parent) {
        TextPortion.VariationType type = getVariationType(rdgGrpElement);

        RdgGrpText rdgGrpText = new RdgGrpText(parent, type);
        for (Element rdgElement : rdgGrpElement.getChildren()) {
            if (rdgElement.getName().equals("rdg")) {
                loadRdg(rdgElement, rdgGrpText);
            } else if (rdgElement.getName().equals("rdgGrp")) {
                loadRdgGrp(rdgElement, rdgGrpText);
            }
        }
    }

    private void loadRdg(Element rdgElement, TextPortion parent) {
        TextPortion.VariationType type = getVariationType(rdgElement);

        Attribute witAttribute = rdgElement.getAttribute("wit");

        if (witAttribute == null) {
            throw new LdoDLoadException("elemento rdg necessita de atributo wit " + rdgElement.getText());
        }

        String witValue = rdgElement.getAttribute("wit").getValue().trim();

        String[] listInterXmlId = witValue.split("\\s+");
        Set<ScholarInter> fragInters = getFragItersByListXmlID(listInterXmlId);

        RdgText rdgText = new RdgText(parent, type, fragInters);

        if (!rdgElement.getContent().isEmpty()) {
            loadElement(rdgElement, rdgText);
        }
    }

    private void loadApp(Element appElement, TextPortion parent) {
        TextPortion.VariationType type = getVariationType(appElement);

        AppText app = new AppText(parent, type);

        for (Element rdgElement : appElement.getChildren()) {
            if (rdgElement.getName().equals("rdg")) {
                loadRdg(rdgElement, app);
            } else if (rdgElement.getName().equals("rdgGrp")) {
                loadRdgGrp(rdgElement, app);
            } else {
                throw new LdoDLoadException("elemento inesperado dentro de app" + " VALOR=" + rdgElement.getName());
                // assert false : "UNEXPECTED ELEMENT NESTED WITHIN APP" +
                // rdgElement.getName();
            }
        }
    }

    private void loadPb(Element element, TextPortion parent) {
        Set<ScholarInter> toFragInters = null;

        Attribute edAttribute = element.getAttribute("ed");
        if (edAttribute == null) {
            toFragInters = parent.getInterps();
        } else {
            String[] listInterXmlId = element.getAttribute("ed").getValue().split("\\s+");
            toFragInters = getFragItersByListXmlID(listInterXmlId);

            for (ScholarInter inter : toFragInters) {
                if (!parent.getInterps().contains(inter)) {
                    throw new LdoDLoadException("testemunho com identificador:" + inter.getXmlId()
                            + " é associado a pb mas não está declarado no contexto do seu rdg");
                }
            }
        }

        PbText pbText = new PbText(parent, toFragInters, this.pbOrder++);

        Attribute facsAttribute = element.getAttribute("facs");
        if (facsAttribute != null) {
            String facsValue = facsAttribute.getValue();

            Surface surface = null;
            for (Source source : parent.getTopParent().getFragment().getSourcesSet()) {
                for (Surface surf : source.getFacsimile().getSurfaces()) {
                    if (surf.getGraphic().equals(facsValue)) {
                        surface = surf;
                        break;
                    }
                }
            }

            if (surface == null) {
                throw new LdoDLoadException("o attributo facs do elemento pb que tem o valor=" + facsValue
                        + " não está associado a nenhum elemento graphic de surface");
            } else {
                pbText.setSurface(surface);
            }
        }

    }

    private void loadLb(Element element, TextPortion parent) {
        Set<ScholarInter> toFragInters = null;

        Attribute edAttribute = element.getAttribute("ed");
        if (edAttribute == null) {
            toFragInters = parent.getInterps();
        } else {
            String xmlsString = element.getAttribute("ed").getValue().trim();
            String[] listInterXmlId = xmlsString.split("\\s+");

            toFragInters = getFragItersByListXmlID(listInterXmlId);

            for (ScholarInter inter : toFragInters) {
                if (!parent.getInterps().contains(inter)) {
                    throw new LdoDLoadException("testemunho com identificador:" + inter.getXmlId()
                            + " é associado a lb mas não está declarado no contexto do seu rdg");
                }
            }
        }

        new LbText(parent, isBreak(element), isHiphenated(element), toFragInters);
    }

    private void loadSimpleText(Text text, TextPortion parent) {
        String value = text.getTextTrim();

        if (value.equals("")) {
            // ignore empty space
        } else {
            new SimpleText(parent, value);
        }
    }

    private void loadParagraph(Element paragraph, TextPortion parent) {
        ParagraphText paragraphText = new ParagraphText(parent);

        String xmlID = paragraph.getAttributeValue("id", paragraph.getNamespace("xml"));

        for (Object obj : getObjectInverseIdMap(xmlID)) {
            PhysNote physNote = (PhysNote) obj;
            physNote.addTextPortion(paragraphText);
        }

        loadElement(paragraph, paragraphText);
    }

    private void loadDiv(Element div, TextPortion parent) {
        loadElement(div, parent);
    }

    private void loadFacsimile(String fragmentTEIID) {
        String selectThisFragment = "[@xml:id='" + fragmentTEIID + "']";
        String queryExpression = "//def:TEI" + selectThisFragment + "/def:facsimile";

        XPathExpression<Element> xp = this.xpfac.compile(queryExpression, Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element facsElement : xp.evaluate(this.doc)) {
            String xmlID = facsElement.getAttributeValue("id", facsElement.getNamespace("xml"));

            if (xmlID == null) {
                throw new LdoDLoadException("elemento facsimile sem atributo xml:id");
            }

            if (getObjectDirectIdMap(xmlID) != null) {
                throw new LdoDLoadException("o atributo xml:id=" + xmlID + " de facsimile já foi declarado");
            }

            Attribute correspAtt = facsElement.getAttribute("corresp");
            String sourceID = null;
            if (correspAtt != null) {
                sourceID = correspAtt.getValue().substring(1);
            } else {
                throw new LdoDLoadException("elemento facsimile xml:id=" + xmlID + " necessita de atributo corresp");
            }

            List<Object> list = getObjectDirectIdMap(sourceID);

            if (list == null) {
                throw new LdoDLoadException("Referência=" + sourceID + " para testemunho fonte em facsimilexml:id="
                        + xmlID + " não existe");
            }

            Source source = (Source) list.get(0);

            if (source.getFacsimile() != null) {
                throw new LdoDLoadException("Existe mais do que um fac-símile para a fonte com referência=" + sourceID);
            }

            Facsimile facsimile = new Facsimile(source, xmlID);

            putObjectDirectIdMap(sourceID, facsimile);

            loadSurface(facsElement, facsimile);
        }

    }

    private void loadSurface(Element facsElement, Facsimile facsimile) {
        for (Element surfElement : facsElement.getChildren("surface", this.namespace)) {
            Element graphElement = surfElement.getChild("graphic", this.namespace);

            if (graphElement == null) {
                throw new LdoDLoadException("elemento surface não possui elemento graphic");
            }

            String graphic = graphElement.getAttributeValue("url");
            Attribute xmlIdAttribute = graphElement.getAttribute("id", graphElement.getNamespace("xml"));
            if (xmlIdAttribute != null) {
                String xmlId = xmlIdAttribute.getValue();
                Surface surface = new Surface(facsimile, graphic, xmlId);

                // when loading ref in annex notes in witnesses the surface was
                // not created yet
                for (Object refText : getObjectInverseIdMap(xmlId)) {
                    ((RefText) refText).setSurface(surface);
                }
            } else {
                new Surface(facsimile, graphic);
            }
        }

    }

    // TODO: a cleaner way to read parent's xmlID
    // TODO: its is necessary to refactor this part of the domain, define what
    // is common in FragInter
    private void loadWitnesses(Fragment fragment, String fragmentTEIID) {
        String selectThisFragment = "[@xml:id='" + fragmentTEIID + "']";
        String queryExpression = "//def:TEI" + selectThisFragment
                + "/def:teiHeader/def:fileDesc/def:sourceDesc/def:listWit/.//def:witness";

        XPathExpression<Element> xp = this.xpfac.compile(queryExpression, Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element witness : xp.evaluate(this.doc)) {
            String sourceOrEditionXmlID = witness.getChild("ref", this.namespace).getAttributeValue("target")
                    .substring(1);

            List<Object> objects = getObjectDirectIdMap(sourceOrEditionXmlID);

            if (objects == null || objects.isEmpty()) {
                throw new LdoDLoadException(
                        "não existe uma fonte declarada para o atributo xml:id=" + sourceOrEditionXmlID);
            }

            assert objects != null && !objects.isEmpty() : "MISSING SOURCE OBJECT FOR xml:id:" + sourceOrEditionXmlID;

            String witnessXmlID = witness.getAttributeValue("id", witness.getNamespace("xml"));
            String witnessListXmlID = witness.getParentElement().getAttributeValue("id", witness.getNamespace("xml"));
            String witnessListXmlID2 = witness.getParentElement().getParentElement().getAttributeValue("id",
                    witness.getNamespace("xml"));

            if (witnessXmlID == null) {
                throw new LdoDLoadException("elemento wit sem atributo xml:id=" + witnessXmlID);
            }
            assert witnessXmlID != null : "MISSING xml:id FOR WITNESS";

            if (getObjectDirectIdMap(witnessXmlID) != null) {
                throw new LdoDLoadException("já está declarado o atributo xml:id=" + witnessXmlID);
            }
            assert getObjectDirectIdMap(witnessXmlID) == null : "xml:id:" + witnessXmlID + " IS ALREADY DECLARED";

            if (witnessListXmlID == null) {
                throw new LdoDLoadException("falta atributo xml:id para listWit");
            }
            assert witnessListXmlID != null : "MISSING xml:id FOR WITNESS LIST";

            if (witnessListXmlID2 == null) {
                throw new LdoDLoadException("falta atributo xml:id para listWit");
            }
            assert witnessListXmlID2 != null : "MISSING xml:id FOR WITNESS LIST";

            Object object = objects.get(0);

            ScholarInter fragInter = null;

            if (object instanceof ManuscriptSource) {
                fragInter = new SourceInter();
                fragInter.setFragment(fragment);
                ((SourceInter) fragInter).setSource((ManuscriptSource) object);
            } else if (object instanceof PrintedSource) {
                fragInter = new SourceInter();
                fragInter.setFragment(fragment);
                ((SourceInter) fragInter).setSource((PrintedSource) object);
            } else {
                // (object instanceof ExpertEdition)

                fragInter = new ExpertEditionInter();
                fragInter.setFragment(fragment);
                ((ExpertEditionInter) fragInter).setExpertEdition((ExpertEdition) object);
            }

            // when loading ref in annex notes in witnesses the witness may
            // not be created yet
            for (Object refText : getObjectInverseIdMap(witnessXmlID)) {
                ((RefText) refText).setScholarInter(fragInter);
            }

            Element bibl = witness.getChild("bibl", this.namespace);
            if (bibl != null) {
                Heteronym heteronym = getHeteronym(bibl);
                if (heteronym != null) {
                    fragInter.setHeteronym(heteronym);
                } else {
                    fragInter.setHeteronym(NullHeteronym.getNullHeteronym());
                }

                Element titleElement = bibl.getChild("title", this.namespace);
                if (titleElement != null && fragInter instanceof ExpertEditionInter) {
                    ((ExpertEditionInter) fragInter).setTitle(titleElement.getTextTrim());
                }

                Element dateElement = bibl.getChild("date", this.namespace);
                if (dateElement != null) {
                    Attribute whenAttribute = dateElement.getAttribute("when");
                    if (whenAttribute == null) {
                        fragInter.setLdoDDate(null);
                    } else {
                        PrecisionType precision = getPrecisionAttribute(dateElement);

                        fragInter.setLdoDDate(new LdoDDate(whenAttribute.getValue(), precision));
                    }
                }

                setBiblScopes(fragInter, bibl);

                setNotes(fragInter, bibl);
            } else {
                fragInter.setHeteronym(NullHeteronym.getNullHeteronym());
            }

            fragInter.setXmlId(witnessXmlID);

            putObjectDirectIdMap(witnessXmlID, fragInter);
            putObjectDirectIdMap(witnessListXmlID, fragInter);
            putObjectDirectIdMap(witnessListXmlID2, fragInter);
        }

    }

    private void setNotes(ScholarInter fragInter, Element bibl) {
        String notes = "";
        List<Element> notesList = bibl.getChildren("note", this.namespace);
        for (Element noteElement : notesList) {
            String typeValue = noteElement.getAttributeValue("type");
            if (typeValue == null) {
                throw new LdoDLoadException("elemento note sem atributo type");
            }
            if (typeValue.equals("physDesc")) {
                notes = notes + noteElement.getTextTrim() + ";";
            } else if (typeValue.equals("annex")) {
                AnnexNote annexNote = new AnnexNote(fragInter);

                NoteText.NoteType type = NoteText.NoteType.ANNEX;
                NoteText noteText = new NoteText(annexNote, type);

                annexNote.setNoteText(noteText);

                for (Content content : noteElement.getContent()) {
                    if (content.getCType() == CType.Text) {
                        if (!content.getValue().trim().equals("")) {
                            loadSimpleText((Text) content, noteText);
                        } else {
                            // empty text
                        }
                    } else if (content.getCType() == CType.Comment) {
                        // ignore comments
                    } else if (content.getCType() == CType.Element) {
                        Element element2 = (Element) content;
                        if (element2.getName().equals("ref")) {
                            RefType refType = getRefType(element2);
                            String target = getRefTarget(element2);

                            RefText refText = new RefText(noteText, refType, target);

                            if (refType == RefType.GRAPHIC) {
                                Surface surface = fragInter.getFragment().getSurface(target);
                                if (surface != null) {
                                    refText.setSurface(surface);
                                } else {
                                    putObjectInverseIdMap(target, refText);
                                }
                            } else if (refType == RefType.WITNESS) {
                                ScholarInter inter = (ScholarInter) fragInter.getFragment().getScholarInterByXmlId(target);
                                if (inter != null) {
                                    refText.setScholarInter(inter);
                                } else {
                                    putObjectInverseIdMap(target, refText);
                                }
                            } else if (refType == RefType.FRAGMENT) {
                                Fragment frag = TextModule.getInstance().getFragmentByXmlId(target);
                                // if (frag != null) {
                                // it is not verified if frag == null but an
                                // exception will be raised when accessing the
                                // fragment
                                refText.setRefFrag(frag);
                                // } else {
                                // throw new LdoDLoadException(
                                // "o valor "
                                // + target
                                // +
                                // " do atributo xml:id do elemento ref não
                                // corresponde ao id the nenhum elemento
                                // fragment."
                                // +
                                // " NOTA: PODERÁ TER QUE CARREGAR ESSE
                                // FRAGMENTO PRIMEIRO");
                                //
                                // }
                            }

                            fragInter.getFragment().getScholarInterByXmlId(target);

                            List<Content> contentList = element2.getContent();

                            loadSimpleText((Text) contentList.get(0), refText);
                        } else {
                            throw new LdoDLoadException("não carrega elementos: " + element2 + " do tipo:"
                                    + element2.getName() + " dentro de note " + " _VALOR=" + noteElement.getText());
                        }
                    }
                }

            } else {
                throw new LdoDLoadException("atributo type de elemento note com valor=" + typeValue);
            }

            if (fragInter instanceof ExpertEditionInter) {
                ((ExpertEditionInter) fragInter).setNotes(notes);
            }
        }
    }

    private void setBiblScopes(ScholarInter fragInter, Element bibl) {
        for (Element biblScope : bibl.getChildren("biblScope", this.namespace)) {
            Attribute unitAtt = biblScope.getAttribute("unit");
            if (unitAtt == null) {
                throw new LdoDLoadException("elemento biblScope sem atributo unit" + " título="
                        + bibl.getChildren("title", this.namespace));
            }
            String value = biblScope.getTextTrim();
            switch (unitAtt.getValue()) {
                case "pp":
                    if (fragInter instanceof ExpertEditionInter) {
                        if (value != null && !value.equals("")) {
                            ((ExpertEditionInter) fragInter).setStartPage(Integer.parseInt(value));
                            ((ExpertEditionInter) fragInter).setEndPage(Integer.parseInt(value));
                        } else {
                            String from = biblScope.getAttributeValue("from");
                            String to = biblScope.getAttributeValue("to");

                            ((ExpertEditionInter) fragInter).setStartPage(Integer.parseInt(from));
                            ((ExpertEditionInter) fragInter).setEndPage(Integer.parseInt(to));
                        }
                    }
                    break;
                case "vol":
                    if (value == null) {
                        value = "";
                    }
                    ((ExpertEditionInter) fragInter).setVolume(value);
                    break;
                case "number":
                    if (value != null && !value.equals("")) {
                        ((ExpertEditionInter) fragInter).setNumber(Integer.parseInt(value.trim()));
                    } else {
                        ((ExpertEditionInter) fragInter).setNumber(0);
                    }
                    break;
                case "subnumber":
                    if (value != null && !value.trim().equals("")) {
                        ((ExpertEditionInter) fragInter).setSubNumber(value.trim());
                    } else {
                        ((ExpertEditionInter) fragInter).setSubNumber("");
                    }
                    break;
            }
        }
    }

    private Heteronym getHeteronym(Element bibl) {
        Heteronym heteronym;
        String hetXmlId = null;
        Element respStmt = bibl.getChild("respStmt", this.namespace);
        if (respStmt != null) {
            Element persName = respStmt.getChild("persName", this.namespace);
            if (persName != null) {
                Attribute correspAtt = persName.getAttribute("corresp");
                if (correspAtt != null) {
                    hetXmlId = persName.getAttributeValue("corresp").substring(1);

                    List<Object> heteronymList = getObjectDirectIdMap(hetXmlId);
                    if (heteronymList != null) {
                        heteronym = (Heteronym) heteronymList.get(0);
                    } else {
                        throw new LdoDLoadException("atributo corresp=" + hetXmlId + " para persName em witness "
                                + bibl.getValue() + " não está declarado");
                    }
                } else {
                    throw new LdoDLoadException("falta atributo corresp para persName em witness" + bibl.getValue());
                }
            } else {
                throw new LdoDLoadException("falta atributo element persName em witness respStmt" + bibl.getValue());
            }
        } else {
            heteronym = NullHeteronym.getNullHeteronym();
        }
        return heteronym;
    }

    private void loadPrintedSources(Fragment fragment, String fragmentTEIID) {
        String selectThisFragment = "[@xml:id='" + fragmentTEIID + "']";
        String queryExpression = "//def:TEI" + selectThisFragment
                + "/def:teiHeader/def:fileDesc/def:sourceDesc/def:listBibl/.//def:bibl";

        XPathExpression<Element> xp = this.xpfac.compile(queryExpression, Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element bibl : xp.evaluate(this.doc)) {
            PrintedSource printedSource = new PrintedSource();
            printedSource.setFragment(fragment);

            Element msId = bibl.getChild("msIdentifier", this.namespace);
            loadMsId(msId, printedSource);

            String biblID = bibl.getAttributeValue("id", bibl.getNamespace("xml"));

            if (getObjectDirectIdMap(biblID) != null) {
                throw new LdoDLoadException("já está declarado o atributo xml:id=" + biblID);
            }
            assert getObjectDirectIdMap(biblID) == null : "xml:id:" + biblID + " IS ALREADY DECLARED";

            putObjectDirectIdMap(biblID, printedSource);

            printedSource.setXmlId(biblID);

            Heteronym heteronym = getHeteronym(bibl);
            printedSource.setHeteronym(heteronym);

            for (Element title : bibl.getChildren("title", this.namespace)) {
                Attribute levelAtt = title.getAttribute("level");
                if (levelAtt == null) {
                    throw new LdoDLoadException("elemento title sem level " + " biblID=" + printedSource.getXmlId());
                }
                String value = title.getTextTrim();
                if (value == null || value.equals("")) {
                    throw new LdoDLoadException("elemento title sem valor " + " biblID=" + printedSource.getXmlId());
                }

                switch (levelAtt.getValue()) {
                    case "a":
                        printedSource.setTitle(value);
                        break;
                    case "j":
                        printedSource.setJournal(value);
                        break;
                    default:
                        throw new LdoDLoadException(
                                "elemento biblScope com attributo com valor não esperado " + levelAtt.getValue());
                }
            }

            printedSource.setPubPlace(bibl.getChildText("pubPlace", this.namespace));

            Element dateElement = bibl.getChild("date", this.namespace);
            if (dateElement != null) {
                Attribute whenAttribute = dateElement.getAttribute("when");

                if (whenAttribute == null) {
                    printedSource.setLdoDDate(null);
                } else {
                    PrecisionType precision = getPrecisionAttribute(dateElement);
                    printedSource.setLdoDDate(new LdoDDate(whenAttribute.getValue(), precision));
                }
            } else {
                throw new LdoDException(
                        "A fonte autoral impressa não possui data attibuída " + printedSource.getTitle());
            }

            for (Element biblScope : bibl.getChildren("biblScope", this.namespace)) {
                Attribute unitAtt = biblScope.getAttribute("unit");
                if (unitAtt == null) {
                    throw new LdoDLoadException(
                            "elemento biblScope sem atributo unit" + " título=" + printedSource.getTitle());
                }
                String value = biblScope.getTextTrim();
                switch (unitAtt.getValue()) {
                    case "pp":
                        if (value != null && !value.equals("")) {
                            printedSource.setStartPage(Integer.parseInt(value));
                            printedSource.setEndPage(Integer.parseInt(value));
                        } else {
                            String from = biblScope.getAttributeValue("from");
                            String to = biblScope.getAttributeValue("to");

                            printedSource.setStartPage(Integer.parseInt(from));
                            printedSource.setEndPage(Integer.parseInt(to));
                        }
                        break;
                    case "issue":
                        if (value == null) {
                            throw new LdoDLoadException(
                                    "elemento biblScope issues sem número " + " título=" + printedSource.getTitle());
                        }
                        printedSource.setIssue(value);
                        break;
                    default:
                        throw new LdoDLoadException("elemento biblScope com attributo com valor não esperado "
                                + unitAtt.getValue() + " título=" + printedSource.getTitle());
                }
            }

        }

    }

    private void loadSourceManuscripts(Fragment fragment, String fragmentTEIID) {

        String selectThisFragment = "[@xml:id='" + fragmentTEIID + "']";
        String queryExpression = "//def:TEI" + selectThisFragment
                + "/def:teiHeader/def:fileDesc/def:sourceDesc/def:listBibl/.//def:msDesc";

        XPathExpression<Element> xp = this.xpfac.compile(queryExpression, Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element msDesc : xp.evaluate(this.doc)) {
            ManuscriptSource manuscript = new ManuscriptSource();
            manuscript.setFragment(fragment);

            String manuscriptID = msDesc.getAttributeValue("id", msDesc.getNamespace("xml"));

            if (getObjectDirectIdMap(manuscriptID) != null) {
                throw new LdoDLoadException("já está declarado o atributo xml:id=" + manuscriptID);
            }

            putObjectDirectIdMap(manuscriptID, manuscript);

            manuscript.setXmlId(manuscriptID);

            Element msId = msDesc.getChild("msIdentifier", this.namespace);
            loadMsId(msId, manuscript);

            loadPhysDesc(msDesc, manuscript);

            loadMsHistory(msDesc, manuscript);
        }
    }

    private void loadDimensions(Element supportDesc, ManuscriptSource manuscript) {
        List<Element> dimensionsList = supportDesc.getChild("extent", this.namespace).getChildren("dimensions",
                this.namespace);

        int position = 1;
        for (Element dimensions : dimensionsList) {
            String unit = dimensions.getAttributeValue("unit");
            if (!unit.equals("cm")) {
                throw new LdoDException("As unidades (unit) do elemento dimensions deve ser em cm");
            }

            Float height;
            try {
                height = Float.parseFloat(dimensions.getChildTextTrim("height", this.namespace));
            } catch (NumberFormatException e) {
                throw new LdoDException("O valor de height do elemento dimensions não pode ser "
                        + dimensions.getChildTextTrim("height", this.namespace));
            }

            Float width;
            try {
                width = Float.parseFloat(dimensions.getChildTextTrim("width", this.namespace));
            } catch (NumberFormatException e) {
                throw new LdoDException("O valor de width do elemento dimensions não pode ser "
                        + dimensions.getChildTextTrim("width", this.namespace));
            }

            manuscript.addDimensions(new Dimensions(height, width, ++position));
        }
    }

    private void loadMsHistory(Element msDesc, ManuscriptSource manuscript) {
        manuscript.setLdoDDate(null);

        Element history = msDesc.getChild("history", this.namespace);
        if (history != null) {
            Element origin = history.getChild("origin", this.namespace);

            if (origin != null) {
                Element origDate = origin.getChild("origDate", this.namespace);

                if (origDate != null) {
                    Attribute when = origDate.getAttribute("when");

                    if (when == null) {
                        // TODO: some fragments have the hierarchy but not the
                        // last element
                        // throw new LdoDLoadException(
                        // "Não existe attributo when associado a elemento
                        // msDesc.history.origin.origDate da fonte "
                        // + manuscript.getXmlId());
                    } else {
                        PrecisionType precision = getPrecisionAttribute(origDate);

                        manuscript.setLdoDDate(new LdoDDate(when.getValue(), precision));
                    }
                }
            }
        }
    }

    private void loadMsId(Element msIdentifier, Source source) {
        source.setSettlement(msIdentifier.getChildText("settlement", this.namespace));
        source.setRepository(msIdentifier.getChildText("repository", this.namespace));
        source.setIdno(msIdentifier.getChildText("idno", this.namespace));

        Element altElement = msIdentifier.getChild("altIdentifier", this.namespace);

        if (altElement == null) {
            throw new LdoDLoadException(
                    "falta declarar altIdentifier de um msIdentifier" + " _VALOR_ " + msIdentifier.getContent());
        }

        source.setAltIdentifier(altElement.getChildText("idno", this.namespace));
    }

    private void loadPhysDesc(Element msDesc, ManuscriptSource manuscript) {
        Element physDesc = msDesc.getChild("physDesc", this.namespace);

        Element objectDesc = physDesc.getChild("objectDesc", this.namespace);
        if (objectDesc.getAttributeValue("form").equals("leaf")) {
            manuscript.setForm(ManuscriptSource.Form.LEAF);
        } else {
            throw new LdoDLoadException("não está definido o valor do atributo form="
                    + objectDesc.getAttributeValue("form") + " _VALOR_ " + objectDesc.getContent());
        }

        Element supportDesc = objectDesc.getChild("supportDesc", this.namespace);
        if (supportDesc.getAttributeValue("material").equals("paper")) {
            manuscript.setMaterial(ManuscriptSource.Material.PAPER);
        } else {
            throw new LdoDLoadException("não está definido o valor do atributo material="
                    + supportDesc.getAttributeValue("material") + " _VALOR_ " + supportDesc.getContent());
        }

        if (supportDesc.getChild("extent", this.namespace) != null) {
            loadDimensions(supportDesc, manuscript);
        }

        Element layoutElement = objectDesc.getChild("layoutDesc", this.namespace).getChild("layout", this.namespace);
        manuscript.setColumns(Integer.parseInt(layoutElement.getAttributeValue("columns")));

        if (physDesc.getChild("handDesc", this.namespace) != null) {
            loadHandDesc(manuscript, physDesc);
        }
        if (physDesc.getChild("typeDesc", this.namespace) != null) {
            loadTypeDesc(manuscript, physDesc);
        }

        Element additions = physDesc.getChild("additions", this.namespace);
        if (additions.getTextTrim().equals("VirtualModule")) {
            manuscript.setHasLdoDLabel(true);
        }

        Element binding = physDesc.getChild("bindingDesc", this.namespace).getChild("binding", this.namespace)
                .getChild("p", this.namespace);

        manuscript.setNotes(additions.getTextTrim() + ", " + binding.getTextTrim());
    }

    private void loadTypeDesc(ManuscriptSource manuscript, Element physDesc) {
        Element typeDesc = physDesc.getChild("typeDesc", this.namespace);
        Element typeDescParagraph = typeDesc.getChild("p", this.namespace);
        String stringTypeNote = null;

        if (typeDescParagraph != null) {
            stringTypeNote = typeDescParagraph.getTextTrim();
            TypeNote typeNote = new TypeNote(null, stringTypeNote);
            typeNote.setManuscript(manuscript);
        } else {
            for (Element typeNoteElement : typeDesc.getChildren("typeNote", this.namespace)) {
                String mediumValue = typeNoteElement.getAttributeValue("medium");
                Medium medium = getMedium(mediumValue);

                if (typeNoteElement.getChild("locus", this.namespace) != null) {
                    stringTypeNote = typeNoteElement.getChild("locus", this.namespace).getTextTrim();
                } else if (typeNoteElement.getChild("p", this.namespace) != null) {
                    stringTypeNote = typeNoteElement.getChild("p", this.namespace).getTextTrim();
                } else {
                    throw new LdoDLoadException(
                            "Elemento typeNote sem locus ou p " + "_VALOR_ " + typeNoteElement.getContent());
                }

                TypeNote typeNote = new TypeNote(medium, stringTypeNote);
                typeNote.setManuscript(manuscript);

                if (typeNoteElement.getChild("locus", this.namespace) != null) {
                    String[] targets = typeNoteElement.getChild("locus", this.namespace).getAttributeValue("target")
                            .trim().split("\\s+");
                    for (String target : targets) {
                        putObjectInverseIdMap(target.substring(1), typeNote);
                    }
                }
            }
        }
    }

    private void loadHandDesc(ManuscriptSource manuscript, Element physDesc) {
        Element handDesc = physDesc.getChild("handDesc", this.namespace);
        Element handDescParagraph = handDesc.getChild("p", this.namespace);
        String stringHandNote = null;

        if (handDescParagraph != null) {
            stringHandNote = handDescParagraph.getTextTrim();

            HandNote handNote = new HandNote(null, stringHandNote);
            handNote.setManuscript(manuscript);
        } else {
            for (Element handNoteElement : handDesc.getChildren("handNote", this.namespace)) {
                String mediumValue = handNoteElement.getAttributeValue("medium");
                Medium medium = getMedium(mediumValue);

                if (handNoteElement.getChild("locus", this.namespace) != null) {
                    stringHandNote = handNoteElement.getChild("locus", this.namespace).getTextTrim();
                } else if (handNoteElement.getChild("p", this.namespace) != null) {
                    stringHandNote = handNoteElement.getChild("p", this.namespace).getTextTrim();
                } else {
                    throw new LdoDLoadException(
                            "Elemento handNote sem locus ou p " + "_VALOR_ " + handNoteElement.getContent());
                }

                HandNote handNote = new HandNote(medium, stringHandNote);
                handNote.setManuscript(manuscript);

                if (handNoteElement.getChild("locus", this.namespace) != null) {
                    String[] targets = handNoteElement.getChild("locus", this.namespace).getAttributeValue("target")
                            .trim().split("\\s+");
                    for (String target : targets) {
                        putObjectInverseIdMap(target.substring(1), handNote);
                    }
                }
            }
        }
    }

    private String getRefTarget(Element element) {
        String target = null;
        Attribute targetAttribute = element.getAttribute("target");
        if (targetAttribute != null) {
            target = targetAttribute.getValue();
        } else {
            throw new LdoDLoadException("É necessário o atributo target para o elemento ref");
        }

        if (target != null && !target.equals("")) {
            return target.substring(1);
        } else {
            throw new LdoDLoadException("Falta o valor do atributo target para o elemento ref");
        }

    }

    private PrecisionType getPrecisionAttribute(Element date) {
        Attribute precisionAttribute = date.getAttribute("precision");
        if (precisionAttribute != null) {
            switch (precisionAttribute.getValue()) {
                case "high":
                    return PrecisionType.HIGH;
                case "medium":
                    return PrecisionType.MEDIUM;
                case "low":
                    return PrecisionType.LOW;
                case "unknown":
                    return PrecisionType.UNKNOWN;
                default:
                    throw new LdoDLoadException("valor inesperado para atribute precison=" + precisionAttribute.getValue());
            }
        } else {
            return null;
        }
    }

    private RefType getRefType(Element element) {
        RefType type = null;

        String typeValue = null;
        Attribute typeAttribute = element.getAttribute("type");
        if (typeAttribute != null) {
            typeValue = typeAttribute.getValue();
        } else {
            throw new LdoDLoadException("o elemento ref deve ter valor para o atributo type");
        }

        switch (typeValue) {
            case "graphic":
                type = RefType.GRAPHIC;
                break;
            case "witness":
                type = RefType.WITNESS;
                break;
            case "fragment":
                type = RefType.FRAGMENT;
                break;
            default:
                throw new LdoDLoadException("valor inesperado para atribute type do elemento ref=" + typeValue);
        }

        return type;
    }

    private NoteText.NoteType getNoteType(Element element) {
        NoteText.NoteType type = null;

        String typeValue = null;
        Attribute typeAttribute = element.getAttribute("type");
        if (typeAttribute != null) {
            typeValue = typeAttribute.getValue();
        }

        if (typeValue == null) {
            throw new LdoDLoadException("elemento note não possui atributo type");
        }

        switch (typeValue) {
            case "annex":
                type = NoteText.NoteType.ANNEX;
                break;
            default:
                throw new LdoDLoadException("valor inesperado para atribute type do elemento note=" + typeValue);
        }

        return type;
    }

    private Medium getMedium(String mediumValue) {
        Medium medium = null;
        switch (mediumValue) {
            case "pen":
                medium = Medium.PEN;
                break;
            case "pencil":
                medium = Medium.PENCIL;
                break;
            case "blue-ink":
                medium = Medium.BLUE_INK;
                break;
            case "black-ink":
                medium = Medium.BLACK_INK;
                break;
            case "violet-ink":
                medium = Medium.VIOLET_INK;
                break;
            case "red-ink":
                medium = Medium.RED_INK;
                break;
            case "green-ink":
                medium = Medium.GREEN_INK;
                break;
            default:
                throw new LdoDLoadException("valor inesperado para atribute medium=" + mediumValue);
        }
        return medium;
    }

    private Boolean isHiphenated(Element element) {
        String hyphenated = null;
        Attribute hyphenatedAttribute = element.getAttribute("type");
        if (hyphenatedAttribute != null) {
            hyphenated = hyphenatedAttribute.getValue();
        }

        Boolean toHyphenate = false;
        if (hyphenated == null) {
            toHyphenate = false;
        } else if (hyphenated.equals("hyphenated")) {
            toHyphenate = true;
        } else {
            throw new LdoDLoadException("valor inesperado para atribute hyphenated=" + hyphenated);

            // assert false : "UNEXPECTED PARAMETER FOR hyphenated ATTRIBUTE"
            // + hyphenated;
        }
        return toHyphenate;
    }

    private Boolean isBreak(Element element) {
        String breakWord = "yes";
        Attribute breakAttribute = element.getAttribute("break");
        if (breakAttribute != null) {
            breakWord = breakAttribute.getValue();
        }

        Boolean toBreak = false;
        if (breakWord == null || breakWord.equals("yes")) {
            toBreak = true;
        } else if (breakWord.equals("no")) {
            toBreak = false;
        } else {
            throw new LdoDLoadException("valor inesperado para atribute break=" + breakWord);
            // assert false : "INVALID PARAMETER FOR break ATTRIBUTE" +
            // breakWord;
        }
        return toBreak;
    }

    private int getQuantityAttribute(Element element) {
        int quantity = 0;
        Attribute quantityAttribute = element.getAttribute("quantity");
        if (quantityAttribute == null) {
            quantity = 0;
        } else {
            try {
                quantity = Integer.parseInt(quantityAttribute.getValue());
            } catch (NumberFormatException e) {
                throw new LdoDLoadException("valor para atributo quantity não é um número="
                        + quantityAttribute.getValue() + " _APLICADO AO VALOR_ " + element.getText());
                // assert false :
                // "VALUE FOR ATTRIBUTE quantity IS NOT INTEGER=\""
                // + quantityAttribute.getValue() + "\"";
            }
        }
        return quantity;
    }

    private SpaceText.SpaceUnit getUnitAttribute(Element element) {
        SpaceText.SpaceUnit unit = SpaceUnit.UNKNOWN;
        Attribute unitAttribute = element.getAttribute("unit");
        if (unitAttribute == null) {
            unit = SpaceUnit.UNKNOWN;
        } else if (unitAttribute.getValue().equals("minims")) {
            unit = SpaceUnit.MINIMS;
        } else {
            throw new LdoDLoadException("valor desconhecido para atributo unit=" + unitAttribute.getValue()
                    + " _APLICADO AO VALOR_ " + element.getText());
            // assert false : "UNKNOWN VALUE FOR ATTRIBUTE unit=\""
            // + unitAttribute.getValue() + "\"";
        }

        return unit;
    }

    private SpaceText.SpaceDim getDimAttribute(Element element) {
        SpaceText.SpaceDim dim = null;

        Attribute dimAttribute = element.getAttribute("dim");
        if (dimAttribute == null) {
            dim = SpaceDim.UNKNOWN;
        } else if (dimAttribute.getValue().equals("vertical")) {
            dim = SpaceDim.VERTICAL;
        } else if (dimAttribute.getValue().equals("horizontal")) {
            dim = SpaceDim.HORIZONTAL;
        } else {
            throw new LdoDLoadException("valor desconhecido para atributo dim=" + dimAttribute.getValue()
                    + " _APLICADO AO VALOR_ " + element.getText());

            // assert false : "UNKNOWN VALUE FOR ATTRIBUTE dim=\""
            // + dimAttribute.getValue() + "\"";
        }
        return dim;
    }

    private void setRenditions(Element element, TextPortion text) {
        String[] listRendXmlId = null;

        Attribute rendAttribute = element.getAttribute("rendition");

        if (rendAttribute != null) {
            listRendXmlId = element.getAttribute("rendition").getValue().split("\\s+");

            for (int i = listRendXmlId.length - 1; i >= 0; i--) {
                String rendXmlId = listRendXmlId[i].substring(1);

                if (rendXmlId.equals("right")) {
                    text.addRend(new Rend(Rend.Rendition.RIGHT));
                } else if (rendXmlId.equals("left")) {
                    text.addRend(new Rend(Rend.Rendition.LEFT));
                } else if (rendXmlId.equals("center")) {
                    text.addRend(new Rend(Rend.Rendition.CENTER));
                } else if (rendXmlId.equals("bold")) {
                    text.addRend(new Rend(Rend.Rendition.BOLD));
                } else if (rendXmlId.equals("i")) {
                    text.addRend(new Rend(Rend.Rendition.ITALIC));
                } else if (rendXmlId.equals("red")) {
                    text.addRend(new Rend(Rend.Rendition.RED));
                } else if (rendXmlId.equals("green")) {
                    text.addRend(new Rend(Rend.Rendition.GREEN));
                } else if (rendXmlId.equals("u")) {
                    text.addRend(new Rend(Rend.Rendition.UNDERLINED));
                } else if (rendXmlId.equals("super")) {
                    text.addRend(new Rend(Rend.Rendition.SUPERSCRIPT));
                } else if (rendXmlId.equals("sub")) {
                    text.addRend(new Rend(Rend.Rendition.SUBSCRIPT));
                } else {
                    throw new LdoDLoadException("valor desconhecido para rend=" + listRendXmlId[i]
                            + " _APLICADO AO VALOR_ " + element.getText());
                    // assert false : "UNKNOWN rend VALUE" + listRendXmlId[i];
                }
            }
        }
    }

    private Place getPlaceAttribute(Attribute placeAttribute) {
        Place place = Place.UNSPECIFIED;
        if (placeAttribute != null) {
            String placeValue = placeAttribute.getValue();

            if (placeValue.equals("above")) {
                place = Place.ABOVE;
            } else if (placeValue.equals("below")) {
                place = Place.BELOW;
            } else if (placeValue.equals("superimposed")) {
                place = Place.SUPERIMPOSED;
            } else if (placeValue.equals("margin")) {
                place = Place.MARGIN;
            } else if (placeValue.equals("top")) {
                place = Place.TOP;
            } else if (placeValue.equals("bottom")) {
                place = Place.BOTTOM;
            } else if (placeValue.equals("inline")) {
                place = Place.INLINE;
            } else if (placeValue.equals("inspace")) {
                place = Place.INSPACE;
            } else if (placeValue.equals("overleaf")) {
                place = Place.OVERLEAF;
            } else if (placeValue.equals("opposite")) {
                place = Place.OPPOSITE;
            } else if (placeValue.equals("end")) {
                place = Place.END;
            } else {
                throw new LdoDLoadException("valor desconhecido para atributo place=" + placeValue
                        + " _APLICADO AO VALOR_ " + placeAttribute.getParent().getText());
            }
        }
        return place;
    }

    private DelText.HowDel getHowDelAttribute(Attribute howDelAttribute) {
        DelText.HowDel howDel = DelText.HowDel.UNSPECIFIED;
        if (howDelAttribute != null) {
            String howDelValue = howDelAttribute.getValue();

            if (howDelValue.equals("overtyped")) {
                howDel = DelText.HowDel.OVERTYPED;
            } else if (howDelValue.equals("overstrike")) {
                howDel = DelText.HowDel.OVERSTRIKE;
            } else if (howDelValue.equals("overwritten")) {
                howDel = DelText.HowDel.OVERWRITTEN;
            } else {
                throw new LdoDLoadException("valor desconhecido para atributo rend=" + howDelValue + " dentro de del"
                        + " _APLICADO AO VALOR_ " + howDelAttribute.getParent().getText());
            }
        }
        return howDel;
    }

    private TextPortion.VariationType getVariationType(Element appElement) {
        TextPortion.VariationType type = TextPortion.VariationType.UNSPECIFIED;

        Attribute typeAttribute = appElement.getAttribute("type");

        if (typeAttribute != null) {
            String typeValue = typeAttribute.getValue();

            switch (typeValue) {
                case "ortographic":
                    // due to a error in the encoding both forms are allowed
                case "orthographic":
                    type = TextPortion.VariationType.ORTHOGRAPHIC;
                    break;
                case "substantive":
                    type = TextPortion.VariationType.SUBSTANTIVE;
                    break;
                case "style":
                    type = TextPortion.VariationType.STYLE;
                    break;
                case "paragraph":
                    type = TextPortion.VariationType.PARAGRAPH;
                    break;
                case "punctuation":
                    type = TextPortion.VariationType.PUNCTUATION;
                    break;
                default:
                    throw new LdoDLoadException("valor desconhecido para atributo type=" + typeValue + " dentro de app");
            }
        }

        return type;
    }

    private GapReason getGapReasonAttribute(Element element) {
        GapReason reason = GapReason.NONSPECIFIED;

        Attribute reasonAttribute = element.getAttribute("reason");

        if (reasonAttribute != null) {
            String reasonValue = reasonAttribute.getValue();

            switch (reasonValue) {
                case "irrelevant":
                    reason = GapReason.IRRELEVANT;
                    break;
                case "illegible":
                    reason = GapReason.ILLEGIABLE;
                    break;
                default:
                    throw new LdoDLoadException(
                            "valor desconhecido para atributo reason=" + reasonValue + " dentro de gap");
            }
        }
        return reason;
    }

    private int getExtentAttribute(Element element) {
        int extent = 0;

        Attribute extentAttribute = element.getAttribute("extent");

        if (extentAttribute != null) {
            try {
                extent = Integer.parseInt(extentAttribute.getValue());
            } catch (NumberFormatException e) {
                throw new LdoDLoadException("valor para atributo extent de um element gap não é um número="
                        + extentAttribute.getValue() + " _APLICADO AO VALOR_ " + element.getParent().getContent());
            }
        }
        return extent;
    }

    private GapUnit getGapUnitAttribute(Element element) {
        GapUnit unit = GapUnit.NONSPECIFIED;

        Attribute unitAttribute = element.getAttribute("unit");

        if (unitAttribute != null) {
            String unitValue = unitAttribute.getValue();

            switch (unitValue) {
                case "word":
                    unit = GapUnit.WORD;
                    break;
                case "char":
                    unit = GapUnit.CHAR;
                    break;
                default:
                    throw new LdoDLoadException("valor desconhecido para atributo unit=" + unitValue + " dentro de gap");
            }
        }
        return unit;
    }

    private UnclearText.UnclearReason getUnclearReasonAttribute(Element element) {
        UnclearText.UnclearReason reason = UnclearText.UnclearReason.NONSPECIFIED;

        Attribute reasonAttribute = element.getAttribute("reason");

        if (reasonAttribute != null) {
            String reasonValue = reasonAttribute.getValue();

            switch (reasonValue) {
                case "irrelevant":
                    reason = UnclearText.UnclearReason.IRRELEVANT;
                    break;
                case "illegible":
                    reason = UnclearText.UnclearReason.ILLEGIABLE;
                    break;
                case "background noise":
                    reason = UnclearText.UnclearReason.BACKGROUND_NOISE;
                    break;
                case "eccentric ductus":
                    reason = UnclearText.UnclearReason.ECCENTRIC_DUCTUS;
                    break;
                case "ink blot":
                    reason = UnclearText.UnclearReason.INK_BLOT;
                    break;
                case "faded":
                    reason = UnclearText.UnclearReason.FADED;
                    break;
                default:
                    throw new LdoDLoadException(
                            "valor desconhecido para atributo reason=" + reasonValue + " dentro de unclear");
            }
        }
        return reason;
    }

    private AltMode getAltMode(Element element) {
        AltMode altMode = AltMode.NONSPECIFIED;

        Attribute modeAttribute = element.getAttribute("mode");
        if (modeAttribute == null) {
            throw new LdoDLoadException("O elemento alt deve ter attributo mode");
        }

        String modeValue = modeAttribute.getValue();
        switch (modeValue) {
            case "excl":
                altMode = AltMode.EXCL;
                break;
            case "incl":
                altMode = AltMode.INCL;
                break;
            default:
                throw new LdoDLoadException("O atributo mode do elemento alt tem valor=" + modeValue);
        }
        return altMode;
    }

    private String[] getTarget(Element element) {
        Attribute targetAttribute = element.getAttribute("target");
        if (targetAttribute == null) {
            throw new LdoDLoadException("O elemento alt deve ter attributo target");
        }
        String targetValue = targetAttribute.getValue().trim();
        String[] targetList = targetValue.split("\\s+");

        if (targetList.length < 2) {
            throw new LdoDLoadException(
                    "O atributo target do elemento alt deve ter pelo menos dois valores. Valor=" + targetValue);
        }
        return targetList;
    }

    private String[] getAltWeights(Element element) {
        Attribute weightsAttribute = element.getAttribute("weights");
        if (weightsAttribute == null) {
            throw new LdoDLoadException("O elemento alt deve ter attributo weights");
        }
        String weightsValue = weightsAttribute.getValue();
        String[] weightsList = weightsValue.split("\\s+");
        if (weightsList.length < 2) {
            throw new LdoDLoadException(
                    "O atributo weights do elemento alt deve ter pelo menos dois valores. Valor=" + weightsValue);
        }

        double total = 0;
        for (String weight : weightsList) {
            total = total + Double.parseDouble(weight);
        }

        if (total != 1) {
            throw new LdoDLoadException(
                    "No atributo weights do elemento alt a soma dos valores deve ser igual a 1. Valor=" + weightsValue);
        }

        return weightsList;
    }

    private String getFragmentTitle(Element element) {
        String title = element.getChild("fileDesc", this.namespace).getChild("titleStmt", this.namespace)
                .getChildText("title", this.namespace);
        return title;
    }

    private String getFragmentXmlId(Element element) {
        String xmlId = element.getParentElement().getAttributeValue("id", element.getNamespace("xml"));

        if (xmlId == null) {
            throw new LdoDLoadException(
                    "falta xml:id de um fragmento" + " VALOR=" + element.getChild("fileDesc", this.namespace)
                            .getChild("titleStmt", this.namespace).getChildText("title", this.namespace));
        }

        assert xmlId != null : "MISSING xml:id ATTRIBUTE IN FRAGMENT <TEI > ELEMENT";

        if (getObjectDirectIdMap(xmlId) != null) {
            throw new LdoDLoadException("xml:id:" + xmlId + " já está declarado");
        }
        return xmlId;
    }
}


import cc.mallet.pipe.Pipe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class TopicModeler {

    private static final Logger logger = LoggerFactory.getLogger(TopicModeler.class);

    private Pipe pipe;
    private final String corpusPath = PropertiesManager.getProperties().getProperty("corpus.dir");
    private final String corpusFilesPath = PropertiesManager.getProperties().getProperty("corpus.files.dir");
    private final String stopListPath = PropertiesManager.getProperties().getProperty("corpus.stoplist");

    public TopicModeler() {}

    public void deleteFile(String externalId) {
        if (Files.exists(Paths.get(this.corpusFilesPath + externalId + ".txt"))) {
            try {
                Files.delete(Paths.get(this.corpusFilesPath + externalId + ".txt"));
            } catch (IOException e) {
                throw new LdoDException(
                        "TopicModeler.deleteFile cannot delete file " + this.corpusFilesPath + externalId + ".txt");
            }
        }
    }

}


import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.StringField;
import org.apache.lucene.index.*;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.queryparser.classic.QueryParserBase;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.NIOFSDirectory;
import org.apache.lucene.util.BytesRef;
import org.apache.tomcat.util.http.fileupload.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.text.api.dto.ScholarInterDto;
import pt.ist.socialsoftware.edition.text.domain.Fragment;
import pt.ist.socialsoftware.edition.text.domain.ScholarInter;
import pt.ist.socialsoftware.edition.text.domain.SourceInter;
import pt.ist.socialsoftware.edition.text.domain.TextModule;
import pt.ist.socialsoftware.edition.text.feature.generators.PlainTextFragmentWriter;


import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class Indexer {
    private static final Logger logger = LoggerFactory.getLogger(Indexer.class);

    private static Indexer indexer = null;

    public static Indexer getIndexer() {
        // if (indexer == null) {
        indexer = new Indexer();
        // }
        return indexer;
    }

    private static final String ID = "id";
    private static final String TEXT = "text";
    private static final String REP = "rep";
    private static final Map<String, Map<String, Double>> termsTFIDFCache = new ConcurrentHashMap<>();
    private final Analyzer analyzer;
    private final QueryParserBase queryParser;
    private static final int SIGNIFICATIVE_TERMS = 1000;
    private final Path docDir;
    private final IndexWriterConfig indexWriterConfig;

    private Indexer() {
        String path = PropertiesManager.getProperties().getProperty("indexer.dir");
        this.docDir = Paths.get(path);
        this.analyzer = new IgnoreDiacriticsAnalyzer();
        this.queryParser = new QueryParser(TEXT, this.analyzer);
        this.indexWriterConfig = new IndexWriterConfig(this.analyzer);
    }

    public void addDocument(ScholarInter inter) throws IOException {
        // IndexWriterConfig config = new IndexWriterConfig(Version.LATEST,
        // analyzer);
        Directory directory = new NIOFSDirectory(this.docDir);
        IndexWriter indexWriter = new IndexWriter(directory, this.indexWriterConfig);
        PlainTextFragmentWriter writer = new PlainTextFragmentWriter(inter);
        writer.write();
        String id = inter.getExternalId();
        String text = writer.getTranscription();
        Document doc = new Document();
        FieldType type = new FieldType();
        type.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
        type.setStored(true);
        type.setStoreTermVectors(true);
        doc.add(new Field(TEXT, text, type));
        doc.add(new StringField(ID, id, Field.Store.YES));
        if (inter.getFragment().getRepresentativeSourceInter() == inter) {
            doc.add(new StringField(REP, "true", Field.Store.YES));
        } else {
            doc.add(new StringField(REP, "false", Field.Store.YES));
        }
        indexWriter.addDocument(doc);
        indexWriter.commit();
        indexWriter.close();
        directory.close();
    }

    public void addDocument(ScholarInterDto interDto) throws IOException {
        // IndexWriterConfig config = new IndexWriterConfig(Version.LATEST,
        // analyzer);
        ScholarInter inter = TextModule.getInstance().getScholarInterByXmlId(interDto.getXmlId());
        Directory directory = new NIOFSDirectory(this.docDir);
        IndexWriter indexWriter = new IndexWriter(directory, this.indexWriterConfig);
        PlainTextFragmentWriter writer = new PlainTextFragmentWriter(inter);
        writer.write();
        String id = inter.getExternalId();
        String text = writer.getTranscription();
        Document doc = new Document();
        FieldType type = new FieldType();
        type.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
        type.setStored(true);
        type.setStoreTermVectors(true);
        doc.add(new Field(TEXT, text, type));
        doc.add(new StringField(ID, id, Field.Store.YES));
        if (inter.getFragment().getRepresentativeSourceInter() == inter) {
            doc.add(new StringField(REP, "true", Field.Store.YES));
        } else {
            doc.add(new StringField(REP, "false", Field.Store.YES));
        }
        indexWriter.addDocument(doc);
        indexWriter.commit();
        indexWriter.close();
        directory.close();
    }

    public List<ScholarInter> search(String words) {
        String query = absoluteSearch(words);

        List<String> hits;
        try {
            hits = getResults(query);
            logger.debug("search hits for:{} size:{}", words, hits.size());
        } catch (ParseException | IOException e) {
            throw new LdoDException("Error associated with textual search on Lucene");
        }

        return getFragIntersAndCleanMissingHits(hits);
    }


    public List<String> search(String words, ScholarInter inter) throws IOException, ParseException {
        String query = absoluteSearch(words);
        query = ID + ":" + inter.getExternalId() + " AND " + query;
        return getResults(query);
    }

    private List<ScholarInter> getFragIntersAndCleanMissingHits(List<String> hits) {
        List<ScholarInter> result = new ArrayList<>();
        List<String> misses = new ArrayList<>();
        for (String hit : hits) {
            try {
                DomainObject object = FenixFramework.getDomainObject(hit);
                if (!FenixFramework.isDomainObjectValid(object)) {
                    misses.add(hit);
                } else if (!(object instanceof ScholarInter)) {
                    misses.add(hit);
                } else {
                    ScholarInter inter = (ScholarInter) object;
                    result.add(inter);
                }
            } catch (InstantiationError e) {
                misses.add(hit);
            }
        }

        if (!misses.isEmpty()) {
            Indexer indexer = Indexer.getIndexer();
            indexer.cleanMissingHits(misses);
        }

        return result;
    }

    private List<String> getResults(String queryString) throws IOException, ParseException {
        Query query = this.queryParser.parse(queryString);
        Directory directory = new NIOFSDirectory(this.docDir);
        IndexReader reader = DirectoryReader.open(directory);
        IndexSearcher searcher = new IndexSearcher(reader);
        int hitsPerPage = reader.numDocs();
        TopDocs results = searcher.search(query, hitsPerPage);
        ScoreDoc[] hits = results.scoreDocs;
        List<String> hitList = new ArrayList<>();
        for (int i = 0; i < hits.length; ++i) {
            int docId = hits[i].doc;
            Document d = searcher.doc(docId);
            String id = d.get(ID);
            if (!hitList.contains(id)) {
                hitList.add(id);
            }
        }
        reader.close();
        directory.close();
        return hitList;
    }

    // SearchProcessor for fragments with a set of words similar to input
    // Fuzzy set for a minimum edition edition of 1
    private String fuzzySearch(String words) {
        String[] split = words.split("\\s+");
        int fuzzy = 1;
        String query = "" + split[0] + "~" + fuzzy;
        int len = split.length;

        for (int i = 1; i < len; i++) {
            query += " AND " + split[i] + "~" + fuzzy;
        }
        return query;
    }

    // SearchProcessor for fragments with a set of equal to inputs
    private String absoluteSearch(String words) {
        String[] split = words.split("\\s+");
        String query = "" + split[0];
        int len = split.length;

        for (int i = 1; i < len; i++) {
            query += " AND " + split[i];
        }
        return query;
    }

    public List<String> getTFIDFTerms(Fragment fragment, int numberOfTerms) throws IOException, ParseException {
        List<Entry<String, Double>> set = new ArrayList<>(getTFIDF(fragment).entrySet());
        return getTFIDFTerms(set, numberOfTerms);
    }

    public Map<String, Double> getTFIDF(Fragment fragment, List<String> terms) throws IOException, ParseException {
        Map<String, Double> TFIDFMap = new HashMap<>(getTFIDF(fragment));
        TFIDFMap.keySet().retainAll(terms);
        return TFIDFMap;
    }

    public void cleanMissingHits(List<String> misses) {
        if (misses.isEmpty()) {
            return;
        }

        String query = misses.get(0);
        for (int i = 1; i < misses.size(); i++) {
            query += " OR " + misses.get(i);
        }

        QueryParser idQueryParser = new QueryParser(ID, this.analyzer);
        try {
            Query q = idQueryParser.parse(query);
            Directory directory = new NIOFSDirectory(this.docDir);
            IndexWriter indexWriter = new IndexWriter(directory, this.indexWriterConfig);
            indexWriter.deleteDocuments(q);

            indexWriter.close();
            directory.close();
        } catch (ParseException | IOException e) {
        }
    }

    public void cleanLucene() {
        String path = PropertiesManager.getProperties().getProperty("indexer.dir");
        try {
            logger.debug("cleanLucene {}", path);
            FileUtils.cleanDirectory(new File(path));
        } catch (IOException e) {
            throw new LdoDException("cleanLucene in class Indexer failed when invoking cleanDirectory");
        }
    }

    public Map<String, Double> getTFIDF(Fragment fragment) throws IOException, ParseException {

        String id = fragment.getExternalId();
        if (termsTFIDFCache.containsKey(id)) {
            return termsTFIDFCache.get(id);
        }
        Map<String, Double> tf = getTermFrequency(fragment);
        Map<String, Double> TFIDFMap = getTFIDF(tf);
        termsTFIDFCache.put(id, TFIDFMap);
        return TFIDFMap;
    }

    private Map<String, Double> getTermFrequency(Fragment fragment) throws IOException, ParseException {
        SourceInter sourceInter = fragment.getRepresentativeSourceInter();
        String queryString = ID + ":" + sourceInter.getExternalId();
        Query query = this.queryParser.parse(queryString);
        return getTermCount(query);
    }

    public Map<String, Double> getTermFrequency(ScholarInter inter) throws IOException, ParseException {
        String queryString = ID + ":" + inter.getExternalId();
        Query query = this.queryParser.parse(queryString);
        return getTermCount(query);
    }

    private Map<String, Double> getTermCount(Query query) throws ParseException, IOException {
        Directory directory = new NIOFSDirectory(this.docDir);
        IndexReader reader = DirectoryReader.open(directory);
        IndexSearcher searcher = new IndexSearcher(reader);
        int hitsPerPage = reader.numDocs();
        TopDocs results = searcher.search(query, hitsPerPage);
        ScoreDoc[] hits = results.scoreDocs;
        int len = hits.length;
        Map<String, Double> TFMap = new ConcurrentHashMap<>();
        for (int i = 0; i < len; ++i) {
            int docId = hits[i].doc;
            Terms terms = reader.getTermVector(docId, TEXT);
            if (terms == null) {
                return TFMap;
            }
            TermsEnum termsEnum = terms.iterator();
            BytesRef text = null;
            int totalFrequency = 0;
            while ((text = termsEnum.next()) != null) {
                String term = text.utf8ToString();
                double tf = termsEnum.totalTermFreq();
                TFMap.put(term, tf);
                totalFrequency += tf;
            }
            for (String key : TFMap.keySet()) {
                TFMap.put(key, TFMap.get(key) / totalFrequency);
            }
        }
        reader.close();
        directory.close();
        return TFMap;
    }

    private Map<String, Double> getTFIDF(Map<String, Double> tf) throws IOException, ParseException {
        Directory directory = new NIOFSDirectory(this.docDir);
        IndexReader reader = DirectoryReader.open(directory);

        Query query = this.queryParser.parse(REP + ":true");
        IndexSearcher searcher = new IndexSearcher(reader);
        TopDocs results = searcher.search(query, reader.numDocs());
        long numDocs = results.totalHits;

        Map<String, Double> TFIDFMap = new ConcurrentHashMap<>();
        for (Entry<String, Double> entry : tf.entrySet()) {
            query = this.queryParser.parse(REP + ":true" + " AND " + entry.getKey());
            searcher = new IndexSearcher(reader);
            results = searcher.search(query, (int) numDocs);
            long df = results.totalHits;
            double tfidf = entry.getValue() * calculateIDF(numDocs, 1 + df);
            TFIDFMap.put(entry.getKey(), tfidf);
        }

        reader.close();
        directory.close();
        List<Entry<String, Double>> list = TFIDFMap.entrySet().stream()
                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).collect(Collectors.toList());
        TFIDFMap = new HashMap<>();
        int size = list.size();
        for (int i = 0; i < size && i < SIGNIFICATIVE_TERMS; i++) {
            TFIDFMap.put(list.get(i).getKey(), list.get(i).getValue());
        }
        return TFIDFMap;
    }

    private double calculateIDF(long numDocs, long df) {
        return Math.log(numDocs / (double) df);
    }

    private List<String> getTFIDFTerms(List<Entry<String, Double>> list, int numberOfTerms) {
        Collections.sort(list, new Comparator<Map.Entry<String, Double>>() {
            @Override
            public int compare(Map.Entry<String, Double> o1, Map.Entry<String, Double> o2) {
                return o2.getValue().compareTo(o1.getValue());
            }
        });
        List<String> terms = new ArrayList<>();
        int size = list.size();
        for (int i = 0; i < size && i < numberOfTerms; i++) {
            terms.add(list.get(i).getKey());
        }
        return terms;
    }

    public static void clearTermsTFIDFCache() {
        termsTFIDFCache.clear();
    }

}

import org.apache.lucene.analysis.*;
import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;
import org.apache.lucene.analysis.pt.PortugueseAnalyzer;
import org.apache.lucene.analysis.standard.StandardTokenizer;

public class IgnoreDiacriticsAnalyzer extends Analyzer {

    private final CharArraySet stopWords;

    public IgnoreDiacriticsAnalyzer() {
        this.stopWords = PortugueseAnalyzer.getDefaultStopSet();
    }

    @Override
    protected TokenStreamComponents createComponents(String fieldName) {
        Tokenizer source = new StandardTokenizer();
        TokenStream tokenStream = source;
        tokenStream = new LowerCaseFilter(tokenStream);
        tokenStream = new StopFilter(tokenStream, getStopwordSet());
        tokenStream = new ASCIIFoldingFilter(tokenStream);
        return new TokenStreamComponents(source, tokenStream);
    }

    private CharArraySet getStopwordSet() {
        return this.stopWords;
    }

}


import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.LdoDDateDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;


import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;
import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class SearchRequiresInterface {


    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    // Requires from Text Module


    public boolean isSourceInter(String xmlId) {
        return !webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/isExpert")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //    return !this.textProvidesInterface.isExpertInter(xmlId);
    }

    public SourceDto getSourceOfSourceInter(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/source")
                .retrieve()
                .bodyToMono(SourceDto.class)
                .block();
        //  return this.textProvidesInterface.getSourceOfSourceInter(xmlId);
    }

    public String getSourceInterType(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/sourceInterType")
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //  return this.textProvidesInterface.getSourceInterType(xmlId);
    }

    public LdoDDateDto getScholarInterDate(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/date")
                .retrieve()
                .bodyToMono(LdoDDateDto.class)
                .block();
        //    return this.textProvidesInterface.getScholarInterDate(xmlId);
    }

    public boolean isExpertInter(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/isExpert")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //   return this.textProvidesInterface.isExpertInter(xmlId);
    }

    public String getEditionAcronymOfInter(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId + "/editionAcronym")
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //    return this.textProvidesInterface.getEditionAcronymOfInter(xmlId);
    }

    public String getHeteronymXmlId(String xmlId) {
        return webClient.build()
                .get()
                .uri("/heteronym/xmlId/" + xmlId)
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //   return this.textProvidesInterface.getHeteronymXmlId(xmlId);
    }

    public List<ScholarInterDto> searchScholarInterForWords(String words) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/scholarInter/search")
                        .queryParam("words", words)
                        .build())
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
        //   return this.textProvidesInterface.searchScholarInterForWords(words);
    }

    public Set<FragmentDto> getFragmentDtoSet() {
        return webClient.build()
                .get()
                .uri("/fragments")
                .retrieve()
                .bodyToFlux(FragmentDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //   return this.textProvidesInterface.getFragmentDtoSet();
    }


    // Requires from Virtual Module
    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    public Set<VirtualEditionInterDto> getVirtualEditionInterSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInterSet")
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterSet();
    }

    public List<String> getVirtualEditionSortedCategoryList(String xmlId) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + xmlId + "/sortedCategory")
                .retrieve()
                .bodyToFlux(String.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionSortedCategoryList(xmlId);
    }

    public boolean isInterInVirtualEdition(String interXmlId, String virtualEditionAcronym) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/isInterInVirtualEdition")
                    .queryParam("xmlId", interXmlId)
                    .queryParam("acronym", virtualEditionAcronym)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.isInterInVirtualEdition(interXmlId, virtualEditionAcronym);
    }

    public String getVirtualEditionAcronymByVirtualEditionInterXmlId(String interXmlId) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionsInter/" + interXmlId + "/virtualEditionAcronym")
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionAcronymByVirtualEditionInterXmlId(interXmlId);
    }

    public Set<VirtualEditionDto> getPublicVirtualEditionsOrUserIsParticipant(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditions/getPublicVirtualEditionsOrUserIsParticipant")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToFlux(VirtualEditionDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getPublicVirtualEditionsOrUserIsParticipant(username);
    }

}


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.bind.annotation.*;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.search.api.dto.AdvancedSearchResultDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;
import pt.ist.socialsoftware.edition.search.api.dto.VirtualEditionSearchOptionDto;
import pt.ist.socialsoftware.edition.search.feature.SearchProcessor;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class SearchProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(SearchProvidesInterface.class);

    @GetMapping("/simpleSearch")
    public Map<String, List<ScholarInterDto>> simpleSearch(@RequestParam(name = "params") String params) {
        logger.debug("simpleSearch: " + params);
        return new SearchProcessor().simpleSearch(params);
    }

    @PostMapping("/advancedSearch")
    public AdvancedSearchResultDto advancedSearch(@RequestBody SearchDto search, @RequestParam(name = "username") String username) {
        logger.debug("advancedSearch: " + username);

        if (username != null) {
            Arrays.stream(search.getSearchOptions())
                .filter(searchOptionDto -> searchOptionDto instanceof VirtualEditionSearchOptionDto)
                .forEach(searchOptionDto -> ((VirtualEditionSearchOptionDto) searchOptionDto).setUsername(username));
        }

        return new SearchProcessor().advancedSearch(search);
    }

}


import java.util.List;
import java.util.Map;

public class AdvancedSearchResultDto {
    private final boolean showEdition;
    private final boolean showHeteronym;
    private final boolean showDate;
    private final boolean showLdoD;
    private final boolean showSource;
    private final boolean showSourceType;
    private final boolean showTaxonomy;
    private final int fragCount;
    private final int interCount;
    private final int fragCountNotAdded;
    private final int interCountNotAdded;
    private final Map<String, Map<SearchableElementDto, List<String>>> results;

    public AdvancedSearchResultDto(boolean showEdition, boolean showHeteronym, boolean showDate, boolean showLdoD,
                                   boolean showSource, boolean showSourceType, boolean showTaxonomy, int fragCount,
                                   int interCount, int fragCountNotAdded,
                                   int interCountNotAdded, Map<String, Map<SearchableElementDto, List<String>>> results) {
        this.showEdition = showEdition;
        this.showHeteronym = showHeteronym;
        this.showDate = showDate;
        this.showLdoD = showLdoD;
        this.showSource = showSource;
        this.showSourceType = showSourceType;
        this.showTaxonomy = showTaxonomy;
        this.fragCount = fragCount;
        this.interCount = interCount;
        this.fragCountNotAdded = fragCountNotAdded;
        this.interCountNotAdded = interCountNotAdded;
        this.results = results;
    }

    public boolean isShowEdition() {
        return this.showEdition;
    }

    public boolean isShowHeteronym() {
        return this.showHeteronym;
    }

    public boolean isShowDate() {
        return this.showDate;
    }

    public boolean isShowLdoD() {
        return this.showLdoD;
    }

    public boolean isShowSource() {
        return this.showSource;
    }

    public boolean isShowSourceType() {
        return this.showSourceType;
    }

    public boolean isShowTaxonomy() {
        return this.showTaxonomy;
    }

    public int getFragCount() {
        return this.fragCount;
    }

    public int getInterCount() {
        return this.interCount;
    }

    public int getFragCountNotAdded() {
        return this.fragCountNotAdded;
    }

    public int getInterCountNotAdded() {
        return this.interCountNotAdded;
    }

    public Map<String, Map<SearchableElementDto, List<String>>> getResults() {
        return this.results;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.ManuscriptSearchOption;

public final class ManuscriptSearchOptionDto extends AuthoralSearchOptionDto {
    public static final String MANUSCRIPTID = "manus";

    public ManuscriptSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                     @JsonProperty("date") DateSearchOptionDto date) {
        super(hasLdoD, date);
    }

    @Override
    public ManuscriptSearchOption createSearchOption() {
        return new ManuscriptSearchOption(this);
    }
}


import java.util.Map;

public class ExpertEditionForSearchDto {

    private String editor;
    private final String acronym;
    private Map<String, String> heteronyms;
    private String beginDate;
    private String endDate;

    public ExpertEditionForSearchDto(String acronym) {
        this.acronym = acronym;
    }

    public String getEditor() {
        return this.editor;
    }

    public void setEditor(String editor) {
        this.editor = editor;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getBeginDate() {
        return this.beginDate;
    }

    public void setBeginDate(int i) {
        this.beginDate = Integer.toString(i);
    }

    public String getEndDate() {
        return this.endDate;
    }

    public void setEndDate(int i) {
        this.endDate = Integer.toString(i);
    }

    public Map<String, String> getHeteronyms() {
        return this.heteronyms;
    }

    public void setHeteronyms(Map<String, String> heteronyms) {
        this.heteronyms = heteronyms;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.TypescriptSearchOption;

public final class TypescriptSearchOptionDto extends AuthoralSearchOptionDto {
    public static final String TYPESCRIPT = "datil";

    public TypescriptSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                     @JsonProperty("date") DateSearchOptionDto date) {
        super(hasLdoD, date);
    }

    @Override
    public TypescriptSearchOption createSearchOption() {
        return new TypescriptSearchOption(this);
    }

}

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import pt.ist.socialsoftware.edition.search.feature.SearchProcessor;

public class SearchableElementDto {
    public enum Type {
        SCHOLAR_INTER,
        VIRTUAL_INTER
    }

    private Type type;

    private String xmlId;

    private String title;

    private String fragmentXmlId;

    private String urlId;

    private String shortName;

    private String lastUsedId;

    public SearchableElementDto(Type type, String xmlId, String title, String fragmentXmlId, String urlId, String shortName, String lastUsedId) {
        this.type = type;
        this.xmlId = xmlId;
        this.title = title;
        this.fragmentXmlId = fragmentXmlId;
        this.urlId = urlId;
        this.shortName = shortName;
        this.lastUsedId = lastUsedId;
    }

    public SearchableElementDto() {}

    public Type getType() {
        return this.type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getFragmentXmlId() {
        return this.fragmentXmlId;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getLastUsedId() {
        return this.lastUsedId;
    }

    public void setLastUsedId(String lastUsedId) {
        this.lastUsedId = lastUsedId;
    }

    @Override
    public String toString() {
        ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter();
        String json = "";
        try {
            json = ow.writeValueAsString(this);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return json;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.TaxonomySearchOption;

public class TaxonomySearchOptionDto extends SearchOptionDto {
    private final String[] tags;

    public TaxonomySearchOptionDto(@JsonProperty("tags") String[] tags) {
        this.tags = tags;
    }


    @Override
    public TaxonomySearchOption createSearchOption() {
        return new TaxonomySearchOption(this);
    }

    public String[] getTags() {
        return this.tags;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.search.feature.options.TextSearchOption;

public final class TextSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(TextSearchOptionDto.class);

    private final String text;

    public TextSearchOptionDto(@JsonProperty("text") String text) {
        text = purgeSearchText(text);
        text = QueryParser.escape(text);
        this.text = text.equals("null") || text.equals("") ? null : text.trim();
    }

    public static String purgeSearchText(String text) {
        text = text.replaceAll("[^\\p{L}0-9\\-\\s]+", "");
        return text;
    }

    @Override
    public TextSearchOption createSearchOption() {
        return new TextSearchOption(this);
    }

    public String getText() {
        return this.text;
    }

}


import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import pt.ist.socialsoftware.edition.search.feature.options.SearchOption;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
@JsonSubTypes({@Type(value = EditionSearchOptionDto.class, name = SearchOptionDto.EDITION),
        @Type(value = ManuscriptSearchOptionDto.class, name = SearchOptionDto.MANUSCRIPT),
        @Type(value = TypescriptSearchOptionDto.class, name = SearchOptionDto.DACTILOSCRIPT),
        @Type(value = PublicationSearchOptionDto.class, name = SearchOptionDto.PUBLICATION),
        @Type(value = HeteronymSearchOptionDto.class, name = SearchOptionDto.HETERONYM),
        @Type(value = DateSearchOptionDto.class, name = SearchOptionDto.DATE),
        @Type(value = TaxonomySearchOptionDto.class, name = SearchOptionDto.TAXONOMY),
        @Type(value = TextSearchOptionDto.class, name = SearchOptionDto.TEXT),
        @Type(value = VirtualEditionSearchOptionDto.class, name = SearchOptionDto.VIRTUALEDITION)})
public abstract class SearchOptionDto {
    /* Json Properties */
    public static final String EDITION = "edition";
    public static final String MANUSCRIPT = "manuscript";
    public static final String DACTILOSCRIPT = "dactiloscript";
    public static final String PUBLICATION = "publication";
    public static final String HETERONYM = "heteronym";
    public static final String DATE = "date";
    public static final String TEXT = "text";
    public static final String TAXONOMY = "taxonomy";
    public static final String VIRTUALEDITION = "virtualedition";


    public abstract SearchOption createSearchOption();

}

import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.Search;
import pt.ist.socialsoftware.edition.search.feature.options.SearchOption;


public class SearchDto {
    private final SearchOption.Mode mode;
    private final SearchOptionDto[] searchOptions;

    public SearchDto(@JsonProperty(Search.MODE) String mode, @JsonProperty(Search.OPTIONS) SearchOptionDto[] searchOptions) {
        this.mode = mode.toLowerCase().equals(SearchOption.Mode.AND.getMode()) ? SearchOption.Mode.AND : SearchOption.Mode.OR;
        this.searchOptions = searchOptions;
    }

    public SearchOption.Mode getMode() {
        return this.mode;
    }

    public SearchOptionDto[] getSearchOptions() {
        return this.searchOptions;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.PublicationSearchOption;

public final class PublicationSearchOptionDto extends SearchOptionDto {

    private final DateSearchOptionDto dateSearchOption;

    public PublicationSearchOptionDto(@JsonProperty("date") DateSearchOptionDto date) {
        this.dateSearchOption = date;
    }

    @Override
    public PublicationSearchOption createSearchOption() {
        return new PublicationSearchOption(this);
    }

    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }
}

import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.search.feature.options.DateSearchOption;


public final class DateSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(DateSearchOptionDto.class);


    private final DateSearchOption.Dated dated;
    private int begin;
    private int end;

    public DateSearchOptionDto(@JsonProperty("option") String dated, @JsonProperty("begin") String begin,
                               @JsonProperty("end") String end) {
        logger.debug("DateSearchOption dated: {}, begin:{}, end:{}", dated, begin, end);

        if (DateSearchOption.Dated.DATED.getDated().equals(dated)) {
            this.dated = DateSearchOption.Dated.DATED;
            this.begin = begin == null ? 1911 : Integer.parseInt(begin);
            this.end = end == null ? 1935 : Integer.parseInt(end);
        } else if (DateSearchOption.Dated.UNDATED.getDated().equals(dated)) {
            this.dated = DateSearchOption.Dated.UNDATED;
        } else {
            this.dated = DateSearchOption.Dated.ALL;
        }

        logger.debug("DateSearchOption dated: {}, begin:{}, end:{}", this.dated, this.begin, this.end);

    }

    @Override
    public DateSearchOption createSearchOption() {
        return new DateSearchOption(this);
    }

    public DateSearchOption.Dated getDated() {
        return this.dated;
    }

    public int getBegin() {
        return this.begin;
    }

    public int getEnd() {
        return this.end;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.VirtualEditionSearchOption;

public final class VirtualEditionSearchOptionDto extends SearchOptionDto {

    private final String virtualEditionAcronym;
    private final boolean inclusion;
    private  String username;


    public VirtualEditionSearchOptionDto(@JsonProperty("inclusion") String inclusion,
                                         @JsonProperty("edition") String virtualEditionAcronym) {
        if (inclusion.equals("in")) {
            this.inclusion = true;
        } else {
            this.inclusion = false;
        }
        this.virtualEditionAcronym = virtualEditionAcronym;

    }

    @Override
    public VirtualEditionSearchOption createSearchOption() {
        return new VirtualEditionSearchOption(this);
    }

    public String getVirtualEditionAcronym() {
        return this.virtualEditionAcronym;
    }

    public boolean isInclusion() {
        return this.inclusion;
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) { this.username = username; }


}


public class DatesForSearchDto {
    private String beginDate;
    private String endDate;

    public String getBeginDate() {
        return this.beginDate;
    }

    public void setBeginDate(int i) {
        this.beginDate = Integer.toString(i);
    }

    public String getEndDate() {
        return this.endDate;
    }

    public void setEndDate(int i) {
        this.endDate = Integer.toString(i);
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

public abstract class AuthoralSearchOptionDto extends SearchOptionDto {

    private final String hasLdoD;
    private final DateSearchOptionDto dateSearchOption;

    public AuthoralSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                   @JsonProperty("date") DateSearchOptionDto date) {
        this.hasLdoD = hasLdoD;
        this.dateSearchOption = date;
    }

    public String getHasLdoD() {
        return this.hasLdoD;
    }

    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }

}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.search.feature.options.EditionSearchOption;

public final class EditionSearchOptionDto extends SearchOptionDto {

    private final boolean inclusion;
    private final String edition;
    private final HeteronymSearchOptionDto heteronymSearchOption;
    private final DateSearchOptionDto dateSearchOption;

    @JsonCreator
    public EditionSearchOptionDto(@JsonProperty("inclusion") boolean inclusion, @JsonProperty("edition") String edition,
                                  @JsonProperty("heteronym") HeteronymSearchOptionDto heteronym, @JsonProperty("date") DateSearchOptionDto date) {

        this.inclusion = inclusion;
        this.edition = edition;
        this.heteronymSearchOption = heteronym;
        this.dateSearchOption = date;
    }

    @Override
    public EditionSearchOption createSearchOption() {
        return new EditionSearchOption(this);
    }

    public boolean isInclusion() {
        return this.inclusion;
    }

    public String getEdition() {
        return this.edition;
    }

    public HeteronymSearchOptionDto getHeteronymSearchOption() {
        return this.heteronymSearchOption;
    }

    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.search.feature.options.HeteronymSearchOption;


public final class HeteronymSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(HeteronymSearchOptionDto.class);

    private final String xmlId4Heteronym;

    public HeteronymSearchOptionDto(@JsonProperty("xmlId4Heteronym") String xmlId) {
        logger.debug("HeteronymSearchOption xmlId: {}", xmlId);
        this.xmlId4Heteronym = xmlId.equals("null") ? null : xmlId;
    }

    @Override
    public HeteronymSearchOption createSearchOption() {
        return new HeteronymSearchOption(this);
    }

    public String getXmlId4Heteronym() {
        return this.xmlId4Heteronym;
    }
}



public class AuthoralForSearchDto {

    private String[] mediums;
    private DatesForSearchDto dates;

    public String[] getMediums() {
        return this.mediums;
    }

    public void setMediums(String[] mediums) {
        this.mediums = mediums;
    }

    public DatesForSearchDto getDates() {
        return this.dates;
    }

    public void setDates(DatesForSearchDto dates) {
        this.dates = dates;
    }
}



import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;

@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.search")
@SpringBootApplication
@Configuration
@EnableJms
public class SearchApplication extends SpringBootServletInitializer implements InitializingBean {


    public static void main(String[] args) {
        SpringApplication.run(SearchApplication.class, args);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

}


import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}



import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.search.api.dto.AdvancedSearchResultDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import pt.ist.socialsoftware.edition.search.feature.options.*;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class SearchProcessor {
    //private static final Logger logger = LoggerFactory.getLogger(SearchController.class);

    public Map<String, List<ScholarInterDto>> simpleSearch(String params) {
        String split;
        if (params.contains("&")) {
            split = "&";
        } else {
            split = "%26";
        }

        String search = params.substring(0, params.indexOf(split));
        params = params.substring(params.indexOf(split) + 1);
        String searchType = params.substring(0, params.indexOf(split));
        params = params.substring(params.indexOf(split) + 1);
        String searchSource = params;

        search = TextSearchOption.purgeSearchText(search);

        TextSearchOption textSearchOption = new TextSearchOption(search);
        List<ScholarInterDto> matches = textSearchOption.search();

        Map<String, List<ScholarInterDto>> results = new HashMap<>();
        for (ScholarInterDto inter : matches) {
            String fragmentXmlId = inter.getFragmentXmlId();
            if ((searchSource.compareTo("") == 0
                    || inter.getShortName().toLowerCase().contains(searchSource.toLowerCase()))
                    && (searchType.compareTo("") == 0
                    || inter.getTitle().toLowerCase().contains(search.toLowerCase()))) {

                if (!results.containsKey(fragmentXmlId)) {
                    results.put(fragmentXmlId, new ArrayList<>());
                }

                if (!results.get(fragmentXmlId).contains(inter)) {
                    results.get(fragmentXmlId).add(inter);
                }
            }
        }
        return results;
    }

    public AdvancedSearchResultDto advancedSearch(SearchDto searchDto) {
       // logger.debug("AdvancedSearchResultDto");

        Map<String, Map<SearchableElementDto, List<SearchOption>>> results = new Search(searchDto).search();

        int fragCount = 0;
        int fragCountNotAdded = 0;
        int interCount = 0;
        int interCountNotAdded = 0;
        boolean showSource = false;
        boolean showSourceType = false;
        boolean showEdition = false;
        boolean showHeteronym = false;
        boolean showDate = false;
        boolean showLdoD = false;
        boolean fragAdd = false;
        boolean showTaxonomy = false;

        for (Map.Entry<String, Map<SearchableElementDto, List<SearchOption>>> entry : results.entrySet()) {
            fragAdd = false;
            for (Map.Entry<SearchableElementDto, List<SearchOption>> entry2 : entry.getValue().entrySet()) {
                if (entry2.getValue().size() >= 1) {
                    interCount++;
                    fragAdd = true;
                } else {
                    interCountNotAdded++;
                }
                for (SearchOption option : entry2.getValue()) {
                    if (option instanceof EditionSearchOption) {
                        showSource = true;
                        EditionSearchOption op = (EditionSearchOption) option;
                        if (!op.getEdition().equals(SearchOption.ALL)) {
                            showEdition = true;
                        }
                        if (op.hasHeteronym()) {
                            showHeteronym = true;
                        }
                        if (op.hasDate()) {
                            showDate = true;
                        }
                    } else if (option instanceof AuthoralSearchOption) {
                        showSource = true;
                        showSourceType = true;
                        AuthoralSearchOption op = (AuthoralSearchOption) option;
                        if (op.hasLdoDMark()) {
                            showLdoD = true;
                        }
                        if (op.hasDate()) {
                            showDate = true;
                        }
                    } else if (option instanceof PublicationSearchOption) {
                        showSource = true;
                        PublicationSearchOption op = (PublicationSearchOption) option;
                        if (op.hasDate()) {
                            showDate = true;
                        }
                    } else if (option instanceof HeteronymSearchOption) {
                        showHeteronym = true;
                    } else if (option instanceof DateSearchOption) {
                        showDate = true;
                    } else if (option instanceof TaxonomySearchOption) {
                        showTaxonomy = true;
                    } else if (option instanceof VirtualEditionSearchOption) {
                        showSource = true;
                    }
                }
            }
            if (fragAdd) {
                fragCount++;
            } else {
                fragCountNotAdded++;
            }
        }

        Map<String, Map<SearchableElementDto, List<String>>> resultsDto = results.entrySet().stream()
                .collect(Collectors.toMap(Map.Entry::getKey, ev -> ev.getValue().entrySet().stream()
                        .collect(Collectors.toMap(Map.Entry::getKey, ev2 -> ev2.getValue().stream()
                                .map(SearchOption::getClass)
                                .map(Class::getSimpleName)
                                .map(s -> s + "Dto")
                                .collect(Collectors.toList())))));

        //logger.debug("AdvancedSearchResultDto {}", results.entrySet().size());

        return new AdvancedSearchResultDto(showEdition, showHeteronym, showDate, showLdoD, showSource, showSourceType,
                showTaxonomy, fragCount, interCount, fragCountNotAdded, interCountNotAdded, resultsDto);
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.dtos.text.LdoDDateDto;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.DateSearchOptionDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import java.util.stream.Stream;

public final class DateSearchOption extends SearchOption {
    private static final Logger logger = LoggerFactory.getLogger(DateSearchOption.class);

    public enum Dated {
        ALL("all"), DATED("dated"), UNDATED("undated");

        private final String dated;

        Dated(String dated) {
            this.dated = dated;
        }

        public String getDated() {
            return this.dated;
        }
    }

    private final Dated dated;
    private final int begin;
    private final int end;


    public DateSearchOption(DateSearchOptionDto dateSearchOptionDto) {
        this.dated = dateSearchOptionDto.getDated();
        this.begin = dateSearchOptionDto.getBegin();
        this.end = dateSearchOptionDto.getEnd();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(inter -> inter.getType() == SearchableElementDto.Type.SCHOLAR_INTER)
                .filter(i -> verifiesSearchOption(i));
    }

    public boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        if (this.dated != Dated.ALL) {
            return isInDate(searchRequiresInterface.getScholarInterDate(inter.getXmlId()));
        }
        return true;
    }

    public boolean isInDate(LdoDDateDto ldoDDate) {
        if (ldoDDate == null && this.dated.equals(Dated.UNDATED)) {
            return true;
        } else if ((ldoDDate == null && this.dated.equals(Dated.DATED))
                || (ldoDDate != null && this.dated.equals(Dated.UNDATED))) {
            return false;
        } else if (this.dated.equals(Dated.DATED)
                && (this.begin > ldoDDate.getDate().getYear() || this.end < ldoDDate.getDate().getYear())) {
            return false;
        } else {
            return true;
        }
    }

    public boolean hasDate() {
        return !this.dated.equals(Dated.ALL);
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.search.api.dto.TypescriptSearchOptionDto;

public final class TypescriptSearchOption extends AuthoralSearchOption {
    public static final String TYPESCRIPT = "datil";

    public TypescriptSearchOption(TypescriptSearchOptionDto typescriptSearchOptionDto) {
        super(typescriptSearchOptionDto.getHasLdoD(), typescriptSearchOptionDto.getDateSearchOption().createSearchOption());
    }

    @Override
    protected boolean isOfDocumentType(SourceDto source) {
        return source.hasTypeNoteSet();
    }

}

import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;
import pt.ist.socialsoftware.edition.search.api.dto.VirtualEditionSearchOptionDto;


import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class VirtualEditionSearchOption extends SearchOption {
    private final String virtualEditionAcronym;
    private final boolean inclusion;
    private final String username;

    public VirtualEditionSearchOption(VirtualEditionSearchOptionDto virtualEditionSearchOptionDto) {
        this.inclusion = virtualEditionSearchOptionDto.isInclusion();
        this.virtualEditionAcronym = virtualEditionSearchOptionDto.getVirtualEditionAcronym();
        this.username = virtualEditionSearchOptionDto.getUsername();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(searchableElement -> searchableElement.getType() == SearchableElementDto.Type.VIRTUAL_INTER)
                .filter(i -> verifiesSearchOption(i));
    }

    public boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        Set<String> virtualEditionsAcronyms = searchRequiresInterface.getPublicVirtualEditionsOrUserIsParticipant(this.username).stream()
                .map(VirtualEditionDto::getAcronym).collect(Collectors.toSet());


        if (this.inclusion) {
            if (this.virtualEditionAcronym.equals(ALL) && virtualEditionsAcronyms.stream().anyMatch(virtualEditionAcronym -> searchRequiresInterface.isInterInVirtualEdition(inter.getXmlId(), virtualEditionAcronym))) {
                return true;
            }
            if (searchRequiresInterface.getVirtualEditionAcronymByVirtualEditionInterXmlId(inter.getXmlId()).equals(this.virtualEditionAcronym)
                    && virtualEditionsAcronyms.stream().anyMatch(virtualEdition -> searchRequiresInterface.isInterInVirtualEdition(inter.getXmlId(), virtualEdition))) {
                return true;
            }
        } else {
            if (this.virtualEditionAcronym.equals(ALL)) {
                return false;
            }
            if (!searchRequiresInterface.getVirtualEditionAcronymByVirtualEditionInterXmlId(inter.getXmlId()).equals(this.virtualEditionAcronym)
                    && virtualEditionsAcronyms.stream().anyMatch(virtualEdition -> searchRequiresInterface.isInterInVirtualEdition(inter.getXmlId(), virtualEdition))) {
                return true;
            }
        }
        return false;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.search.api.dto.ManuscriptSearchOptionDto;

public final class ManuscriptSearchOption extends AuthoralSearchOption {
    public static final String MANUSCRIPTID = "manus";

    public ManuscriptSearchOption(@JsonProperty("hasLdoDMark") String hasLdoD,
                                  @JsonProperty("date") DateSearchOption date) {
        super(hasLdoD, date);
    }

    public ManuscriptSearchOption(ManuscriptSearchOptionDto manuscriptSearchOptionDto) {
        super(manuscriptSearchOptionDto.getHasLdoD(), manuscriptSearchOptionDto.getDateSearchOption().createSearchOption());
    }

    @Override
    protected boolean isOfDocumentType(SourceDto source) {
        return source.hasHandNoteSet();
    }

}


import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import java.util.stream.Stream;


public abstract class SearchOption {
    /* SearchProcessor options to include everything */
    public static final String ALL = "all";

    /* SearchProcessor modes */
    public enum Mode {
        AND("and"), OR("or");

        private final String mode;

        Mode(String mode) {
            this.mode = mode;
        }

        public String getMode() {
            return this.mode;
        }
    }

    public abstract Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters);

}

import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.EditionSearchOptionDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import java.util.stream.Stream;

public final class EditionSearchOption extends SearchOption {

    private final boolean inclusion;
    private final String edition;
    private final HeteronymSearchOption heteronymSearchOption;
    private final DateSearchOption dateSearchOption;

    public EditionSearchOption(EditionSearchOptionDto editionSearchOptionDto) {
        this.inclusion = editionSearchOptionDto.isInclusion();
        this.edition = editionSearchOptionDto.getEdition();
        this.heteronymSearchOption = editionSearchOptionDto.getHeteronymSearchOption() != null ?
                editionSearchOptionDto.getHeteronymSearchOption().createSearchOption() : null;
        this.dateSearchOption = editionSearchOptionDto.getDateSearchOption() != null ? editionSearchOptionDto.getDateSearchOption().createSearchOption() : null;
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(searchableElement -> searchableElement.getType() == SearchableElementDto.Type.SCHOLAR_INTER)
                .filter(i -> verifiesSearchOption(i));
    }

    private boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();
        if (searchRequiresInterface.isExpertInter(inter.getXmlId()) && this.inclusion) {
            if (this.edition.equals(ALL)) {
                return true;
            }
            if (!(this.edition.equals(searchRequiresInterface.getEditionAcronymOfInter(inter.getXmlId())))) {
                return false;
            }
            if (this.heteronymSearchOption != null && !this.heteronymSearchOption.verifiesSearchOption(inter)) {
                return false;
            }
            if (this.dateSearchOption != null && !this.dateSearchOption.verifiesSearchOption(inter)) {
                return false;
            }
        } else if ((this.edition.equals(searchRequiresInterface.getEditionAcronymOfInter(inter.getXmlId())) || this.edition.equals(ALL)) || (this.heteronymSearchOption != null
                && this.heteronymSearchOption.verifiesSearchOption(inter)) || (this.dateSearchOption != null && this.dateSearchOption.verifiesSearchOption(inter))) {
            return false;
        }

        return true;
    }

    public boolean hasDate() {
        return this.dateSearchOption == null ? false : this.dateSearchOption.hasDate();
    }

    public boolean hasHeteronym() {
        return this.heteronymSearchOption == null ? false : this.heteronymSearchOption.hasHeteronym();
    }

    public String getEdition() {
        return this.edition;
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.HeteronymSearchOptionDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import java.util.stream.Stream;

public final class HeteronymSearchOption extends SearchOption {
    private static final Logger logger = LoggerFactory.getLogger(HeteronymSearchOption.class);

    private final String xmlId4Heteronym;

    public HeteronymSearchOption(HeteronymSearchOptionDto heteronymSearchOptionDto) {
        this.xmlId4Heteronym = heteronymSearchOptionDto.getXmlId4Heteronym();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(i -> verifiesSearchOption(i));
    }

    public boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        if (ALL.equals(this.xmlId4Heteronym)) {
            // all are selected
            return true;
        } else if (this.xmlId4Heteronym == null && searchRequiresInterface.getHeteronymXmlId(inter.getXmlId()) == null) {
            // Searching for fragments with no authors and fragment has no
            // author
            return true;
        } else if ((this.xmlId4Heteronym != null && searchRequiresInterface.getHeteronymXmlId(inter.getXmlId()) == null)
                || (this.xmlId4Heteronym == null && searchRequiresInterface.getHeteronymXmlId(inter.getXmlId()) != null)) {
            // Searching for fragment with author and fragment has no author or
            // searching for fragment with no author and fragment has author and
            return false;
        } else {
            // the interpretation has the expected correct heteronym assignment
            return this.xmlId4Heteronym.equals(searchRequiresInterface.getHeteronymXmlId(inter.getXmlId()));
        }
    }

    public boolean hasHeteronym() {
        return this.xmlId4Heteronym != null && !this.xmlId4Heteronym.equals(ALL);
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.notification.enums.SourceType;
import pt.ist.socialsoftware.edition.search.api.dto.AuthoralSearchOptionDto;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;


import java.util.stream.Stream;

public abstract class AuthoralSearchOption extends SearchOption {

    private final String hasLdoD;
    private final DateSearchOption dateSearchOption;

    public AuthoralSearchOption(String hasLdoD,
                                DateSearchOption date) {
        this.hasLdoD = hasLdoD;
        this.dateSearchOption = date;
    }

    public AuthoralSearchOption(AuthoralSearchOptionDto authoralSearchOptionDto) {
        this.hasLdoD = authoralSearchOptionDto.getHasLdoD();
        this.dateSearchOption = authoralSearchOptionDto.getDateSearchOption().createSearchOption();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(searchableElement -> searchableElement.getType() == SearchableElementDto.Type.SCHOLAR_INTER)
                .filter(i -> verifiesSearchOption(i));
    }

    private boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        if (searchRequiresInterface.isSourceInter(inter.getXmlId()) && searchRequiresInterface.getSourceInterType(inter.getXmlId()).equals(SourceType.MANUSCRIPT.name())) {
            SourceDto source = searchRequiresInterface.getSourceOfSourceInter(inter.getXmlId());
            if (isOfDocumentType(source) && this.dateSearchOption.verifiesSearchOption(inter)) {
                if (this.hasLdoD.equals(ALL) || (this.hasLdoD.equals("true") && source.getHasLdoDLabel())) {
                    return true;
                } else if (this.hasLdoD.equals("false") && !source.getHasLdoDLabel()) {
                    return true;
                }
            }
        }
        return false;
    }

    protected abstract boolean isOfDocumentType(SourceDto source);

    public boolean hasDate() {
        return this.dateSearchOption == null ? false : this.dateSearchOption.hasDate();
    }

    public boolean hasLdoDMark() {
        return !this.hasLdoD.equals(ALL);
    }
}


import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchDto;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;
import pt.ist.socialsoftware.edition.search.feature.options.SearchOption.Mode;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Search {
    public static final String OPTIONS = "options";
    public static final String MODE = "mode";

    private final Mode mode;
    private final SearchOption[] searchOptions;

    public Search(SearchDto searchDto) {
        this.mode = searchDto.getMode();
        this.searchOptions = Arrays.stream(searchDto.getSearchOptions()).map(searchOptionDto -> searchOptionDto.createSearchOption()).toArray(SearchOption[]::new);
    }


    public Mode getMode() {
        return this.mode;
    }

    public SearchOption[] getSearchOptions() {
        return this.searchOptions;
    }

    public Map<String, Map<SearchableElementDto, List<SearchOption>>> search() {
        Set<SearchOption> options = Arrays.stream(getSearchOptions()).collect(Collectors.toSet());
        Map<String, Map<SearchableElementDto, List<SearchOption>>> resultSet = null;

        if (getMode().equals(Mode.OR)) {
            resultSet = searchOptionsORComposition(options);
        }

        if (getMode().equals(Mode.AND)) {
            resultSet = searchOptionsANDComposition(options);
        }

        return resultSet;
    }

    private Map<String, Map<SearchableElementDto, List<SearchOption>>> searchOptionsORComposition(Set<SearchOption> options) {
        Map<String, Map<SearchableElementDto, List<SearchOption>>> resultSet = new LinkedHashMap<>();

        List<SearchOption> searchOptions = orderTextSearchOptions(options);

        List<SearchableElementDto> searchableElementDtos = getSearchableElements();

        for (SearchOption searchOption : searchOptions) {
            for (SearchableElementDto inter : searchOption.search(searchableElementDtos.stream()).collect(Collectors.toList())) {
                addToMatchSet(resultSet, inter, searchOption);
            }
        }

        return resultSet;
    }

    private Map<String, Map<SearchableElementDto, List<SearchOption>>> searchOptionsANDComposition(Set<SearchOption> options) {
        Map<String, Map<SearchableElementDto, List<SearchOption>>> resultSet = new LinkedHashMap<>();

        List<SearchOption> searchOptions = orderTextSearchOptions(options);

        List<SearchableElementDto> searchableElementDtos = getSearchableElements();

        Stream<SearchableElementDto> selectedElements = searchableElementDtos.stream();
        for (SearchOption searchOption : searchOptions) {
            List<SearchableElementDto> inters = searchOption.search(selectedElements).collect(Collectors.toList());

            for (SearchableElementDto inter : inters) {
                addToMatchSet(resultSet, inter, searchOption);
            }

            Set<String> fragmentXmlIds = inters.stream().map(searchableElement -> searchableElement.getFragmentXmlId()).collect(Collectors.toSet());

            selectedElements = searchableElementDtos.stream().filter(searchableElement -> fragmentXmlIds.contains(searchableElement.getFragmentXmlId()));
        }

        purgeNonFullyAchievedEntries(resultSet, searchOptions);

        return resultSet;
    }

    private List<SearchableElementDto> getSearchableElements() {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        return Stream.concat(searchRequiresInterface.getFragmentDtoSet().stream()
                        .flatMap(f -> f.getScholarInterDtoSet().stream()).map(scholarInter ->
                                new SearchableElementDto(SearchableElementDto.Type.SCHOLAR_INTER, scholarInter.getXmlId(),
                                        scholarInter.getTitle(), scholarInter.getFragmentXmlId(), scholarInter.getUrlId(),
                                        scholarInter.getShortName(), scholarInter.getXmlId()))
                , searchRequiresInterface.getVirtualEditionInterSet().stream().map(virtualEditionInter ->
                        new SearchableElementDto(SearchableElementDto.Type.VIRTUAL_INTER, virtualEditionInter.getXmlId(),
                                virtualEditionInter.getTitle(), virtualEditionInter.getFragmentXmlId(), virtualEditionInter.getUrlId(),
                                virtualEditionInter.getShortName(), virtualEditionInter.getLastUsed().getXmlId()))
        ).collect(Collectors.toList());
    }

    private void purgeNonFullyAchievedEntries(Map<String, Map<SearchableElementDto, List<SearchOption>>> resultSet,
                                              List<SearchOption> searchOptions) {
        for (Map.Entry<String, Map<SearchableElementDto, List<SearchOption>>> resultEntry : resultSet.entrySet()) {
            Set<SearchOption> achievedOptions = new HashSet<>();
            for (Map.Entry<SearchableElementDto, List<SearchOption>> entry : resultEntry.getValue().entrySet()) {
                achievedOptions.addAll(entry.getValue());
            }
            if (achievedOptions.size() != searchOptions.size()) {
                resultEntry.getValue().clear();
            }
        }
    }

    private List<SearchOption> orderTextSearchOptions(Set<SearchOption> options) {
        List<SearchOption> textSearchOptions = options.stream().filter(TextSearchOption.class::isInstance)
                .collect(Collectors.toList());

        options.removeAll(textSearchOptions);

        List<SearchOption> taxonomySearchOptions = options.stream().filter(TaxonomySearchOption.class::isInstance)
                .collect(Collectors.toList());

        options.removeAll(taxonomySearchOptions);

        // text search options first
        List<SearchOption> result = new ArrayList<>(textSearchOptions);
        result.addAll(options);
        // taxonomy search options last
        result.addAll(taxonomySearchOptions);

        return result;
    }

    private void addToMatchSet(Map<String, Map<SearchableElementDto, List<SearchOption>>> matchSet, SearchableElementDto inter,
                               SearchOption searchOption) {
        // no entry to fragment
        if (matchSet.get(inter.getFragmentXmlId()) == null) {
            matchSet.put(inter.getFragmentXmlId(), new HashMap<>());
        }

        // no entry to fragInter
        if (matchSet.get(inter.getFragmentXmlId()).get(inter) == null) {
            matchSet.get(inter.getFragmentXmlId()).put(inter, new ArrayList<>());
        }

        // insert element
        matchSet.get(inter.getFragmentXmlId()).get(inter).add(searchOption);
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;
import pt.ist.socialsoftware.edition.search.api.dto.TextSearchOptionDto;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class TextSearchOption extends SearchOption {
    private static final Logger logger = LoggerFactory.getLogger(TextSearchOption.class);

    private final String text;

    public TextSearchOption(TextSearchOptionDto textSearchOptionDto) {
        this.text = textSearchOptionDto.getText();
    }

    public TextSearchOption(String search) {
        this.text = search;
    }

    public static String purgeSearchText(String text) {
        text = text.replaceAll("[^\\p{L}0-9\\-\\s]+", "");
        return text;
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        Set<ScholarInterDto> searchResult = new HashSet<>(search());
        Set<String> resultIds = searchResult.stream().map(scholarInterDto -> scholarInterDto.getXmlId()).collect(Collectors.toSet());
        return inters.filter(i -> resultIds.contains(i.getXmlId()));
    }

    public List<ScholarInterDto> search() {
        if (this.text != null) {
            SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();
            return searchRequiresInterface.searchScholarInterForWords(this.text);
        }

        return new ArrayList<>();
    }

}


import pt.ist.socialsoftware.edition.notification.enums.SourceType;
import pt.ist.socialsoftware.edition.search.api.dto.PublicationSearchOptionDto;
import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;

import java.util.stream.Stream;

public final class PublicationSearchOption extends SearchOption {
    private final DateSearchOption dateSearchOption;

    public PublicationSearchOption(PublicationSearchOptionDto publicationSearchOptionDto) {
        this.dateSearchOption = publicationSearchOptionDto.getDateSearchOption().createSearchOption();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(i -> verifiesSearchOption(i));
    }

    private boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        return inter.getType().equals(SearchableElementDto.Type.SCHOLAR_INTER) && searchRequiresInterface.isSourceInter(inter.getXmlId()) && searchRequiresInterface.getSourceInterType(inter.getXmlId()).equals(SourceType.PRINTED.name())
                && this.dateSearchOption.verifiesSearchOption(inter);
    }

    public boolean hasDate() {
        return this.dateSearchOption == null ? false : this.dateSearchOption.hasDate();
    }

}

import pt.ist.socialsoftware.edition.search.api.SearchRequiresInterface;
import pt.ist.socialsoftware.edition.search.api.dto.SearchableElementDto;
import pt.ist.socialsoftware.edition.search.api.dto.TaxonomySearchOptionDto;

import java.util.Arrays;
import java.util.stream.Stream;

public class TaxonomySearchOption extends SearchOption {
    private final String[] tags;

    public TaxonomySearchOption(TaxonomySearchOptionDto taxonomySearchOptionDto) {
        this.tags = taxonomySearchOptionDto.getTags();
    }

    @Override
    public Stream<SearchableElementDto> search(Stream<SearchableElementDto> inters) {
        return inters.filter(searchableElement -> searchableElement.getType() == SearchableElementDto.Type.VIRTUAL_INTER)
                .filter(i -> verifiesSearchOption(i));
    }

    public boolean verifiesSearchOption(SearchableElementDto inter) {
        SearchRequiresInterface searchRequiresInterface = new SearchRequiresInterface();

        return Arrays.stream(this.tags)
                .allMatch(tt -> searchRequiresInterface.getVirtualEditionSortedCategoryList(inter.getXmlId())
                        .stream().anyMatch(t -> t.equals(tt)));
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

import javax.servlet.*;
import java.io.IOException;

@Component
public class TransactionFilter implements Filter {
    private static final Logger logger = LoggerFactory.getLogger(TransactionFilter.class);

    @Override
//    @Atomic(mode = TxMode.READ)
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        chain.doFilter(request, response);
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }

}

import java.io.Serializable;

public class LdoDException extends RuntimeException implements Serializable {

    private static final long serialVersionUID = 1L;

    protected String message;

    public LdoDException() {
        this.message = "";
    }

    public LdoDException(String message) {
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }

}


public class LdoDLoadException extends LdoDException {

    private static final long serialVersionUID = -4087610484821921033L;

    public LdoDLoadException(String message) {
        this.message = message;
    }

}


import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.api.VisualRequiresInterface;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Set;
import java.util.stream.Collectors;

public class TestLoadUtils {
    private static final Logger logger = LoggerFactory.getLogger(TestLoadUtils.class);

    public static void loadCorpus() throws FileNotFoundException {
        VisualRequiresInterface visualRequiresInterface = new VisualRequiresInterface();
        if (visualRequiresInterface.getSortedHeteronyms().isEmpty()) {
            String testFilesDirectory = PropertiesManager.getProperties().getProperty("test.files.dir");
            File directory = new File(testFilesDirectory);
            final String filename = "corpus.xml";
            File file = new File(directory, filename);
            visualRequiresInterface.getLoaderTEICorpus(new FileInputStream(file));
            visualRequiresInterface.loadTEICorpusVirtual(new FileInputStream(file));

        }
    }


    public static void loadFragments(String[] fragmentsToLoad) throws LdoDLoadException, FileNotFoundException {

        String testFilesDirectory = PropertiesManager.getProperties().getProperty("test.files.dir");
        File directory = new File(testFilesDirectory);


        String[] fragmentFiles = fragmentsToLoad;

        VisualRequiresInterface visualRequiresInterface = new VisualRequiresInterface();

        File file;
        for (int i = 0; i < fragmentFiles.length; i++) {
            file = new File(directory, fragmentFiles[i]);
            visualRequiresInterface.getLoadTEIFragmentsAtOnce(new FileInputStream(file));
        }
        if (fragmentFiles.length > 0){  visualRequiresInterface.getFragmentCorpusGenerator(); }
    }


    public static void setUpDatabaseWithCorpus() throws FileNotFoundException {
        TestLoadUtils.cleanDatabase();
        initializeSystem();
        TestLoadUtils.loadCorpus();
    }

    public static void cleanDatabase() {

        VisualRequiresInterface visualRequiresInterface = new VisualRequiresInterface();

        visualRequiresInterface.cleanFragmentMapCache();
        visualRequiresInterface.cleanScholarInterMapCache();
        visualRequiresInterface.cleanVirtualEditionInterMapByUrlIdCache();
        visualRequiresInterface.cleanVirtualEditionInterMapByXmlIdCache();
        visualRequiresInterface.cleanVirtualEditionMapCache();


       visualRequiresInterface.removeTextModule();

//       feUserRequiresInterface.removeUserModule();

        visualRequiresInterface.removeVirtualModule();

//        new FeReadingRequiresInterface().removeRecommendationModule();
//
//        new FeGameRequiresInterface().removeGameModule();
    }

    public static byte[] jsonBytes(Object object) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return mapper.writeValueAsBytes(object);
    }

    public static void initializeSystem() {

        VisualRequiresInterface visualRequiresInterface = new VisualRequiresInterface();

        visualRequiresInterface.initializeTextModule();

//        userCreate = new FeUserRequiresInterface().initializeUserModule();

        visualRequiresInterface.initializeVirtualModule();

//        new FeReadingRequiresInterface().initializeRecommendationModule();

//        new FeGameRequiresInterface().initializeGameModule();

    }

}


import java.io.IOException;
import java.util.Properties;

public class PropertiesManager {

	private static final Properties properties = new Properties();

	static {
		try {
			properties.load(PropertiesManager.class.getResourceAsStream("/application.properties"));
			properties.load(PropertiesManager.class.getResourceAsStream("/specific.properties"));
			properties.load(PropertiesManager.class.getResourceAsStream("/secrete.properties"));
		} catch (IOException e) {
			throw new RuntimeException("Unable to load properties files.", e);
		}
	}

	public static Properties getProperties() {
		return properties;
	}
}

import org.apache.commons.lang.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.NoHandlerFoundException;


import javax.servlet.http.HttpServletRequest;

//@EnableWebMvc
@ControllerAdvice
public class LdoDExceptionHandler {
    private final static Logger logger = LoggerFactory.getLogger(LdoDExceptionHandler.class);


    @ExceptionHandler({LdoDLoadException.class})
    public ModelAndView handleLdoDLoadException(LdoDLoadException ex) {

        logger.debug("LdoDLoadException: {}", ex.getMessage());

        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("utils/notOkMessage");
        modelAndView.addObject("message", ex.getMessage());
        return modelAndView;
    }


    @ExceptionHandler({AccessDeniedException.class})
    public ModelAndView handleAccessDeniedException(AccessDeniedException ex) {

        logger.debug("AccessDeniedException: {}", ex.getMessage());

        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("utils/errorPage");
        modelAndView.addObject("message", "general.access.denied");
        return modelAndView;
    }

    @ExceptionHandler({LdoDException.class})
    public ModelAndView handleLdoException(LdoDException ex) {

        logger.debug("LdoDException: {}", ExceptionUtils.getStackTrace(ex));

        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("utils/notOkMessage");
        modelAndView.addObject("message", ex.getMessage());
        return modelAndView;
    }

    @ExceptionHandler({Exception.class})
    public ModelAndView handleException(Exception ex) {

        logger.error("Exception: {}", ExceptionUtils.getStackTrace(ex));

        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("utils/notOkMessage");
        modelAndView.addObject("message", ex.getMessage());
        return modelAndView;
    }

    @ExceptionHandler(NoHandlerFoundException.class)
    public ModelAndView handleAnyException(HttpServletRequest request, Exception ex) {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("utils/notOkMessage");
        modelAndView.addObject("message", ex.getMessage());
        return modelAndView;
    }

}


import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithUserDetails;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.api.VisualRequiresInterface;

import pt.ist.socialsoftware.edition.config.VisualApplication;


import pt.ist.socialsoftware.edition.api.remote.VisualRemoteController;
import pt.ist.socialsoftware.edition.ldod.visual.LdoDExceptionHandler;
import pt.ist.socialsoftware.edition.ldod.visual.TestLoadUtils;
import pt.ist.socialsoftware.edition.ldod.visual.TransactionFilter;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.InterIdDistancePairDto;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.WeightsDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

import java.io.FileNotFoundException;

import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@ExtendWith(SpringExtension.class)
@SpringBootTest(classes = VisualApplication.class)
@AutoConfigureMockMvc
public class VisualTest {
//    private static final Logger log = LoggerFactory.getLogger(VirtualEditionTest.class);
    public static final String ARCHIVE_EDITION_ACRONYM = "LdoD-Arquivo";
    public static final String CUNHA_EDITION_ACRONYM = "TSC";
    public static final String ZENITH_EDITION_ACRONYM = "RZ";



    @InjectMocks
    VisualRemoteController visualRemoteController;

    protected MockMvc mockMvc;

    @BeforeAll
//    @Atomic(mode = Atomic.TxMode.WRITE)
    public static void setUpAll() throws FileNotFoundException {
        TestLoadUtils.setUpDatabaseWithCorpus();

        String[] fragments = {"001.xml", "002.xml", "003.xml"};
        TestLoadUtils.loadFragments(fragments);
    }

    @AfterAll
//    @Atomic(mode = Atomic.TxMode.WRITE)
    public static void tearDownAll() {
        TestLoadUtils.cleanDatabase();
    }

    @BeforeEach
    public void setUp()  {
        this.mockMvc = MockMvcBuilders.standaloneSetup(this.visualRemoteController)
                .setControllerAdvice(new LdoDExceptionHandler()).addFilters(new TransactionFilter()).build();
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    @WithUserDetails("ars")
    public void getFragmentsExpertTest() throws Exception {
//        this.mockMvc.perform(get("/visual/editions/acronym/{acronym}/fragments", TextModule.getInstance().getTSCEdition().getAcronym()))
//                .andDo(print()).andExpect(status().isOk()).andExpect(content().string(notNullValue()));
        this.mockMvc.perform(get("/visual/editions/acronym/{acronym}/fragments", new VisualRequiresInterface().getExpertEditionByAcronym(CUNHA_EDITION_ACRONYM).getAcronym()))
                .andDo(print()).andExpect(status().isOk()).andExpect(content().string(notNullValue()));
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    @WithUserDetails("ars")
    public void getVirtualFragmentsVirtualTest() throws Exception {
        this.mockMvc.perform(get("/visual/editions/acronym/{acronym}/fragments", ARCHIVE_EDITION_ACRONYM))
                .andDo(print()).andExpect(status().isOk()).andExpect(content().string(notNullValue()));
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    @WithUserDetails("ars")
    public void getFragmentsErrorTest() throws Exception {
        this.mockMvc.perform(get("/visual/editions/acronym/{acronym}/fragments", "ERROR")).andDo(print())
                .andExpect(status().is4xxClientError()).andExpect(content().string(""));
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    @WithUserDetails("ars")
    public void getIntersByDistanceExpertEditionTest() throws Exception {
//        ExpertEditionInter expertEditionInter = TextModule.getInstance().getRZEdition().getSortedInterps().get(0);
        ScholarInterDto expertEditionInter = new VisualRequiresInterface().getExpertEditionScholarInterDtoList(ZENITH_EDITION_ACRONYM).get(0);


        WeightsDto dto = new WeightsDto(0.0f, 0.0f, 0.0f, 0.0f);

        String res = this.mockMvc.perform(post("/visual/editions/{externalId}/intersByDistance", expertEditionInter.getExternalId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(TestLoadUtils.jsonBytes(dto)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().string(not(""))).andReturn().getResponse().getContentAsString();

        res = res.replace("[", "").replace("]", "")
                .replace("},{", "};{");

        String[] frags = res.split(";");
        System.out.println(res);
        assertEquals(3, frags.length);
        ObjectMapper mapper = new ObjectMapper();
        for (int i = 0; i < 3; i++) {
            InterIdDistancePairDto pair = mapper.readValue(frags[i], InterIdDistancePairDto.class);
            if (pair.getInterId().equals(expertEditionInter.getExternalId())) {
                assertEquals(1.0, pair.getDistance());
            } else {
                assertEquals(0.0, pair.getDistance());
            }
        }
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
//    @WithUserDetails("ars")
    public void getIntersByDistanceVirtualEditionTest() throws Exception {
        VirtualEditionInterDto vi = new VisualRequiresInterface().getArchiveEdition()
                .getIntersSet().stream().findFirst().get();

        WeightsDto dto = new WeightsDto(0.0f, 0.0f, 0.0f, 0.0f);

        String res = this.mockMvc.perform(post("/visual/editions/{externalId}/intersByDistance", vi.getExternalId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(TestLoadUtils.jsonBytes(dto)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().string(not(""))).andReturn().getResponse().getContentAsString();

        res = res.replace("[", "").replace("]", "")
                .replace("},{", "};{");

        String[] frags = res.split(";");
        System.out.println(res);
        assertEquals(3, frags.length);
        ObjectMapper mapper = new ObjectMapper();
        for (int i = 0; i < 3; i++) {
            InterIdDistancePairDto pair = mapper.readValue(frags[i], InterIdDistancePairDto.class);
            if (pair.getInterId().equals(vi.getExternalId())) {
                assertEquals(1.0, pair.getDistance());
            } else {
                assertEquals(0.0, pair.getDistance());
            }
        }
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
    public void getEditionsTest() throws Exception {
        this.mockMvc.perform(get("/visual/editions/public"))
                .andDo(print()).andExpect(status().isOk()).andExpect(content().string(notNullValue()));
    }

    @Test
//    @Atomic(mode = Atomic.TxMode.WRITE)
    public void getInterIdTFIDFTermsTest() throws Exception {
        VirtualEditionDto ve = new VisualRequiresInterface().getArchiveEdition();
        VirtualEditionInterDto inter = ve.getIntersSet().stream().findFirst().get();

        this.mockMvc.perform(get("/visual/editions/acronym/{acronym}/interId/{interId}/tfidf", ARCHIVE_EDITION_ACRONYM, inter.getExternalId()))
                .andDo(print()).andExpect(status().isOk()).andExpect(content().string(notNullValue()));
    }

}



import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.InterIdDistancePairDto;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.WeightsDto;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.wrappers.IntersByDistance;
import pt.ist.socialsoftware.edition.notification.dtos.text.*;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterListDto;


import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.*;

public class VisualRequiresInterface {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    // Requires the Text Module

    //Check later
    public List<ExpertEditionInterListDto> getEditionInterListDto() {
        return webClient.build()
                .get()
                .uri("/expertEditionInters")
                .retrieve()
                .bodyToFlux(ExpertEditionInterListDto.class)
                .collectList()
                .block();
        //  return this.textProvidesInterface.getEditionInterListDto();
    }

    public ExpertEditionDto getExpertEditionDto(String acronym) {
        return webClient.build()
                .get()
                .uri("/expertEdition/acronym/" + acronym)
                .retrieve()
                .bodyToMono(ExpertEditionDto.class)
                .blockOptional().orElse(null);
        //  return this.textProvidesInterface.getExpertEditionDto(acronym);
    }

    public List<ScholarInterDto> getExpertEditionScholarInterDtoList(String acronym) {
        return webClient.build()
                .get()
                .uri("/expertEdition/" + acronym + "/scholarInterList")
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
        //  return this.textProvidesInterface.getExpertEditionScholarInterDtoList(acronym);
    }

    public String getWriteFromPlainHtmlWriter4OneInter(String xmlId, boolean highlightDiff) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/writeFromPlainHtmlWriter4OneInter/")
                        .queryParam("xmlId", xmlId)
                        .queryParam("highlightDiff", highlightDiff)
                        .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();
    }


    public ScholarInterDto getScholarInterbyExternalId(String interId) {
        return webClient.build()
                .get()
                .uri("/scholarinter/ext/" + interId)
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().orElse(null);
    }

    public List<Map.Entry<String, Double>> getScholarInterTermFrequency(ScholarInterDto scholarInterDto) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + scholarInterDto.getXmlId() + "/termFrequency")
                .retrieve()
                .bodyToFlux(new ParameterizedTypeReference<Map.Entry<String, Double>>() {})
                .collectList()
                .block();
        //  return this.textProvidesInterface.getScholarInterTermFrequency(scholarInterDto);
    }


    // Requires the Virtual Module
    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);

    public List<VirtualEditionInterListDto> getPublicVirtualEditionInterListDto() {
        return webClientVirtual.build()
                .get()
                .uri("/publicVirtualEditionInterList")
                .retrieve()
                .bodyToFlux(VirtualEditionInterListDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getPublicVirtualEditionInterListDto();
    }

    public VirtualEditionDto getVirtualEdition(String acronym) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym)
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEdition(acronym);
    }

    public ScholarInterDto getScholarInterByExternalIdOfInter(String interId) {
        ScholarInterDto scholarInterDto =
                this.webClientVirtual.build()
                        .get()
                        .uri("/scholarInter/ext/" + interId)
                        .retrieve()
                        .bodyToMono(ScholarInterDto.class)
                        .block();

//                        .getScholarInterbyExternalId(interId);

        if (scholarInterDto == null) {
            scholarInterDto = getScholarInterbyExternalId(interId);
        }

        return scholarInterDto;
    }


    // Requires the Recommendation Module
    private final WebClient.Builder webClientRecommendation = WebClient.builder().baseUrl(RECOMMENDATION_SERVICE_URL);

    public List<InterIdDistancePairDto> getIntersByDistance(String externalId, WeightsDto weights) {

        ScholarInterDto scholarInterDto = getScholarInterbyExternalId(externalId);
        if (scholarInterDto != null) {
            return getScholarIntersByDistance(scholarInterDto, weights);
        }

        VirtualEditionInterDto virtualEditionInterDto = webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/ext/" + externalId)
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
//                this.virtualProvidesInterface.getVirtualEditionInterByExternalId(externalId);
        if (virtualEditionInterDto != null) {
            return geVirtualEditiontIntersByDistance(virtualEditionInterDto, weights);
        }
        return null;
    }


    private List<InterIdDistancePairDto> getScholarIntersByDistance(ScholarInterDto scholarInterDto, WeightsDto weightsDto) {
        return webClientRecommendation.build()
                .post()
                .uri("/scholarIntersByDistance")
                .bodyValue(new IntersByDistance(scholarInterDto, weightsDto))
                .retrieve()
                .bodyToFlux(InterIdDistancePairDto.class)
                .collectList()
                .block();
    }

    private List<InterIdDistancePairDto> geVirtualEditiontIntersByDistance(VirtualEditionInterDto virtualEditionInterDto, WeightsDto weightsDto) {
        return webClientRecommendation.build()
                .post()
                .uri("/virtualEditionIntersByDistance")
                .bodyValue(new IntersByDistance(virtualEditionInterDto, weightsDto))
                .retrieve()
                .bodyToFlux(InterIdDistancePairDto.class)
                .collectList()
                .block();
    }


    // Test Method Calls

    public List<HeteronymDto> getSortedHeteronyms() {
        return  webClient.build()
                .get()
                .uri("/sortedHeteronyms")
                .retrieve()
                .bodyToFlux(HeteronymDto.class).toStream()
                .collect(Collectors.toList());
    }

    public void getLoaderTEICorpus(InputStream file) {
        try {
            webClient.build().post()
                    .uri("/loadTEICorpus")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .bodyValue(file.readAllBytes())
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void loadTEICorpusVirtual(InputStream inputStream) {
        try {
            webClientVirtual.build()
                    .post()
                    .uri("/loadTEICorpusVirtual")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .bodyValue(inputStream.readAllBytes())
                    .retrieve()
                    .bodyToMono(Void.class)
                    .block();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void importVirtualEditionCorupus(InputStream inputStream) {
        try {
            webClientVirtual.build()
                    .post()
                    .uri("/importVirtualEditionCorpus")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .bodyValue(inputStream.readAllBytes())
                    .retrieve()
                    .bodyToMono(Void.class)
                    .block();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //        this.virtualProvidesInterface.importVirtualEditionCorpus(inputStream);
    }

    public String getLoadTEIFragmentsAtOnce(InputStream file) {
        try {
            return webClient.build()
                    .post()
                    .uri("/loadFragmentsAtOnce")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .bodyValue(file.readAllBytes())
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "";
    }

    public void getFragmentCorpusGenerator() {
        Set<FragmentDto> fragments = webClient.build()
                .get()
                .uri("/fragmentDtosWithScholarInterDtos")
                .retrieve()
                .bodyToFlux(FragmentDto.class).toStream()
                .collect(Collectors.toSet());
        ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter();
        try {
            String json = ow.writeValueAsString(fragments);
            webClientVirtual.build()
                    .post()
                    .uri("/loadTEIFragmentCorpus")
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(json)
                    .retrieve()
                    .bodyToMono(Void.class)
                    .block();
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        //       this.virtualProvidesInterface.loadTEIFragmentCorpus(fragments);
    }

    public void cleanFragmentMapCache() {
        webClient.build()
                .get()
                .uri("/cleanFragmentMapCache")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void cleanScholarInterMapCache() {
        webClient.build()
                .get()
                .uri("/cleanScholarInterMapCache")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void cleanVirtualEditionInterMapByUrlIdCache() {
        webClientVirtual.build()
                .post()
                .uri("/cleanVirtualEditionInterMapByUrlIdCache")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void cleanVirtualEditionInterMapByXmlIdCache() {
        webClientVirtual.build()
                .post()
                .uri("/cleanVirtualEditionInterMapByXmlIdCache")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void cleanVirtualEditionMapCache() {
        webClientVirtual.build()
                .post()
                .uri("/cleanVirtualEditionMapCache")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void removeTextModule() {
        webClient.build()
                .post()
                .uri("/removeModule")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void removeVirtualModule() {
        webClientVirtual.build()
                .post()
                .uri("/removeVirtualModule")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void importFragmentFromTEI(InputStream inputStream) {
        try {
            webClientVirtual.build()
                    .post()
                    .uri("/importVirtualEditionFragmentFromTEI")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .bodyValue(inputStream.readAllBytes())
                    .retrieve()
                    .bodyToMono(Void.class)
                    .block();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public ExpertEditionDto getExpertEditionByAcronym(String acronym) {
        return webClient.build()
                .get()
                .uri("/expertEdition/acronym/" + acronym)
                .retrieve()
                .bodyToMono(ExpertEditionDto.class)
                .blockOptional().orElse(null);
    }

    public VirtualEditionDto getArchiveEdition() {
        return webClientVirtual.build()
                .get()
                .uri("/archiveVirtualEdition")
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
//        return this.virtualProvidesInterface.getArchiveVirtualEdition();
    }

    public boolean initializeTextModule() {
        return webClient.build().get()
                .uri("/initializeTextModule")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //return this.textProvidesInterface.initializeTextModule();
    }

    public boolean initializeVirtualModule() {
        return webClientVirtual.build()
                .post()
                .uri("/initializeVirtualModule")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.initializeVirtualModule();
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;


import pt.ist.socialsoftware.edition.api.VisualRequiresInterface;

import pt.ist.socialsoftware.edition.notification.dtos.recommendation.InterIdDistancePairDto;
import pt.ist.socialsoftware.edition.notification.dtos.recommendation.WeightsDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ExpertEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ExpertEditionInterListDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.visual.EditionFragmentsDto;
import pt.ist.socialsoftware.edition.notification.dtos.visual.EditionInterListDto;
import pt.ist.socialsoftware.edition.notification.dtos.visual.Fragment4VisualDto;


import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Controller
@SessionAttributes({"frontendSession"})
@RequestMapping("/visual/editions")
public class VisualRemoteController {
    private static final Logger logger = LoggerFactory.getLogger(VisualRemoteController.class);

    private final VisualRequiresInterface visualRequiresInterface = new VisualRequiresInterface();

    @GetMapping("/public")
    public @ResponseBody
    ResponseEntity<List<EditionInterListDto>> getExpertEditionsAndPublicVirtualEditions() {
        logger.debug("getExpertEditionsAndPublicVirtualEditions");

        //ADD both
        List<ExpertEditionInterListDto> expertresult = new ArrayList<>(this.visualRequiresInterface.getEditionInterListDto());
        List<EditionInterListDto> result = this.visualRequiresInterface.getPublicVirtualEditionInterListDto().stream()
                .map(virtualEditionInterListDto -> new EditionInterListDto(virtualEditionInterListDto))
                .collect(Collectors.toList());

        result.addAll(this.visualRequiresInterface.getEditionInterListDto().stream()
                .map(expertEditionInterListDto -> new EditionInterListDto(expertEditionInterListDto))
                .collect(Collectors.toList()));


        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @RequestMapping(method = RequestMethod.GET, value = "/acronym/{acronym}/fragments")
    @PreAuthorize("hasPermission(#acronym, 'editionacronym.public')")
    public @ResponseBody
    ResponseEntity<EditionFragmentsDto> getFragments(@PathVariable String acronym) {
        logger.debug("getFragments acronym:{}", acronym);

        EditionFragmentsDto editionFragments = new EditionFragmentsDto();
        ExpertEditionDto expertEdition = this.visualRequiresInterface.getExpertEditionDto(acronym);
        if (expertEdition != null) {
            editionFragments.setCategories(new ArrayList<>());

            List<Fragment4VisualDto> fragments = new ArrayList<>();

            this.visualRequiresInterface.getExpertEditionScholarInterDtoList(acronym).stream().sorted(Comparator.comparing(ScholarInterDto::getTitle))
                    .forEach(inter -> {
//                        PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(inter.getXmlId());
//                        writer.write(false);
                        Fragment4VisualDto fragment = new Fragment4VisualDto(inter, this.visualRequiresInterface.getWriteFromPlainHtmlWriter4OneInter(inter.getXmlId(), false));

                        fragments.add(fragment);
                    });

            editionFragments.setFragments(fragments);

            return new ResponseEntity<>(editionFragments, HttpStatus.OK);

        } else {
            VirtualEditionDto virtualEdition = this.visualRequiresInterface.getVirtualEdition(acronym);
            if (virtualEdition != null) {
                editionFragments.setCategories(virtualEdition.getSortedCategorySet());

                List<Fragment4VisualDto> fragments = new ArrayList<>();

                virtualEdition.getSortedVirtualEditionInterDtoList().stream().sorted(Comparator.comparing(VirtualEditionInterDto::getTitle))
                        .forEach(inter -> {
//                            PlainHtmlWriter4OneInter writer = new PlainHtmlWriter4OneInter(inter.getLastUsed().getXmlId());
//                            writer.write(false);
                            Fragment4VisualDto fragment = new Fragment4VisualDto(inter, this.visualRequiresInterface.getWriteFromPlainHtmlWriter4OneInter(inter.getLastUsed().getXmlId(), false));

                            fragments.add(fragment);
                        });

                editionFragments.setFragments(fragments);

                return new ResponseEntity<>(editionFragments, HttpStatus.OK);

            }
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

    }


    @RequestMapping(method = RequestMethod.GET, value = "/acronym/{acronym}/interId/{interId}/tfidf")
    @PreAuthorize("hasPermission(#acronym, 'editionacronym.public')")
    public @ResponseBody
    ResponseEntity<List<Map.Entry<String, Double>>> getInterIdTFIDFTerms(
            @PathVariable String acronym, @PathVariable String interId) {
        logger.debug("getInterIdTFIDFTerms acronym:{}", acronym);

        ScholarInterDto scholarInterDto = this.visualRequiresInterface.getScholarInterByExternalIdOfInter(interId);

        List<Map.Entry<String, Double>> result = this.visualRequiresInterface.getScholarInterTermFrequency(scholarInterDto);

        if (result == null) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @RequestMapping(method = RequestMethod.POST, value = "/{externalId}/intersByDistance")
    @PreAuthorize("hasPermission(#externalId, 'fragInter.public')")
    public @ResponseBody
    ResponseEntity<InterIdDistancePairDto[]> getIntersByDistance(Model model,
                                                                 @PathVariable String externalId, @RequestBody WeightsDto weights) {
        logger.debug("getIntersByDistance externalId: {}, weights: {}", externalId,
                "(" + weights.getHeteronymWeight() + "," + weights.getTextWeight() + "," + weights.getDateWeight() + ","
                        + weights.getTaxonomyWeight() + ")");


        List<InterIdDistancePairDto> interIdDistancePairDtos = this.visualRequiresInterface.getIntersByDistance(externalId, weights);

        if (interIdDistancePairDtos != null) {
            return new ResponseEntity<>(interIdDistancePairDtos.stream()
                    .toArray(size -> new InterIdDistancePairDto[size]), HttpStatus.OK);
        }

        return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }


}



import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;


@ComponentScan(basePackages = "pt.ist.socialsoftware.edition")
@SpringBootApplication
@Configuration
@EnableJms
public class VisualApplication extends SpringBootServletInitializer implements InitializingBean {


    public static void main(String[] args) {
        SpringApplication.run(VisualApplication.class, args);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }

}


public class ServiceEndpoints {

    // Localhost version
//    public static final String TEXT_SERVICE_URL = "http://localhost:8081/api";
//    public static final String USER_SERVICE_URL = "http://localhost:8082/api";
//    public static final String VIRTUAL_SERVICE_URL = "http://localhost:8083/api";
//    public static final String GAME_SERVICE_URL = "http://localhost:8085/api";
//    public static final String RECOMMENDATION_SERVICE_URL = "http://localhost:8084/api";
//    public static final String SEARCH_SERVICE_URL = "http://localhost:8086/api";
//    public static final String VISUAL_SERVICE_URL = "http://localhost:8087/api";

    // Docker version
    public static final String TEXT_SERVICE_URL = "http://docker-text:8081/api";
    public static final String USER_SERVICE_URL = "http://docker-user:8082/api";
    public static final String VIRTUAL_SERVICE_URL = "http://docker-virtual:8083/api";
    public static final String GAME_SERVICE_URL = "http://docker-game:8085/api";
    public static final String RECOMMENDATION_SERVICE_URL = "http://docker-recommendation:8084/api";
    public static final String SEARCH_SERVICE_URL = "http://docker-search:8086/api";
    public static final String VISUAL_SERVICE_URL = "http://docker-visual:8087/api";
}


public enum Material {
    PAPER
}


public enum Mode {
    AND("and"), OR("or");

    private final String mode;

    Mode(String mode) {
        this.mode = mode;
    }

    public String getMode() {
        return this.mode;
    }

}


public enum DateType {
    YEAR, MONTH, DAY
}


public enum Form {
    LEAF
}


public enum SourceType {
    MANUSCRIPT("manuscript"), PRINTED("printed");

    private final String desc;

    SourceType(String desc) {
        this.desc = desc;
    }

    public String getDesc() {
        return this.desc;
    }
}


public enum Role_Type {
    ROLE_USER, ROLE_ADMIN
}


public enum Dated {
    ALL("all"), DATED("dated"), UNDATED("undated");

    private final String dated;

    Dated(String dated) {
        this.dated = dated;
    }

    public String getDated() {
        return this.dated;
    }
}


public enum Medium {
    PEN("pen"), PENCIL("pencil"), BLUE_INK("blue-ink"), BLACK_INK("black-ink"), VIOLET_INK("violet-ink"), RED_INK(
            "red-ink"), GREEN_INK("green-ink");

    private final String desc;

    Medium(String desc) {
        this.desc = desc;
    }

    public String getDesc() {
        return this.desc;
    }
}


public enum PrecisionType {
    HIGH("high"), MEDIUM("medium"), LOW("low"), UNKNOWN("unknown");

    private final String desc;

    PrecisionType(String desc) {
        this.desc = desc;
    }

    public String getDesc() {
        return this.desc;
    }
}


import org.joda.time.DateTime;
import org.joda.time.LocalDate;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateUtils {
    public static LocalDate convertDate(String dateString) {
        Date date = null;
        if (dateString.equals("")) {
            return null;
        } else if (dateString.length() == 4) {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy");
            try {
                date = dateFormat.parse(dateString);
            } catch (ParseException e) {
                throw new LdoDLoadException(
                        "A data não está no formato correto: " + dateString);
            }
            return new LocalDate(new DateTime(date));
        } else {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            try {
                date = dateFormat.parse(dateString);
            } catch (ParseException e) {
                throw new LdoDLoadException(
                        "A data não está no formato correto: " + dateString);
            }
            return new LocalDate(new DateTime(date));
        }
    }
}





import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;

import java.util.ArrayList;
import java.util.List;

public class LdoDEditVirtualEditionException extends LdoDException {

    private static final long serialVersionUID = 6962978813318025931L;

    private List<String> errors = new ArrayList<>();
    private VirtualEditionDto virtualEdition = null;
    private String acronym = null;
    private String title = null;
    private boolean pub = false;

    public LdoDEditVirtualEditionException(List<String> errors,
                                           VirtualEditionDto virtualEdition, String acronym, String title,
                                           boolean pub) {
        this.errors = errors;
        this.virtualEdition = virtualEdition;
        this.acronym = acronym;
        this.title = title;
        this.pub = pub;
    }

    public List<String> getErrors() {
        return this.errors;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public VirtualEditionDto getVirtualEdition() {
        return this.virtualEdition;
    }

    public String getTitle() {
        return this.title;
    }

    public boolean isPub() {
        return this.pub;
    }

}


public class LdoDDuplicateUsernameException extends LdoDException {

    private static final long serialVersionUID = 1L;

    public LdoDDuplicateUsernameException(String message) {
        super(message);
    }

}


public class LdoDDuplicateNameException extends LdoDException {
    private static final long serialVersionUID = 1L;

    public LdoDDuplicateNameException(String name) {
        super(name);
    }
}





import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;

import java.util.ArrayList;
import java.util.List;

public class LdoDCreateVirtualEditionException extends LdoDException {
    private static final long serialVersionUID = 1L;

    private List<String> errors = new ArrayList<>();
    private String acronym = null;
    private String title = null;
    private boolean pub = false;
    private List<VirtualEditionDto> virtualEditions = null;
    private String user = null;

    public LdoDCreateVirtualEditionException(List<String> errors, String acronym, String title, boolean pub,
                                             List<VirtualEditionDto> virtualEditions, String user) {
        this.errors = errors;
        this.acronym = acronym;
        this.title = title;
        this.pub = pub;
        this.virtualEditions = virtualEditions;
        this.user = user;
    }

    public List<String> getErrors() {
        return this.errors;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getTitle() {
        return this.title;
    }

    public boolean isPub() {
        return this.pub;
    }

    public List<VirtualEditionDto> getVirtualEditions() {
        return this.virtualEditions;
    }

    public String getUser() {
        return this.user;
    }

}


import java.io.Serializable;

public class LdoDException extends RuntimeException implements Serializable {

    private static final long serialVersionUID = 1L;

    protected String message;

    public LdoDException() {
        this.message = "";
    }

    public LdoDException(String message) {
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }

}


public class LdoDLoadException extends LdoDException {

    private static final long serialVersionUID = -4087610484821921033L;

    public LdoDLoadException(String message) {
        this.message = message;
    }

}



public class LdoDExceptionNonAuthorized extends LdoDException {

}


import java.io.IOException;
import java.util.Properties;

public class PropertiesManager {

	private static final Properties properties = new Properties();

	static {
		try {
			properties.load(PropertiesManager.class.getResourceAsStream("/application.properties"));
			properties.load(PropertiesManager.class.getResourceAsStream("/specific.properties"));
			properties.load(PropertiesManager.class.getResourceAsStream("/secrete.properties"));
		} catch (IOException e) {
			throw new RuntimeException("Unable to load properties files.", e);
		}
	}

	public static Properties getProperties() {
		return properties;
	}
}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class Emailer {
    private static final Logger logger = LoggerFactory.getLogger(Emailer.class);

    public void sendEmail(String to, String subject, String msg, String from)
            throws MessagingException {
        Properties properties = setMailProperties();

        Session getMailSession = Session.getDefaultInstance(properties, null);

        Message generateMailMessage = createMessage(from, to, subject, msg, getMailSession);

        sendMessage(getMailSession, generateMailMessage);
    }

    private void sendMessage(Session getMailSession, Message generateMailMessage) throws MessagingException {
        Transport transport = getMailSession.getTransport("smtp");
        transport.connect((String) PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.host"),
                (String) PropertiesManager.getProperties().get("registration.confirmation.email.user"),
                (String) PropertiesManager.getProperties().get("registration.confirmation.email.password"));
        transport.sendMessage(generateMailMessage, generateMailMessage.getAllRecipients());
        transport.close();
    }

    private Message createMessage(String from, String to, String subject, String msg, Session getMailSession)
            throws MessagingException {
        Message generateMailMessage = new MimeMessage(getMailSession);
        generateMailMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
        generateMailMessage.addRecipient(Message.RecipientType.BCC, new InternetAddress(from));
        generateMailMessage.setSubject(subject);
        generateMailMessage.setContent(msg, "text/html");
        return generateMailMessage;
    }

    private Properties setMailProperties() {
        Properties properties = new Properties();
        properties.put("mail.smtp.auth", "true");
        properties.put("mail.smtp.starttls.enable", "true");
        properties.put("mail.smtp.host",
                PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.host"));
        properties.put("mail.smtp.port",
                PropertiesManager.getProperties().get("registration.confirmation.mail.smtp.port"));
        return properties;
    }
}






import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;

import java.util.ArrayList;
import java.util.List;

public class LdoDCreateClassificationGameException extends LdoDException {
    private static final long serialVersionUID = 1L;

    private List<String> errors = new ArrayList<>();
    private final String description;
    private final String interExternalId;
    private final String date;
    private final VirtualEditionDto virtualEdition;

    public LdoDCreateClassificationGameException(List<String> errors, String description, String date,
                                                 String interExternalId, VirtualEditionDto virtualEdition) {
        this.errors = errors;
        this.description = description;
        this.date = date;
        this.interExternalId = interExternalId;
        this.virtualEdition = virtualEdition;
    }

    public List<String> getErrors() {
        return this.errors;
    }

    public String getDescription() {
        return this.description;
    }

    public String getDate() {
        return this.date;
    }

    public String getInterExternalId() {
        return this.interExternalId;
    }

    public VirtualEditionDto getVirtualEdition() {
        return this.virtualEdition;
    }

}


public class LdoDDuplicateAcronymException extends LdoDException {

    private static final long serialVersionUID = -3947538146603301616L;

}



import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;

public class MainFragmentDto {

    private String xmlId;

    public String getXmlId() {
        return xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public MainFragmentDto(FragmentDto fragment) {
        this.xmlId = fragment.getXmlId();
    }
}


import java.io.Serializable;
import java.util.List;

public class AnnotationSearchJson implements Serializable {
	private static final long serialVersionUID = 1L;

	private int total;
	private List<AnnotationDTO> rows;

	public AnnotationSearchJson(List<AnnotationDTO> annotations) {
		setTotal(annotations.size());
		setRows(annotations);
	}

	public int getTotal() {
		return total;
	}

	public void setTotal(int total) {
		this.total = total;
	}

	public List<AnnotationDTO> getRows() {
		return rows;
	}

	public void setRows(List<AnnotationDTO> rows) {
		this.rows = rows;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}

}



import pt.ist.socialsoftware.edition.notification.dtos.text.ExpertEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;

public class EditionDto {
    private String acronym;

    public EditionDto(ExpertEditionDto edition) {
        this.acronym = edition.getAcronym();
    }

    public EditionDto(VirtualEditionDto edition) {
        this.acronym = edition.getAcronym();
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class PermissionDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private List<String> read = new ArrayList<>();
    private List<String> admin = new ArrayList<>();
    private List<String> update = new ArrayList<>();
    private List<String> delete = new ArrayList<>();

    public PermissionDTO() {
    }

    public PermissionDTO(VirtualEditionDto virtualEditionDto, String user) {
        if (!virtualEditionDto.getPub()) {
            for (String participant: virtualEditionDto.getParticipantSet()) {
                this.read.add(participant);
            }
        }

        if (virtualEditionDto.getParticipantSet().contains(user)) {
            this.update.add(user);
        }

        this.delete.add(user);
    }


    public List<String> getRead() {
        return this.read;
    }

    public void setRead(List<String> read) {
        this.read = read;
    }

    public List<String> getAdmin() {
        return this.admin;
    }

    public void setAdmin(List<String> admin) {
        this.admin = admin;
    }

    public List<String> getUpdate() {
        return this.update;
    }

    public void setUpdate(List<String> update) {
        this.update = update;
    }

    public List<String> getDelete() {
        return this.delete;
    }

    public void setDelete(List<String> delete) {
        this.delete = delete;
    }

    public static long getSerialversionuid() {
        return serialVersionUID;
    }
}


import org.apache.commons.lang.StringEscapeUtils;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.AnnotationDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.HumanAnnotationDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.RangeJson;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TagDto;


import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

//@JsonIgnoreProperties(ignoreUnknown = true)
public class AnnotationDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private String id;
    private List<RangeJson> ranges;
    private String quote;
    private String text;
    private List<String> tags;
    private String uri;
    private String user;
    private PermissionDTO permissions;

    public AnnotationDTO() {
    }


    public AnnotationDTO(AnnotationDto annotation) {
        if (!annotation.isHumanAnnotation()) {
            setText(StringEscapeUtils.unescapeHtml(annotation.getText()));
        } else if (annotation.isHumanAnnotation()) {
            setText(StringEscapeUtils.unescapeHtml(annotation.getText()));
        }

        setId(annotation.getExternalId());
        setQuote(StringEscapeUtils.unescapeHtml(annotation.getQuote()));
        setUri(annotation.getInterExternalId());

        this.ranges = new ArrayList<>();
        this.ranges.addAll(new ArrayList<>(annotation.getRangeSet()));

        setUser(annotation.getUser());

        // code that supports treatment for Human Annotation
        if (annotation.isHumanAnnotation()) {
            this.tags = new ArrayList<>();
            for (TagDto tag : ((HumanAnnotationDto) annotation).getTags()) {
                this.tags.add(tag.getNameInEdition());
            }

            setPermissions(
                    new PermissionDTO(annotation.getVirtualEdition(),
                            annotation.getUser()));
        }
    }

    public List<RangeJson> getRanges() {
        return this.ranges;
    }

    public void setRanges(List<RangeJson> range) {
        this.ranges = range;
    }

    public String getQuote() {
        return this.quote;
    }

    public void setQuote(String quote) {
        this.quote = quote;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public List<String> getTags() {
        return this.tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }

    public String getUri() {
        return this.uri;
    }

    public void setUri(String uri) {
        this.uri = uri;
    }

    public static long getSerialversionuid() {
        return serialVersionUID;
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUser() {
        return this.user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public PermissionDTO getPermissions() {
        return this.permissions;
    }

    public void setPermissions(PermissionDTO permissions) {
        this.permissions = permissions;
    }

}



import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;

public class JWTAuthenticationDto {
    private String accessToken;
    private String tokenType = PropertiesManager.getProperties().getProperty("spring.security.jwt.token.prefix");

    public JWTAuthenticationDto(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getAccessToken() {
        return this.accessToken;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getTokenType() {
        return this.tokenType;
    }

    public void setTokenType(String tokenType) {
        this.tokenType = tokenType;
    }
}



import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.client.WebClient;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.USER_SERVICE_URL;

public class UserConnectionDto {

    private final WebClient.Builder webClientUser = WebClient.builder().baseUrl(USER_SERVICE_URL);

    private String userId;
    private String providerId;
    private String providerUserId;
    private String displayName;
    private String profileUrl;
    private String imageUrl;
    private String accessToken;
    private String secret;
    private String refreshToken;
    private long expireTime;
    private int rank;

    public UserConnectionDto() {

    }

    public String getUserId() {
        return userId;
    }

    public String getProviderId() {
        return providerId;
    }

    public String getProviderUserId() {
        return providerUserId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getProfileUrl() {
        return profileUrl;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public String getSecret() {
        return secret;
    }

    public String getRefreshToken() {
        return refreshToken;
    }

    public long getExpireTime() {
        return expireTime;
    }

    public int getRank() {
        return rank;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setProviderId(String providerId) {
        this.providerId = providerId;
    }

    public void setProviderUserId(String providerUserId) {
        this.providerUserId = providerUserId;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public void setProfileUrl(String profileUrl) {
        this.profileUrl = profileUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    public void setRefreshToken(String refreshToken) {
        this.refreshToken = refreshToken;
    }

    public void setExpireTime(long expireTime) {
        this.expireTime = expireTime;
    }

    public void setRank(int rank) {
        this.rank = rank;
    }

    @JsonIgnore
    public void updateUserConnection(String displayName, String profileUrl, String imageUrl, String accessToken, String secret, String refreshToken, Long expireTime) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/updateUserConnection")
                    .queryParam("userId", userId)
                    .queryParam("providerId", providerId)
                    .queryParam("providerUserId", providerUserId)
                    .queryParam("displayName", displayName)
                    .queryParam("profileUrl", profileUrl)
                    .queryParam("imageUrl", imageUrl)
                    .queryParam("accessToken", accessToken)
                    .queryParam("secret", secret)
                    .queryParam("refreshToken", refreshToken)
                    .queryParam("expireTime", expireTime)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.updateUserConnection(this.userId, this.providerId, this.providerUserId, displayName, profileUrl, imageUrl, accessToken, secret, refreshToken, expireTime);
    }

    @JsonIgnore
    public void removeUserConnection() {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeUserConnection")
                        .queryParam("userId", userId)
                        .queryParam("providerId", providerId)
                        .queryParam("providerUserId", providerUserId)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }
}


import com.fasterxml.jackson.annotation.JsonIgnore;
import org.joda.time.LocalDate;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.enums.Role_Type;

import java.util.List;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.USER_SERVICE_URL;

public class UserDto {

    private final WebClient.Builder webClientUser = WebClient.builder().baseUrl(USER_SERVICE_URL);

    private String username;

    // cached attributes
    private String firstName;

    private String lastName;

    private boolean isEnabled;

    private boolean isActive;

    private String socialMedalId;

    private String externalId;

    private String password;

    private String email;

    public UserDto() {
    }

    public UserDto(String username) {
        setUsername(username);
//        this.firstName = getFirstNameFromService();
//        this.lastName = getLastNameFromService();
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getFirstName() {
        //return this.userProvidesInterface.getFirstName(this.username);
        return this.firstName;
    }

    public String getLastName() {
        //return this.userProvidesInterface.getLastName(this.username);
        return this.lastName;
    }

    public boolean isEnabled() {
        //return this.userProvidesInterface.isEnabled(this.username);
        return this.isEnabled;
    }

    public boolean isActive() {
        //return this.userProvidesInterface.isActive(this.username);
        return this.isActive;
    }

    public String getSocialMediaId() {
       //return this.userProvidesInterface.getSocialMediaId(this.username);
       return this.socialMedalId;
    }

    public String getPassword() {
        return this.password;
    }

    public String getExternalId() {
        return this.externalId;
    }

    public String getEmail() {
        return email;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public void setEnabled(boolean enabled) {
        isEnabled = enabled;
    }

    public void setActive(boolean active) {
        isActive = active;
    }

    public void setSocialMedalId(String socialMedalId) {
        this.socialMedalId = socialMedalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setEmail(String email) {
        this.email = email;
    }


    @JsonIgnore
    public void updatePassword(PasswordEncoder passwordEncoder, String currentPassword, String newPassword) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/updatePassword")
                        .queryParam("username", username)
                    .queryParam("currentPassword", passwordEncoder.encode(currentPassword))
                    .queryParam("newPassword", passwordEncoder.encode(newPassword))
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.updatePassword(this.username, passwordEncoder, currentPassword, newPassword);
    }

    @JsonIgnore
    public boolean hasRoleTypeAdmin() {
        return webClientUser.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/hasRoleAdmin")
                    .queryParam("username", this.username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return this.userProvidesInterface.hasRoleTypeAdmin(this.username);
    }

    @JsonIgnore
    public boolean hasRoleTypeUser() {
        return webClientUser.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/hasRoleUser")
                        .queryParam("username", this.username)
                        .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return this.userProvidesInterface.hasRoleTypeUser(this.username);
    }

    @JsonIgnore
    public List<String> getRolesSet() {
        return webClientUser.build()
                .get()
                .uri("/user/" + username + "/roles")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        return this.userProvidesInterface.getRolesFromUser(this.username);
    }


    @JsonIgnore
    public RegistrationTokenDto createRegistrationToken(String toString) {
        return webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/createRegistrationToken")
                    .queryParam("username", username)
                    .queryParam("toString", toString)
                    .build())
                .retrieve()
                .bodyToMono(RegistrationTokenDto.class)
                .blockOptional()
                .orElse(null);
        //        return this.userProvidesInterface.createRegistrationToken(this.username, toString);
    }

    @JsonIgnore
    public void enableUnconfirmedUser() {
        webClientUser.build()
                .post()
                .uri("/user/" + this.username + "/enableUnconfirmed")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.enableUnconfirmedUser(this.username);
    }

    @JsonIgnore
    public void update(PasswordEncoder passwordEncoder, String oldUsername, String newUsername, String firstName, String lastName, String email, String newPassword, boolean user, boolean admin, boolean enabled) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/updateUserInfo")
                    .queryParam("username", this.username)
                    .queryParam("oldUsername", oldUsername)
                    .queryParam("newUsername", newUsername)
                    .queryParam("firstName", firstName)
                    .queryParam("lastName", lastName)
                    .queryParam("email", email)
                    .queryParam("newPassword", passwordEncoder.encode(newPassword))
                    .queryParam("user", user)
                    .queryParam("admin", admin)
                    .queryParam("enabled", enabled)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.updateUserInfo(this.username, passwordEncoder, oldUsername, newUsername, firstName, lastName, email, newPassword, user, admin, enabled);
    }

    @JsonIgnore
    public void switchActive() {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/switchUserActive")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.switchUserActive(this.username);
    }

    @JsonIgnore
    public void removeUser() {
        webClientUser.build()
                .delete()
                .uri(uriBuilder -> uriBuilder
                        .path("/removeUser")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.removeUser(this.username);
    }

    @JsonIgnore
    public String getListOfRolesAsStrings() {
        return webClientUser.build()
                .get()
                .uri("/user/"+ this.username + "/listOfRoles")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional()
                .orElse("");
        //        return this.userProvidesInterface.getUserListofRoleAsStrings(this.username);
    }

    @JsonIgnore
    public LocalDate getLastLogin() {
        return webClientUser.build()
                .get()
                .uri("/user/"+ this.username + "/lastLogin")
                .retrieve()
                .bodyToMono(LocalDate.class)
                .blockOptional()
                .orElse(LocalDate.now());
        //        return this.userProvidesInterface.getUserLastLogin(username);
    }

    @JsonIgnore
    public void setUserEnabled(boolean enabled) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/user/" + this.username + "/enabled")
                    .queryParam("enabled", enabled)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .blockOptional();
    }

    @JsonIgnore
    public void addRolesToUser(Role_Type roleUser) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/user/" + this.username + "/addRoles")
                        .queryParam("roleUser", roleUser)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .blockOptional();
    }

    @JsonIgnore
    public RegistrationTokenDto getToken() {
        return webClientUser.build()
                .get()
                .uri("/user/" + this.username + "/token")
                .retrieve()
                .bodyToMono(RegistrationTokenDto.class)
                .blockOptional()
                .orElse(null);
    }

    @JsonIgnore
    public String getFirstNameFromService() {
        return webClientUser.build()
                .get()
                .uri("/user/" + username + "/first")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional()
                .orElse("");
    }

    @JsonIgnore
    public String getLastNameFromService() {
        return webClientUser.build()
                .get()
                .uri("/user/" + username + "/last")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional()
                .orElse("");
    }


}


import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import org.joda.time.DateTime;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeDeserializer;
import pt.ist.socialsoftware.edition.notification.utils.Emailer;

import javax.mail.MessagingException;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.USER_SERVICE_URL;

public class RegistrationTokenDto {


    private final WebClient.Builder webClientUser = WebClient.builder().baseUrl(USER_SERVICE_URL);

    private String token;

    @JsonDeserialize(using = CustomDateTimeDeserializer.class)
    private DateTime expireTimeDateTime;

    private boolean authorized;

    public RegistrationTokenDto() {
    }

    public String getToken() {
        return this.token;
    }


    @JsonDeserialize(using = CustomDateTimeDeserializer.class)
    public DateTime getExpireTimeDateTime() {
        return expireTimeDateTime;
    }

    public boolean isAuthorized() {
        return authorized;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public void setExpireTimeDateTime(DateTime expireTimeDateTime) {
        this.expireTimeDateTime = expireTimeDateTime;
    }

    public void setAuthorized(boolean authorized) {
        this.authorized = authorized;
    }

    @JsonIgnore
    public void updateExpireTimeDateTime(int i, int i1, int i2, int i3, int i4, int i5, int i6) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                .path("/token/" + this.token + "/updateExpireTimeDateTime")
                .queryParam("i", i)
                .queryParam("i1", i1)
                .queryParam("i2", i2)
                .queryParam("i3", i3)
                .queryParam("i4", i4)
                .queryParam("i5", i5)
                        .queryParam("i6", i6)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    @JsonIgnore
    public HashMap<String, String> requestAuthorization(HttpServletRequest servletRequest, Emailer emailer) throws MessagingException {
       return webClientUser.build()
                .post()
                .uri( uriBuilder -> uriBuilder
                    .path("/requestAuthorization")
                    .queryParam("token", token)
                    .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<HashMap<String, String>>() {})
                .block();
        //        this.userProvidesInterface.requestAuthorization(this.token, servletRequest, emailer);
    }

    @JsonIgnore
    public void setTokenAuthorized(boolean authorized) {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/setAuthorized")
                    .queryParam("token", token)
                    .queryParam("authorized", authorized)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.userProvidesInterface.setAuthorized(this.token, authorized);
    }

    @JsonIgnore
    public HashMap<String, String> requestConfirmation() throws MessagingException {
       return webClientUser.build()
                .post()
                .uri( uriBuilder -> uriBuilder
                        .path("/requestConfirmation")
                        .queryParam("token", token)
                        .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<HashMap<String, String>>() {})
                .block();
        //        this.userProvidesInterface.requestConfirmation(this.token, servletRequest, emailer);
    }

    @JsonIgnore
    public UserDto getUser() {
        return webClientUser.build()
                .get()
                .uri("/registrationToken/" + this.token + "/user")
                .retrieve()
                .bodyToMono(UserDto.class)
                .blockOptional()
                .orElse(null);
        //        return this.userProvidesInterface.getUserFromRegistrationToken(this.token);
    }

    @JsonIgnore
    public void removeToken() {
        webClientUser.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeToken")
                    .queryParam("token", token)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }
}


public class VirtualEditionInterGameDto {
    private String fragmentId;
    private String title;
    private int number;
    private String urlId;
    private String text;

    public VirtualEditionInterGameDto() {
    }

    public String getFragmentId() {
        return this.fragmentId;
    }

    public void setFragmentId(String fragmentId) {
        this.fragmentId = fragmentId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getNumber() {
        return this.number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

}



public class ClassificationVirtualGameDto {
	private String gameExternalId;
	private String virtualEditionAcronym;
	private String virtualEditionTitle;
	private boolean openAnnotation;
	private long dateTime;
	private VirtualEditionInterGameDto virtualEditionInterGameDto;

	public ClassificationVirtualGameDto() {
	}

	public String getGameExternalId() {
		return this.gameExternalId;
	}

	public void setGameExternalId(String gameExternalId) {
		this.gameExternalId = gameExternalId;
	}

	public String getVirtualEditionAcronym() {
		return this.virtualEditionAcronym;
	}

	public void setVirtualEditionAcronym(String virtualEditionAcronym) {
		this.virtualEditionAcronym = virtualEditionAcronym;
	}

	public String getVirtualEditionTitle() {
		return this.virtualEditionTitle;
	}

	public void setVirtualEditionTitle(String virtualEditionTitle) {
		this.virtualEditionTitle = virtualEditionTitle;
	}

	public boolean isOpenAnnotation() {
		return this.openAnnotation;
	}

	public void setOpenAnnotation(boolean openAnnotation) {
		this.openAnnotation = openAnnotation;
	}

	public long getDateTime() {
		return this.dateTime;
	}

	public void setDateTime(long dateTime) {
		this.dateTime = dateTime;
	}

	public VirtualEditionInterGameDto getVirtualEditionInterGameDto() {
		return this.virtualEditionInterGameDto;
	}

	public void setVirtualEditionInterGameDto(VirtualEditionInterGameDto virtualEditionInterGameDto) {
		this.virtualEditionInterGameDto = virtualEditionInterGameDto;
	}

}


public class ClassificationGameParticipantDto {

    private double score;
    private String playerUsername;

    public ClassificationGameParticipantDto() {}

    public double getScore() {
        return score;
    }

    public String getPlayerUsername() {
        return playerUsername;
    }

    public void setScore(double score) {
        this.score = score;
    }

    public void setPlayerUsername(String playerUsername) {
        this.playerUsername = playerUsername;
    }

}



import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.DateTime;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeDeserializer;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeSerializer;
import pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints;

import java.util.List;

public class ClassificationGameDto {

    private final WebClient.Builder webClientGame = WebClient.builder().baseUrl(ServiceEndpoints.GAME_SERVICE_URL);

    private String editionId;
    private String interId;
    private String tagId;
    private String externalId;
    private String description;
    private String responsible;
    private boolean canBeRemoved;
    private boolean isActive;
    private DateTime dateTime;
    private boolean openAnnotation;

    public ClassificationGameDto() {}

    public String getEditionId() {
        return editionId;
    }

    public void setEditionId(String editionId) {
        this.editionId = editionId;
    }

    public String getInterId() {
        return interId;
    }

    public void setInterId(String interId) {
        this.interId = interId;
    }

    public String getTagId() {
        return tagId;
    }

    public void setTagId(String tagId) {
        this.tagId = tagId;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getResponsible() {
        return responsible;
    }

    public void setResponsible(String responsible) {
        this.responsible = responsible;
    }

    public boolean canBeRemoved() {
        return canBeRemoved;
    }

    public void setCanBeRemoved(boolean removed) {
        this.canBeRemoved = removed;
    }

    public boolean isActive() {
        return isActive;
    }

    public void setisActive(boolean active) {
        isActive = active;
    }

    @JsonDeserialize(using = CustomDateTimeDeserializer.class)
    public DateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(DateTime dateTime) {
        this.dateTime = dateTime;
    }

    public boolean getOpenAnnotation() {
        return openAnnotation;
    }

    public void setOpenAnnotation(boolean openAnnotation) {
        this.openAnnotation = openAnnotation;
    }

    @JsonIgnore
    public void remove() {
        webClientGame.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeClassificationGame")
                    .queryParam("externalId", externalId)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.gameProvidesInterface.removeClassificationGame(this.externalId);
    }

    @JsonIgnore
    public List<ClassificationGameParticipantDto> getClassificationGameParticipantSet() {
        return webClientGame.build()
                .get()
                .uri("/classificationGameParticipant/ext/" + this.externalId)
                .retrieve()
                .bodyToFlux(ClassificationGameParticipantDto.class)
                .collectList()
                .block();
        //        return this.gameProvidesInterface.getClassificationGameParticipantByExternalId(this.externalId);
    }

    @JsonIgnore
    public void addParticipant(String username) {
        webClientGame.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/classificationGame/" + this.externalId + "/addParticipant")
                    .queryParam("username", username)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }
}



public class PlayerDto {

    private String user;
    private double score;

    public PlayerDto() {}

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.DateTime;

import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeSerializer;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

public class CreateGameWrapper {

    private VirtualEditionDto VirtualEditionDto;
    private String description;
    private DateTime parse;
    private VirtualEditionInterDto inter;
    private String authenticatedUser;

    public CreateGameWrapper(VirtualEditionDto VirtualEditionDto, String description, DateTime parse, VirtualEditionInterDto inter, String authenticatedUser) {
        this.VirtualEditionDto = VirtualEditionDto;
        this.description = description;
        this.parse = parse;
        this.inter = inter;
        this.authenticatedUser = authenticatedUser;
    }

    public VirtualEditionDto getVirtualEditionDto() {
        return VirtualEditionDto;
    }

    public void setVirtualEditionDto(VirtualEditionDto VirtualEditionDto) {
        this.VirtualEditionDto = VirtualEditionDto;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @JsonSerialize(using = CustomDateTimeSerializer.class)
    public DateTime getParse() {
        return parse;
    }

    public void setParse(DateTime parse) {
        this.parse = parse;
    }

    public VirtualEditionInterDto getInter() {
        return inter;
    }

    public void setInter(VirtualEditionInterDto inter) {
        this.inter = inter;
    }

    public String getAuthenticatedUser() {
        return authenticatedUser;
    }

    public void setAuthenticatedUser(String authenticatedUser) {
        this.authenticatedUser = authenticatedUser;
    }
}




public class HeteronymDto {

    public static String NULL_NAME = "não atribuído";

    private String name;

    private String xmlId;

    private String externalId;


    public HeteronymDto() {
        super();
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public boolean isNullHeteronym() {
        return this.name.equals(NULL_NAME);
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}



public class SimpleTextDto {

    private String xmlId;
    private String externalId;


    public SimpleTextDto() {
        super();
    }

    public String getXmlId() {
        return xmlId;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}



import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class DimensionsDto {
    private final float height;
    private final float width;

    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public DimensionsDto(@JsonProperty("height") float height, @JsonProperty("width") float width) {
        this.height = height;
        this.width = width;
    }

    public float getHeight() {
        return this.height;
    }

    public float getWidth() {
        return this.width;
    }
}


import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;

import java.util.List;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;


public class ScholarInterDto {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private static final Logger logger = LoggerFactory.getLogger(ScholarInterDto.class);

    private String acronym;

    private String xmlId;

    //cached attributes
    private String externalId;
    private String title;
    private String urlId;
    private String shortName;
    private boolean isExpertInter;
    private boolean isSourceInter;
    private String reference;
    private String editionReference;
    private int number;
    private String fragXmlId;
    private String volume;
    private int startPage;
    private int endPage;
    private String completeNumber;
    private String notes;

    private LdoDDateDto ldoDDateDto;
    private HeteronymDto heteronym;
    private ExpertEditionDto expertEditionDto;
    private SourceDto sourceDto;
    private List<AnnexNoteDto> annexNoteDtos;

    public ScholarInterDto() {
        super();
    }

    public String getAcronym() {
        return acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getExternalId() {
       //return this.textProvidesInterface.getScholarInterExternalId(this.xmlId);
        return this.externalId;
    }

//    public HeteronymDto getHeteronym() {
////        return webClient.build()
////                .get()
////                .uri( "/heteronym/scholarInter/" + this.xmlId)
////                .retrieve()
////                .bodyToMono(HeteronymDto.class)
////                .blockOptional().orElse(null);
//        return this.heteronymDto;
//        //    return this.textProvidesInterface.getScholarInterHeteronym(this.xmlId);
//    }

    public FragScholarInterDto.InterType getType(){
        return isExpertInter() ? FragScholarInterDto.InterType.EDITORIAL : FragScholarInterDto.InterType.AUTHORIAL;
    }

    public String getFragmentXmlId() {
        //return this.textProvidesInterface.getFragmentOfScholarInterDto(this).getXmlId();
        return this.fragXmlId;
    }

    public String getReference() {
        //return this.textProvidesInterface.getScholarInterReference(this.xmlId);
        return this.reference;
    }

    public String getEditionReference() {
        //return this.textProvidesInterface.getScholarInterEditionReference(this.xmlId);
        return this.editionReference;
    }

    public int getNumber() {
        //return this.textProvidesInterface.getScholarInterNumber(this.xmlId);
        return this.number;
    }

    @JsonProperty(value = "isSourceInter")
    public boolean isSourceInter() {
        //return !this.textProvidesInterface.isExpertInter(this.xmlId);
        return this.isSourceInter;
    }

    @JsonProperty(value = "isExpertInter")
    public boolean isExpertInter() {
        //return !this.textProvidesInterface.isExpertInter(this.xmlId);
        return this.isExpertInter;
    }


    @JsonIgnore
    public String getExpertEditionAcronym() {
        return  webClient.build()
                .get()
                .uri("/expertEdition/" + this.xmlId + "/acronym")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().orElse("");
        //  return this.textProvidesInterface.getExpertEditionAcronym(this.xmlId);
    }

    @JsonIgnore
    public int getNumberOfTimesCited() {
        return  webClient.build()
                .get()
                .uri("/scholarEdition/" + this.xmlId + "/citednumber")
                .retrieve()
                .bodyToMono(Integer.class)
                .blockOptional().orElse(0);
        //return this.textProvidesInterface.getNumberOfTimesCited(this.xmlId);
    }

    @JsonIgnore
    public int getNumberOfTimesCitedIncludingRetweets() {
        return  webClient.build()
                .get()
                .uri("/scholarEdition/" + this.xmlId + "/citednumberPlusretweets")
                .retrieve()
                .bodyToMono(Integer.class)
                .blockOptional().orElse(0);
        //    return this.textProvidesInterface.getNumberOfTimesCitedIncludingRetweets(this.xmlId);
    }


    @JsonIgnore
    public FragmentDto getFragmentDto() {
        return webClient.build()
                .get()
                .uri("/scholarInter/fragment/" + this.xmlId)
                .retrieve()
                .bodyToMono(FragmentDto.class)
                .blockOptional().orElse(null);
        //   return this.textProvidesInterface.getFragmentOfScholarInterDto(this);
    }

    public String getTitle() {
        //return this.textProvidesInterface.getScholarInterTitle(this.xmlId);
        return this.title;
    }

    public String getUrlId() {
        //return this.textProvidesInterface.getScholarInterUrlId(this.xmlId);
        return this.urlId;
    }

    public String getShortName() {
        //return this.textProvidesInterface.getScholarInterShortName(this.xmlId);
        return this.shortName;
    }

    public String getVolume() {
        //return this.textProvidesInterface.getExpertEditionInterVolume(this.xmlId);
        return this.volume;
    }

    public String getCompleteNumber() {
        //return this.textProvidesInterface.getExpertInterCompleteNumber(this.xmlId);
        return this.completeNumber;
    }

    public int getStartPage() {
        //return this.textProvidesInterface.getExpertEditionInterStartPage(this.xmlId);
        return this.startPage;
    }

    public int getEndPage() {
        //return this.textProvidesInterface.getExpertEditionInterEndPage(this.xmlId);
        return this.endPage;
    }

    public String getNotes() {
        //return this.textProvidesInterface.getExpertEditionInterNotes(this.xmlId);
        return this.notes;
    }

    @JsonIgnore
    public void remove() {
        webClient.build()
                .post()
                .uri("/scholarInter/" + this.xmlId + "/remove")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }


    @JsonIgnore
    public String getTranscription() {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + this.xmlId + "/transcription")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
        //    return this.textProvidesInterface.getScholarInterTranscription(this.xmlId);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ScholarInterDto other = (ScholarInterDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @JsonIgnore
    public ScholarInterDto getNextScholarInter() {
        return  webClient.build()
                .get()
                .uri("/scholarInter/" + this.xmlId + "/next")
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().get();
        //    return this.textProvidesInterface.getScholarInterNextNumberInter(this.xmlId);
    }


    @JsonIgnore
    public ScholarInterDto getPrevScholarInter() {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + this.xmlId + "/prev")
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().get();
        //    return this.textProvidesInterface.getScholarInterPrevNumberInter(this.xmlId);
    }

    @JsonIgnore
    public ScholarInterDto getNextNumberInter() {
       return webClient.build()
                .get()
                .uri("/scholarInter/" + this.xmlId + "/next")
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().get();
        //  return this.textProvidesInterface.getScholarInterNextNumberInter(this.xmlId);
    }

    @JsonIgnore
    public ScholarInterDto getPrevNumberInter() {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + this.xmlId + "/prev")
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().get();
    }

    @JsonIgnore
    public String getExpertTranscription(boolean diff) {
        return  webClient.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/expertInter/" + this.xmlId + "/transcription")
                        .queryParam("diff", diff)
                        .build()
                )
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
        //   return this.textProvidesInterface.getExpertInterTranscription(this.xmlId, diff);
    }

    @JsonIgnore
    public String getSourceTranscription(boolean diff, boolean del, boolean ins,
                                         boolean subst, boolean notes) {
    return  webClient.build()
            .get()
            .uri(uriBuilder -> uriBuilder
                    .path("/sourceInter/" + this.xmlId + "/transcription")
                    .queryParam("diff", diff)
                    .queryParam("del", del)
                    .queryParam("ins", ins)
                    .queryParam("subst", subst)
                    .queryParam("notes", notes)
                    .build()
            )
            .retrieve()
            .bodyToMono(String.class)
            .blockOptional().get();
        //    return this.textProvidesInterface.getSourceInterTranscription(this.xmlId, diff, del, ins, subst, notes);
    }


    public LdoDDateDto getLdoDDate() {
        return ldoDDateDto;
    }

    public HeteronymDto getHeteronym() {
        return heteronym;
    }

    public ExpertEditionDto getExpertEdition() {
        return expertEditionDto;
    }

    public SourceDto getSourceDto() {
        return sourceDto;
    }

    public List<AnnexNoteDto> getSortedAnnexNote() {
        return annexNoteDtos;
    }

    public void setLdoDDate(LdoDDateDto ldoDDateDto) {
        this.ldoDDateDto = ldoDDateDto;
    }

    public void setHeteronym(HeteronymDto heteronymDto) {
        this.heteronym = heteronymDto;
    }

    public void setExpertEdition(ExpertEditionDto expertEditionDto) {
        this.expertEditionDto = expertEditionDto;
    }

    public void setSourceDto(SourceDto sourceDto) {
        this.sourceDto = sourceDto;
    }

    public void setSortedAnnexNote(List<AnnexNoteDto> annexNoteDtos) {
        this.annexNoteDtos = annexNoteDtos;
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public void setisExpertInter(boolean expertInter) {
        isExpertInter = expertInter;
    }

    public void setisSourceInter(boolean sourceInter) {
        isSourceInter = sourceInter;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public void setEditionReference(String editionReference) {
        this.editionReference = editionReference;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public void setFragmentXmlId(String fragXmlId) {
        this.fragXmlId = fragXmlId;
    }

    public void setVolume(String volume) {
        this.volume = volume;
    }

    public void setStartPage(int startPage) {
        this.startPage = startPage;
    }

    public void setEndPage(int endPage) {
        this.endPage = endPage;
    }

    public void setCompleteNumber(String completeNumber) {
        this.completeNumber = completeNumber;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }



}




import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;

public class FragmentDto {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private String xmlId;

    //cached attributes
    private String title;
    private String externalId;

    private Set<SourceDto> embeddedSourceDtos = new HashSet<>(  );

    private Set<ScholarInterDto> embeddedScholarInterDtos = new HashSet<>();

    public FragmentDto() { super(); }


    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public Set<SourceDto> getEmbeddedSourceDtos() {
        return embeddedSourceDtos;
    }

    public void setEmbeddedSourceDtos(Set<SourceDto> embeddedSourceDtos) {
        this.embeddedSourceDtos = embeddedSourceDtos;
    }

    public Set<ScholarInterDto> getEmbeddedScholarInterDtos() {
        return embeddedScholarInterDtos;
    }

    public void setEmbeddedScholarInterDtos(Set<ScholarInterDto> embeddedScholarInterDtos) {
        this.embeddedScholarInterDtos = embeddedScholarInterDtos;
    }

    public String getTitle() {
        //return this.textProvidesInterface.getFragmentTitle(getXmlId());
        return this.title;
    }

    @JsonIgnore
    public Set<ScholarInterDto> getScholarInterDtoSet() {
        return webClient.build().get()
                .uri("/fragment/" + getXmlId() + "/scholarInters")
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //    return this.textProvidesInterface.getScholarInterDto4FragmentXmlId(getXmlId());
    }

    @JsonIgnore
    public Set<ScholarInterDto> getEmbeddedScholarInterDtoSetForExpertEdition(String acronym) {
        return this.embeddedScholarInterDtos.stream()
                .filter(scholarInterDto -> scholarInterDto.getAcronym().equals(acronym)).collect(Collectors.toSet());
    }


    @JsonIgnore
    public List<ScholarInterDto> getSortedSourceInter() {
        return webClient.build()
                .get()
                .uri("/fragment/" + getXmlId() + "/sortedSourceInter")
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
        //   return this.textProvidesInterface.getFragmentSortedSourceInter(this.xmlId);
    }

    @JsonIgnore
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    public List<ScholarInterDto> getEmbeddedSourceInter() {
        return this.embeddedScholarInterDtos.stream()
                .filter(scholarInterDto -> scholarInterDto.isSourceInter()).collect(Collectors.toList());
    }

    @JsonIgnore
    public ScholarInterDto getScholarInterByXmlId(String xmlId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/" + xmlId)
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .block();
        //    return this.textProvidesInterface.getScholarInter(xmlId);
    }

    // Only necessary due to manual ordering of virtual edition javascript code
    public String getExternalId() {
        //return this.textProvidesInterface.getFragmentExternalId(getXmlId());
        return this.externalId;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FragmentDto other = (FragmentDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }


    @JsonIgnore
    public Set<CitationDto> getCitationSet() {
        return webClient.build()
                .get()
                .uri( "/fragment/citations/" + this.xmlId)
                .retrieve()
                .bodyToFlux(CitationDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //    return this.textProvidesInterface.getFragmentCitationSet(this.xmlId);
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    @JsonIgnore
    public Set<SourceDto> getSourcesSet() {
        return webClient.build()
                .get()
                .uri("/fragment/" + this.xmlId + "/sources")
                .retrieve()
                .bodyToFlux(SourceDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //   return this.textProvidesInterface.getFragmentSourceSet(this.xmlId);
    }

    @JsonIgnore
    public ScholarInterDto getScholarInterDtoByUrlId(String urlId) {
        return webClient.build().get()
                .uri( uriBuilder -> uriBuilder
                        .path("/fragment/" + getXmlId() + "/scholarInter")
                        .queryParam("urlId", urlId)
                        .build())
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .block();
        // return this.textProvidesInterface.getScholarInterDtoByFragmentXmlIdAndUrlId(getXmlId(), urlId);
    }

    @JsonIgnore
    public ScholarInterDto getScholarInterByUrlId(String urlId) {
        return webClient.build()
                .get()
                .uri("/fragment/" + getXmlId() + "/" + urlId + "/scholarInter")
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .block();
        //    return this.textProvidesInterface.getFragmentScholarInterByUrlId(this.xmlId, urlId);
    }


    @JsonIgnore
    public Set<ScholarInterDto> getScholarInterDtoSetForExpertEdtion(String acronym) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/fragment/" + getXmlId() + "/scholarInters4Expert")
                        .queryParam("acronym", acronym)
                        .build())
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
    //    return this.textProvidesInterface.getFragmentScholarInterDtoSetForExpertEdtion(getXmlId(), acronym);
    }


    @JsonIgnore
    public String getRepresentativeSourceInterExternalId() {
        return webClient.build()
                .get()
                .uri( "/representativeSourceInter/" + this.xmlId + "/externalId")
                .retrieve()
                .bodyToMono(String.class)
                .block();
    }

    @Override
    public String toString() {
        return xmlId;
    }

}



public class FragScholarInterDto {

    public enum InterType {
        AUTHORIAL("authorial"), EDITORIAL("editorial"), VIRTUAL("virtual");

        private final String desc;

        InterType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    private InterType type;
    private String fragmentXmlId;
    private String urlId;
    private String shortName;
    private String externalId;



    public FragScholarInterDto() {
        super();
    }

    public InterType getType() {
        return this.type;
    }

    public void setType(InterType type) {
        this.type = type;
    }

    public String getFragmentXmlId() {
        return this.fragmentXmlId;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getExternalId() {
        return this.externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

}



public class ExpertEditionInterListDto {

    private String title;
    private String acronym;
    private String type;
    private boolean pub;
    private int numberOfInters;



    public ExpertEditionInterListDto() {
        super();
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public boolean isPub() {
        return this.pub;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public int getNumberOfInters() {
        return this.numberOfInters;
    }

    public void setNumberOfInters(int numberOfInters) {
        this.numberOfInters = numberOfInters;
    }

    public String getType() {
        return this.type;
    }

    public void setType(String type) {
        this.type = type;
    }

}




public class SurfaceDto {

    private String xmlId;

    private String graphic;


    public SurfaceDto() {
        super();
    }

    public String getXmlId() {
        return xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getGraphic() {
        return graphic;
    }

    public void setGraphic(String graphic) {
        this.graphic = graphic;
    }
}




public class AnnexNoteDto {

    private int number;

    private String text;

    public AnnexNoteDto() {
        super();
    }


    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}





import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;

public class CitationDto {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private long id;
    private String externalId;
    private String date;
    private String fragmentXmlId;
    private String fragmentTitle;
    private String sourceLink;
    private boolean hasNoInfoRange;

    public CitationDto() {
        super();
    }

    public long getId() {
        return id;
    }

    public boolean isTwitterCitation() {
        return false;
    }

    public String getExternalId() {
        return externalId;
    }

    public String getDate() {
        return date;
    }

    public String getFragmentXmlId() {
        return fragmentXmlId;
    }

    public String getFragmentTitle() {
        return fragmentTitle;
    }

    public String getSourceLink() {
        return sourceLink;
    }

    public boolean isHasNoInfoRange() {
        return hasNoInfoRange;
    }

    @JsonIgnore
    public LocalDateTime getFormatedDate() {
        DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
        return LocalDateTime.parse(getDate(), formater);
    }

    @JsonIgnore
    public void remove() {
        webClient.build()
                .delete()
                .uri("/removeAllCitations")
                .retrieve()
                .bodyToMono(Void.class)
                .block();    }

    @JsonIgnore
    public int getNumberOfTimesCited() {
        return webClient.build()
                .get()
                .uri("/citation/" + id + "/infoRange")
                .retrieve()
                .bodyToFlux(InfoRangeDto.class)
                .toStream()
                .collect(Collectors.toSet()).size();
    }

    public void setId(long id) {
        this.id = id;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public void setFragmentTitle(String fragmentTitle) {
        this.fragmentTitle = fragmentTitle;
    }

    public void setSourceLink(String sourceLink) {
        this.sourceLink = sourceLink;
    }

    public void setHasNoInfoRange(boolean hasNoInfoRange) {
        this.hasNoInfoRange = hasNoInfoRange;
    }
}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;

public class ExpertEditionDto {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private final String acronym;

    // cached attributes
    private String editor;
    private String externalId;
    private String author;
    private String title;



    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public ExpertEditionDto(@JsonProperty("acronym") String acronym) {
        this.acronym = acronym;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getEditor() {
        //return this.textProvidesInterface.getExpertEditionEditorByEditionAcronym(this.acronym);
        return this.editor;
    }

    public String getExternalId() {
        return externalId;
    }

    public boolean isExpertEdition() {
        return true;
    }

    public boolean isVirtualEdition() {
        return false;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    @JsonIgnore
     public List<ScholarInterDto> getExpertEditionInters() {
        return webClient.build()
                .get()
                .uri("/expertEdition/" + this.acronym + "/scholarInterList")
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
        //    return this.textProvidesInterface.getExpertEditionScholarInterDtoList(this.acronym);
    }

    @JsonIgnore
    public List<ScholarInterDto> getSortedInter4Frag(String fragmentXmlId) {
        return webClient.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/fragment/" + fragmentXmlId + "/expertEditionSortedInter")
                        .queryParam("acronym", this.acronym)
                        .build()
                )
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
        //  return this.textProvidesInterface.getExpertEditionSortedInter4Frag(this.acronym, fragmentXmlId);
    }

    public void setEditor(String editor) {
        this.editor = editor;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}



import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.enums.Form;
import pt.ist.socialsoftware.edition.notification.enums.Material;
import pt.ist.socialsoftware.edition.notification.enums.SourceType;

import java.util.AbstractMap;
import java.util.List;
import java.util.Set;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;


public class SourceDto {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private String xmlId;

    //cached attributes
    private String name;
    private SourceType type;
    private String title;
    private String idno;
    private String altIdentifier;
    private String journal;
    private String issue;
    private String pubPlace;
    private String notes;
    private int startPage;
    private int endPage;
    private Material material;
    private Form form;
    private int columns;
    private boolean ldoDLabel;
    private boolean hasHandNoteSet;
    private boolean hasTypeNoteSet;

    private LdoDDateDto ldoDDate;
    private Set<ManuscriptNote> handNoteSet;
    private Set<ManuscriptNote> typeNoteSet;
    private List<SurfaceDto> surfaces;
    private List<DimensionsDto> sortedDimensionsDto;
    private Set<ScholarInterDto> sourceInters;




    public SourceDto() {
        super();
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getName(){
        return this.name;
    }

    public String getTitle() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(printedSource -> printedSource.getTitle())
                .orElseThrow(LdoDException::new);*/
        return this.title;
    }

    public String getIdno() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getIdno)
                .orElse(null);*/
        return this.idno;
    }

    public Material getMaterial() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getMaterial)
                .orElseThrow(LdoDException::new);*/
        return this.material;
    }


    public int getColumns() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getColumns)
                .orElseThrow(LdoDException::new);*/
       return this.columns;
    }

    public String getJournal() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getJournal)
                .orElse(null);*/
       return this.journal;
    }

    public String getIssue() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getIssue)
                .orElse(null);*/
        return this.issue;
    }

    public String getAltIdentifier() {
       /* return getSourceByXmlId(this.xmlId)
                .map(Source::getAltIdentifier)
                .orElse(null);*/
       return this.altIdentifier;
    }

    public String getNotes() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getNotes)
                .orElse(null);*/
        return this.notes;
    }

    public int getStartPage() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getStartPage)
                .orElseThrow(LdoDException::new);*/
        return this.startPage;
    }

    public int getEndPage() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getEndPage)
                .orElseThrow(LdoDException::new);*/
        return this.endPage;
    }

    public String getPubPlace() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(PrintedSource.class::isInstance)
                .map(PrintedSource.class::cast)
                .map(PrintedSource::getPubPlace)
                .orElse(null);*/
       return this.pubPlace;
    }

    public boolean getHasLdoDLabel() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getHasLdoDLabel)
                .orElseThrow(LdoDException::new);*/
        return this.ldoDLabel;
    }

    public boolean hasHandNoteSet() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(manuscriptSource -> !manuscriptSource.getHandNoteSet().isEmpty())
                .orElseThrow(LdoDException::new);*/
       return this.hasHandNoteSet;
    }

    public boolean hasTypeNoteSet() {
        /*return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(manuscriptSource -> !manuscriptSource.getTypeNoteSet().isEmpty())
                .orElseThrow(LdoDException::new);*/
        return this.hasTypeNoteSet;
    }

    public SourceType getType() {
        //return getSourceByXmlId(this.xmlId).map(source -> source.getType()).orElse(null);
        return this.type;
    }


    public Form getForm() {
       /* return getSourceByXmlId(this.xmlId)
                .filter(ManuscriptSource.class::isInstance)
                .map(ManuscriptSource.class::cast)
                .map(ManuscriptSource::getForm)
                .orElse(null);*/
       return this.form;
    }

    @JsonIgnore
    public String getRepository() {
        return  webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/repository")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
    }

    @JsonIgnore
    public HeteronymDto getHeteronym() {
        return webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/heteronym")
                .retrieve()
                .bodyToMono(HeteronymDto.class)
                .blockOptional().get();
        //   return this.textProvidesInterface.getHeteronym(this.xmlId);
    }

    @JsonIgnore
    public String getFormattedDimensions() {
        return  webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/formattedDimensions")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
        //   return this.textProvidesInterface.getFormattedDimensions(this.xmlId);
    }


    @JsonIgnore
    public List<AbstractMap.SimpleEntry<String, String>> getFormattedHandNote() {
        return webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/formattedHandNotes")
                .retrieve()
                .bodyToFlux(new ParameterizedTypeReference<AbstractMap.SimpleEntry<String, String>>() {})
                .collectSortedList()
                .block();
        //    return this.textProvidesInterface.getFormattedHandNote(this.xmlId);
    }


    @JsonIgnore
    public List<AbstractMap.SimpleEntry<String, String>> getFormattedTypeNote() {
        return webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/formattedTypeNotes")
                .retrieve()
                .bodyToFlux(new ParameterizedTypeReference<AbstractMap.SimpleEntry<String, String>>() {})
                .collectSortedList()
                .block();
        //  return this.textProvidesInterface.getFormattedTypeNote(this.xmlId);
    }

    @JsonIgnore
    public String getSettlement() {
        return  webClient.build()
                .get()
                .uri("/source/" + this.xmlId + "/settlement")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
    }


    public LdoDDateDto getLdoDDate() {
        return ldoDDate;
    }

    public Set<ManuscriptNote> getHandNoteSet() {
        return handNoteSet;
    }

    public Set<ManuscriptNote> getTypeNoteSet() {
        return typeNoteSet;
    }

    public List<SurfaceDto> getSurfaces() {
        return surfaces;
    }

    public List<DimensionsDto> getSortedDimensionsDto() {
        return sortedDimensionsDto;
    }

    public Set<ScholarInterDto> getSourceIntersSet() {
        return sourceInters;
    }

    public void setLdoDDate(LdoDDateDto ldoDDate) {
        this.ldoDDate = ldoDDate;
    }

    public void setSurfaces(List<SurfaceDto> surfaces) {
        this.surfaces = surfaces;
    }

    public void setSortedDimensionsDto(List<DimensionsDto> sortedDimensionsDto) {
        this.sortedDimensionsDto = sortedDimensionsDto;
    }

    public void setSourceIntersSet(Set<ScholarInterDto> sourceInters) {
        this.sourceInters = sourceInters;
    }

    public void setHandNoteSet(Set<ManuscriptNote> handNoteSet) {
        this.handNoteSet = handNoteSet;
    }

    public void setTypeNoteSet(Set<ManuscriptNote> typeNoteSet) {
        this.typeNoteSet = typeNoteSet;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setType(SourceType type) {
        this.type = type;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setIdno(String idno) {
        this.idno = idno;
    }

    public void setAltIdentifier(String altIdentifier) {
        this.altIdentifier = altIdentifier;
    }

    public void setJournal(String journal) {
        this.journal = journal;
    }

    public void setIssue(String issue) {
        this.issue = issue;
    }

    public void setPubPlace(String pubPlace) {
        this.pubPlace = pubPlace;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public void setStartPage(int startPage) {
        this.startPage = startPage;
    }

    public void setEndPage(int endPage) {
        this.endPage = endPage;
    }

    public void setMaterial(Material material) {
        this.material = material;
    }

    public void setForm(Form form) {
        this.form = form;
    }

    public void setColumns(int columns) {
        this.columns = columns;
    }

    public void setLdoDLabel(boolean ldoDLabel) {
        this.ldoDLabel = ldoDLabel;
    }

    public void setHasHandNoteSet(boolean hasHandNoteSet) {
        this.hasHandNoteSet = hasHandNoteSet;
    }

    public void setHasTypeNoteSet(boolean hasTypeNoteSet) {
        this.hasTypeNoteSet = hasTypeNoteSet;
    }

}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.notification.enums.Medium;

public class ManuscriptNote {
    private final Medium medium;
    private final String note;



    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public ManuscriptNote(@JsonProperty("medium") Medium medium, @JsonProperty("note") String note) {
        this.medium = medium;
        this.note = note;
    }

    public Medium getMedium() {
        return this.medium;
    }

    public String getNote() {
        return this.note;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.LocalDate;
import pt.ist.socialsoftware.edition.notification.config.CustomDateTimeDeserializer;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateDeserializer;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateSerializer;
import pt.ist.socialsoftware.edition.notification.enums.PrecisionType;


public class LdoDDateDto {

    public  enum DateType {
        YEAR, MONTH, DAY
    }

    private DateType type;
    private LocalDate date;
    private PrecisionType precisionType;



    public LdoDDateDto() {
        super();
    }

    public String print() {
        switch (getType()) {
            case YEAR:
                return getDate().toString("yyyy");
            case DAY:
                return getDate().toString("dd-MM-yyyy");
            case MONTH:
                return getDate().toString("MM-yyyy");
            default:
                return "";
        }
    }

    public DateType getType() {
        return this.type;
    }

    public void setType(DateType type) {
        this.type = type;
    }

    @JsonDeserialize(using = CustomLocalDateDeserializer.class)
    @JsonSerialize(using = CustomLocalDateSerializer.class)
    public LocalDate getDate() {
        return this.date;
    }

    public void setDate(LocalDate date) {
        this.date = date;
    }

    public PrecisionType getPrecision() {
        return precisionType;
    }

    public void setPrecision(PrecisionType precisionType) {
        this.precisionType = precisionType;
    }
}



public class InfoRangeDto {

    private String externalId;
    private String scholarInterid;
    private String start;
    private String end;
    private String quote;
    private String text;
    private int startOffset;
    private int endOffset;



    public InfoRangeDto() {
        super();
    }

    public String getExternalId() {
        return externalId;
    }

    public String getScholarInterid() {
        return scholarInterid;
    }

    public String getStart() {
        return start;
    }

    public String getEnd() {
        return end;
    }

    public String getText() {
        return text;
    }

    public String getQuote() {
        return quote;
    }

    public int getStartOffset() {
        return startOffset;
    }

    public int getEndOffset() {
        return endOffset;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setScholarInterid(String scholarInterid) {
        this.scholarInterid = scholarInterid;
    }

    public void setStart(String start) {
        this.start = start;
    }

    public void setEnd(String end) {
        this.end = end;
    }

    public void setQuote(String quote) {
        this.quote = quote;
    }

    public void setText(String text) {
        this.text = text;
    }

    public void setStartOffset(int startOffset) {
        this.startOffset = startOffset;
    }

    public void setEndOffset(int endOffset) {
        this.endOffset = endOffset;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class AdvancedSearchResultDto {
    private final boolean showEdition;
    private final boolean showHeteronym;
    private final boolean showDate;
    private final boolean showLdoD;
    private final boolean showSource;
    private final boolean showSourceType;
    private final boolean showTaxonomy;
    private final int fragCount;
    private final int interCount;
    private final int fragCountNotAdded;
    private final int interCountNotAdded;
    private Map<String, Map<String, List<String>>> results;

//    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public AdvancedSearchResultDto(@JsonProperty("showEdition") boolean showEdition, @JsonProperty("showHeteronym") boolean showHeteronym, @JsonProperty("showDate") boolean showDate, @JsonProperty("showLdoD") boolean showLdoD,
                                   @JsonProperty("showSource") boolean showSource, @JsonProperty("showSourceType") boolean showSourceType, @JsonProperty("showTaxonomy") boolean showTaxonomy, @JsonProperty("fragCount") int fragCount,
                                   @JsonProperty("interCount") int interCount, @JsonProperty("fragCountNotAdded") int fragCountNotAdded,
                                   @JsonProperty("interCountNotAdded") int interCountNotAdded, @JsonProperty("results") Map<String, Map<String,  List<String>>> results) {
        this.showEdition = showEdition;
        this.showHeteronym = showHeteronym;
        this.showDate = showDate;
        this.showLdoD = showLdoD;
        this.showSource = showSource;
        this.showSourceType = showSourceType;
        this.showTaxonomy = showTaxonomy;
        this.fragCount = fragCount;
        this.interCount = interCount;
        this.fragCountNotAdded = fragCountNotAdded;
        this.interCountNotAdded = interCountNotAdded;
        this.results = results;
    }



    public boolean isShowEdition() {
        return this.showEdition;
    }

    public boolean isShowHeteronym() {
        return this.showHeteronym;
    }

    public boolean isShowDate() {
        return this.showDate;
    }

    public boolean isShowLdoD() {
        return this.showLdoD;
    }

    public boolean isShowSource() {
        return this.showSource;
    }

    public boolean isShowSourceType() {
        return this.showSourceType;
    }

    public boolean isShowTaxonomy() {
        return this.showTaxonomy;
    }

    public int getFragCount() {
        return this.fragCount;
    }

    public int getInterCount() {
        return this.interCount;
    }

    public int getFragCountNotAdded() {
        return this.fragCountNotAdded;
    }

    public int getInterCountNotAdded() {
        return this.interCountNotAdded;
    }

    public Map<String, Map<String, List<String>>> getResults() {
        return this.results;
    }

    public Map<String, Map<SearchableElementDto, List<String>>> convert() {
        ObjectReader objectMapper = new ObjectMapper().readerFor(SearchableElementDto.class);

        Map<String, Map<SearchableElementDto, List<String>>> test = results.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, ev -> ev.getValue().entrySet().stream()
                .collect(Collectors.toMap(stringListEntry -> {
                    try {
                        return objectMapper.readValue(stringListEntry.getKey());
                    } catch (JsonProcessingException e) {
                        e.printStackTrace();
                    }
                    return null;
                }, ev2 -> ev2.getValue()))));
        return test;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;

public final class ManuscriptSearchOptionDto extends AuthoralSearchOptionDto {
    public static final String MANUSCRIPTID = "manus";

    public ManuscriptSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                     @JsonProperty("date") DateSearchOptionDto date) {
        super(hasLdoD, date);
    }

}


import java.util.Map;

public class ExpertEditionForSearchDto {

    private String editor;
    private final String acronym;
    private Map<String, String> heteronyms;
    private String beginDate;
    private String endDate;

    public ExpertEditionForSearchDto(String acronym) {
        this.acronym = acronym;
    }

    public String getEditor() {
        return this.editor;
    }

    public void setEditor(String editor) {
        this.editor = editor;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getBeginDate() {
        return this.beginDate;
    }

    public void setBeginDate(int i) {
        this.beginDate = Integer.toString(i);
    }

    public String getEndDate() {
        return this.endDate;
    }

    public void setEndDate(int i) {
        this.endDate = Integer.toString(i);
    }

    public Map<String, String> getHeteronyms() {
        return this.heteronyms;
    }

    public void setHeteronyms(Map<String, String> heteronyms) {
        this.heteronyms = heteronyms;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

public final class TypescriptSearchOptionDto extends AuthoralSearchOptionDto {
    public static final String TYPESCRIPT = "datil";

    public TypescriptSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                     @JsonProperty("date") DateSearchOptionDto date) {
        super(hasLdoD, date);
    }


}

public class SearchableElementDto {
    public enum Type {
        SCHOLAR_INTER,
        VIRTUAL_INTER
    }

    private Type type;

    private String xmlId;

    private String title;

    private String fragmentXmlId;

    private String urlId;

    private String shortName;

    private String lastUsedId;

    public SearchableElementDto(Type type, String xmlId, String title, String fragmentXmlId, String urlId, String shortName, String lastUsedId) {
        this.type = type;
        this.xmlId = xmlId;
        this.title = title;
        this.fragmentXmlId = fragmentXmlId;
        this.urlId = urlId;
        this.shortName = shortName;
        this.lastUsedId = lastUsedId;
    }

    public SearchableElementDto() {}

    public Type getType() {
        return this.type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getFragmentXmlId() {
        return this.fragmentXmlId;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getLastUsedId() {
        return this.lastUsedId;
    }

    public void setLastUsedId(String lastUsedId) {
        this.lastUsedId = lastUsedId;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

public class TaxonomySearchOptionDto extends SearchOptionDto {
    private final String[] tags;

    public TaxonomySearchOptionDto(@JsonProperty("tags") String tags) {
        this.tags = tags.trim().split("\\s+");
    }


    public String[] getTags() {
        return this.tags;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class TextSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(TextSearchOptionDto.class);

    private final String text;

    public TextSearchOptionDto(@JsonProperty("text") String text) {
        text = purgeSearchText(text);
        text = QueryParser.escape(text);
        this.text = text.equals("null") || text.equals("") ? null : text.trim();
    }

    public static String purgeSearchText(String text) {
        text = text.replaceAll("[^\\p{L}0-9\\-\\s]+", "");
        return text;
    }


    public String getText() {
        return this.text;
    }

}


import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
@JsonSubTypes({@Type(value = EditionSearchOptionDto.class, name = SearchOptionDto.EDITION),
        @Type(value = ManuscriptSearchOptionDto.class, name = SearchOptionDto.MANUSCRIPT),
        @Type(value = TypescriptSearchOptionDto.class, name = SearchOptionDto.DACTILOSCRIPT),
        @Type(value = PublicationSearchOptionDto.class, name = SearchOptionDto.PUBLICATION),
        @Type(value = HeteronymSearchOptionDto.class, name = SearchOptionDto.HETERONYM),
        @Type(value = DateSearchOptionDto.class, name = SearchOptionDto.DATE),
        @Type(value = TaxonomySearchOptionDto.class, name = SearchOptionDto.TAXONOMY),
        @Type(value = TextSearchOptionDto.class, name = SearchOptionDto.TEXT),
        @Type(value = VirtualEditionSearchOptionDto.class, name = SearchOptionDto.VIRTUALEDITION)})
public abstract class SearchOptionDto {
    /* Json Properties */
    public static final String EDITION = "edition";
    public static final String MANUSCRIPT = "manuscript";
    public static final String DACTILOSCRIPT = "dactiloscript";
    public static final String PUBLICATION = "publication";
    public static final String HETERONYM = "heteronym";
    public static final String DATE = "date";
    public static final String TEXT = "text";
    public static final String TAXONOMY = "taxonomy";
    public static final String VIRTUALEDITION = "virtualedition";


//    public abstract SearchOption createSearchOption();

}

import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.notification.enums.Mode;


public class SearchDto {
    private final Mode mode;
    private final SearchOptionDto[] searchOptions;

    public SearchDto(@JsonProperty("mode") String mode, @JsonProperty("options") SearchOptionDto[] searchOptions) {
        this.mode = mode.equals(Mode.AND.getMode()) ? Mode.AND : Mode.OR;
        this.searchOptions = searchOptions;
    }

    public Mode getMode() {
        return this.mode;
    }

    public SearchOptionDto[] getSearchOptions() {
        return this.searchOptions;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;

public final class PublicationSearchOptionDto extends SearchOptionDto {

    private final DateSearchOptionDto dateSearchOption;

    public PublicationSearchOptionDto(@JsonProperty("date") DateSearchOptionDto date) {
        this.dateSearchOption = date;
    }


    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }
}

import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.notification.enums.Dated;


public final class DateSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(DateSearchOptionDto.class);


    private final Dated dated;
    private int begin;
    private int end;

    public DateSearchOptionDto(@JsonProperty("option") String dated, @JsonProperty("begin") String begin,
                               @JsonProperty("end") String end) {
        logger.debug("DateSearchOption dated: {}, begin:{}, end:{}", dated, begin, end);

        if (Dated.DATED.getDated().equals(dated)) {
            this.dated = Dated.DATED;
            this.begin = begin == null ? 1911 : Integer.parseInt(begin);
            this.end = end == null ? 1935 : Integer.parseInt(end);
        } else if (Dated.UNDATED.getDated().equals(dated)) {
            this.dated = Dated.UNDATED;
        } else {
            this.dated = Dated.ALL;
        }

        logger.debug("DateSearchOption dated: {}, begin:{}, end:{}", this.dated, this.begin, this.end);

    }

    public Dated getDated() {
        return this.dated;
    }

    public int getBegin() {
        return this.begin;
    }

    public int getEnd() {
        return this.end;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

public final class VirtualEditionSearchOptionDto extends SearchOptionDto {

    private final String virtualEditionAcronym;
    private final boolean inclusion;
    private  String username;


    public VirtualEditionSearchOptionDto(@JsonProperty("inclusion") String inclusion,
                                         @JsonProperty("edition") String virtualEditionAcronym) {
        if (inclusion.equals("in")) {
            this.inclusion = true;
        } else {
            this.inclusion = false;
        }
        this.virtualEditionAcronym = virtualEditionAcronym;

    }

//    @Override
//    public VirtualEditionSearchOption createSearchOption() {
//        return new VirtualEditionSearchOption(this);
//    }

    public String getVirtualEditionAcronym() {
        return this.virtualEditionAcronym;
    }

    public boolean isInclusion() {
        return this.inclusion;
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) { this.username = username; }



}


public class DatesForSearchDto {
    private String beginDate;
    private String endDate;

    public String getBeginDate() {
        return this.beginDate;
    }

    public void setBeginDate(int i) {
        this.beginDate = Integer.toString(i);
    }

    public String getEndDate() {
        return this.endDate;
    }

    public void setEndDate(int i) {
        this.endDate = Integer.toString(i);
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

public abstract class AuthoralSearchOptionDto extends SearchOptionDto {

    private final String hasLdoD;
    private final DateSearchOptionDto dateSearchOption;

    public AuthoralSearchOptionDto(@JsonProperty("hasLdoDMark") String hasLdoD,
                                   @JsonProperty("date") DateSearchOptionDto date) {
        this.hasLdoD = hasLdoD;
        this.dateSearchOption = date;
    }

    public String getHasLdoD() {
        return this.hasLdoD;
    }

    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }

}


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public final class EditionSearchOptionDto extends SearchOptionDto {

    private final boolean inclusion;
    private final String edition;
    private final HeteronymSearchOptionDto heteronymSearchOption;
    private final DateSearchOptionDto dateSearchOption;

    @JsonCreator
    public EditionSearchOptionDto(@JsonProperty("inclusion") String inclusion, @JsonProperty("edition") String edition,
                                  @JsonProperty("heteronym") HeteronymSearchOptionDto heteronym, @JsonProperty("date") DateSearchOptionDto date) {

        if (inclusion.equals("in")) {
            this.inclusion = true;
        } else {
            this.inclusion = false;
        }

        this.edition = edition;
        this.heteronymSearchOption = heteronym;
        this.dateSearchOption = date;
    }

    public boolean isInclusion() {
        return this.inclusion;
    }

    public String getEdition() {
        return this.edition;
    }

    public HeteronymSearchOptionDto getHeteronymSearchOption() {
        return this.heteronymSearchOption;
    }

    public DateSearchOptionDto getDateSearchOption() {
        return this.dateSearchOption;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class HeteronymSearchOptionDto extends SearchOptionDto {
    private static final Logger logger = LoggerFactory.getLogger(HeteronymSearchOptionDto.class);

    private final String xmlId4Heteronym;

    public HeteronymSearchOptionDto(@JsonProperty("heteronym") String xmlId) {
        logger.debug("HeteronymSearchOption xmlId: {}", xmlId);
        this.xmlId4Heteronym = xmlId.equals("null") ? null : xmlId;
    }

    public String getXmlId4Heteronym() {
        return this.xmlId4Heteronym;
    }
}



public class AuthoralForSearchDto {

    private String[] mediums;
    private DatesForSearchDto dates;

    public String[] getMediums() {
        return this.mediums;
    }

    public void setMediums(String[] mediums) {
        this.mediums = mediums;
    }

    public DatesForSearchDto getDates() {
        return this.dates;
    }

    public void setDates(DatesForSearchDto dates) {
        this.dates = dates;
    }
}


import java.util.ArrayList;
import java.util.List;

public class EditionFragmentsDto {
    List<Fragment4VisualDto> fragments = new ArrayList<>();
    private List<String> categories = new ArrayList<>();

    public EditionFragmentsDto() {
    }

    public List<Fragment4VisualDto> getFragments() {
        return this.fragments;
    }

    public void setFragments(List<Fragment4VisualDto> fragments) {
        this.fragments = fragments;
    }

    public List<String> getCategories() {
        return this.categories;
    }

    public void setCategories(List<String> categories) {
        this.categories = categories;
    }

}





import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

import java.util.ArrayList;
import java.util.List;

public class FragmentMetaInfoDto {
    private String title;
    private String heteronym;
    private String date;
    private boolean hasLdoDLabel;
    private List<String> categories = new ArrayList<>();

    public FragmentMetaInfoDto(ScholarInterDto inter) {
        this.title = inter.getFragmentDto().getTitle();

        if (inter.getLdoDDate() != null) {
            this.date = inter.getLdoDDate().getDate().toString();
        }

        if (inter.getHeteronym() != null && !inter.getHeteronym().isNullHeteronym()) {
            this.heteronym = inter.getHeteronym().getName();
        }

        if (inter.isSourceInter()) {
            SourceDto sourceDto = inter.getSourceDto();
//            if (sourceDto.getType() == SourceType.MANUSCRIPT) {
            if (sourceDto.getType().getDesc().equals("manuscript")) {

                this.hasLdoDLabel = sourceDto.getHasLdoDLabel();
            }
        }
    }

    public FragmentMetaInfoDto(VirtualEditionInterDto inter) {
        this(inter.getLastUsed());

        this.categories = inter.getSortedCategoriesName();
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getHeteronym() {
        return this.heteronym;
    }

    public void setHeteronym(String heteronym) {
        this.heteronym = heteronym;
    }

    public String getDate() {
        return this.date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public boolean isHasLdoDLabel() {
        return this.hasLdoDLabel;
    }

    public void setHasLdoDLabel(boolean hasLdoDLabel) {
        this.hasLdoDLabel = hasLdoDLabel;
    }

    public List<String> getCategories() {
        return this.categories;
    }

    public void setCategories(List<String> categories) {
        this.categories = categories;
    }

}



import com.fasterxml.jackson.annotation.JsonIgnore;
import pt.ist.socialsoftware.edition.notification.dtos.text.ExpertEditionInterListDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.LdoDUserViewDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TaxonomyDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterGameDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterListDto;

import java.util.ArrayList;
import java.util.List;

public class EditionInterListDto {
    private List<VirtualEditionInterGameDto> virtualEditionInterList = new ArrayList<>();
    private String title;
    private String acronym;
    private String type;
    private boolean pub;
    private int numberOfInters;
    private TaxonomyDto taxonomy;
    private List<LdoDUserViewDto> members;


    public EditionInterListDto(ExpertEditionInterListDto expertEditionList){
        this.title = expertEditionList.getTitle();
        this.acronym = expertEditionList.getAcronym();
        this.type = expertEditionList.getType();
        this.pub = expertEditionList.isPub();
        this.numberOfInters = expertEditionList.getNumberOfInters();
        TaxonomyDto taxonomyDto = new TaxonomyDto();
        taxonomyDto.setHasCategories(false);
        this.taxonomy = taxonomyDto;
    }

    public EditionInterListDto(VirtualEditionInterListDto virtualEditionList){
        this.virtualEditionInterList = virtualEditionList.getVirtualEditionInterList();
        this.title = virtualEditionList.getTitle();
        this.acronym=virtualEditionList.getAcronym();
        this.type=virtualEditionList.getType();
        this.pub = virtualEditionList.isPub();
        this.numberOfInters = virtualEditionList.getNumberOfInters();
        this.taxonomy = virtualEditionList.getTaxonomy();
        this.members = virtualEditionList.getMembers();
    }

    public List<VirtualEditionInterGameDto> getVirtualEditionInterList() {
        return this.virtualEditionInterList;
    }

    public void setVirtualEditionInterList(List<VirtualEditionInterGameDto> virtualEditionInterList) {
        this.virtualEditionInterList = virtualEditionInterList;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public boolean isPub() {
        return this.pub;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public int getNumberOfInters() {
        return this.numberOfInters;
    }

    public void setNumberOfInters(int numberOfInters) {
        this.numberOfInters = numberOfInters;
    }

    @JsonIgnore
    public TaxonomyDto getTaxonomy() {
        return this.taxonomy;
    }

    public void setTaxonomy(TaxonomyDto taxonomy) {
        this.taxonomy = taxonomy;
    }

    public List<LdoDUserViewDto> getMembers() {
        return this.members;
    }

    public void setMembers(List<LdoDUserViewDto> members) {
        this.members = members;
    }

    public String getType() {
        return this.type;
    }

    public void setType(String type) {
        this.type = type;
    }
}



import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

public class Fragment4VisualDto {
    private String interId;
    private FragmentMetaInfoDto meta;
    String text;

    public Fragment4VisualDto(ScholarInterDto inter, String text) {
        this.interId = inter.getExternalId();
        this.meta = new FragmentMetaInfoDto(inter);
        this.text = text;
    }

    public Fragment4VisualDto(VirtualEditionInterDto inter, String text) {
        this.interId = inter.getExternalId();
        this.meta = new FragmentMetaInfoDto(inter);
        this.text = text;
    }

    public String getInterId() {
        return this.interId;
    }

    public void setInterId(String interId) {
        this.interId = interId;
    }

    public FragmentMetaInfoDto getMeta() {
        return this.meta;
    }

    public void setMeta(FragmentMetaInfoDto meta) {
        this.meta = meta;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

}




public class VirtualEditionInterGameDto {
    private String fragmentId;
    private String title;
    private int number;
    private String urlId;
    private String text;

    public VirtualEditionInterGameDto() {
    }

    public VirtualEditionInterGameDto(VirtualEditionInterDto inter) {
        this.setFragmentId(inter.getFragmentXmlId());
        this.title = inter.getTitle();
        this.number = inter.getNumber();
        this.urlId = inter.getUrlId();

//        this.text = inter.getLastUsed().getTranscription();
    }

    public String getFragmentId() {
        return this.fragmentId;
    }

    public void setFragmentId(String fragmentId) {
        this.fragmentId = fragmentId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getNumber() {
        return this.number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

}




import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;

import javax.validation.constraints.NotBlank;

public class LdoDUserViewDto {
    @NotBlank
    private String username;
    private String password;
    private String firstName;
    private String lastName;
    private boolean enabled;
    private boolean active;

    public LdoDUserViewDto() {
    }

    public LdoDUserViewDto(UserDto user) {
        this.username = user.getUsername();
        this.enabled = user.isEnabled();
        this.active = user.isActive();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
    }

    public LdoDUserViewDto(String user) {
        UserDto userDto = new UserDto(user);
        this.username = user;
        this.enabled = userDto.isEnabled();
        this.active = userDto.isActive();
        this.firstName = userDto.getFirstName();
        this.lastName = userDto.getLastName();
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return this.password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public boolean isEnabled() {
        return this.enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public boolean isActive() {
        return this.active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

}




import java.io.Serializable;

public class RangeJson implements Serializable {
	private static final long serialVersionUID = 1L;

	private String start;
	private int startOffset;
	private String end;
	private int endOffset;

	public RangeJson() {
	}


	public String getStart() {
		return start;
	}

	public void setStart(String start) {
		this.start = start;
	}

	public int getStartOffset() {
		return startOffset;
	}

	public void setStartOffset(int startOffset) {
		this.startOffset = startOffset;
	}

	public String getEnd() {
		return end;
	}

	public void setEnd(String end) {
		this.end = end;
	}

	public int getEndOffset() {
		return endOffset;
	}

	public void setEndOffset(int endOffset) {
		this.endOffset = endOffset;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}
}


import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.client.WebClient;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class TweetDto {

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    private long id;

    public TweetDto() {

    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @JsonIgnore
    public void remove() {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeTweet")
                    .queryParam("id", id)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }
}



import java.util.ArrayList;
import java.util.List;

public class VirtualEditionInterListDto {

    private List<VirtualEditionInterGameDto> virtualEditionInterList = new ArrayList<>();
    private String title;
    private String acronym;
    private String type;
    private boolean pub;
    private int numberOfInters;
    private TaxonomyDto taxonomy;
    private List<LdoDUserViewDto> members;

    public VirtualEditionInterListDto() {}

    public List<VirtualEditionInterGameDto> getVirtualEditionInterList() {
        return this.virtualEditionInterList;
    }

    public void setVirtualEditionInterList(List<VirtualEditionInterGameDto> virtualEditionInterList) {
        this.virtualEditionInterList = virtualEditionInterList;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public boolean isPub() {
        return this.pub;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public int getNumberOfInters() {
        return this.numberOfInters;
    }

    public void setNumberOfInters(int numberOfInters) {
        this.numberOfInters = numberOfInters;
    }


    public TaxonomyDto getTaxonomy() {
        return this.taxonomy;
    }

    public void setTaxonomy(TaxonomyDto taxonomy) {
        this.taxonomy = taxonomy;
    }

    public List<LdoDUserViewDto> getMembers() {
        return this.members;
    }

    public void setMembers(List<LdoDUserViewDto> members) {
        this.members = members;
    }

    public String getType() {
        return this.type;
    }

    public void setType(String type) {
        this.type = type;
    }


}



import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class TwitterCitationDto  {

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    private String tweetText;
    private String country;
    private String location;
    private String username;
    private String userProfileUrl;
    private long id;
    private long tweetId;

    public TwitterCitationDto() { }

    public String getTweetText() {
        return tweetText;
    }

    public String getCountry() {
        return country;
    }

    public String getLocation() {
        return location;
    }

    public String getUsername() {
        return username;
    }

    public long getId() {
        return id;
    }

    public long getTweetId() {
        return tweetId;
    }

    public boolean isTwitterCitation() {
        return true;
    }

    public String getUserProfileURL() {
        return this.userProfileUrl;
    }

    @JsonIgnore
    public Set<AwareAnnotationDto> getAwareAnnotationDtos() {
        return webClientVirtual.build()
                .get()
                .uri("/twitterCitation/" + tweetId + "/awareAnnotations")
                .retrieve()
                .bodyToFlux(AwareAnnotationDto.class)
                .toStream()
                .collect(Collectors.toSet());
    }

    @JsonIgnore
    public int getNumberOfRetweets() {
        return webClientVirtual.build()
                .get()
                .uri("/twitterCitation/" + tweetId + "/numberOfRetweets")
                .retrieve()
                .bodyToMono(Integer.class)
                .blockOptional().orElse(0);
    }

    @JsonIgnore
    public Set<TweetDto> getTweets() {
        return webClientVirtual
                .build()
                .get()
                .uri("/twitterCitation/" + tweetId + "/tweets")
                .retrieve()
                .bodyToFlux(TweetDto.class)
                .toStream().collect(Collectors.toSet());
    }

    public void setTweetText(String tweetText) {
        this.tweetText = tweetText;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setUserProfileUrl(String userProfileUrl) {
        this.userProfileUrl = userProfileUrl;
    }

    public void setId(long id) {
        this.id = id;
    }

    public void setTweetId(long tweetId) {
        this.tweetId = tweetId;
    }
}


import java.io.Serializable;

//@JsonIgnoreProperties(ignoreUnknown = true)
public class CategoryDto implements Serializable {
	private static final long serialVersionUID = 1L;

	private String id;
	private String text;
	private String selected;

	public CategoryDto() {
	}

	public String getId() {
		return this.id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getText() {
		return this.text;
	}

	public void setText(String name) {
		this.text = name;
	}

	public String getSelected() {
		return this.selected;
	}

	public void setSelected(String selected) {
		this.selected = selected;
	}

}



public class AwareAnnotationDto extends AnnotationDto {

    private String source;
    private String profile;
    private String date;
    private String country;

    public AwareAnnotationDto() {}

    public String getSource() {
        return this.source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getProfile() {
        return this.profile;
    }

    public void setProfile(String profile) {
        this.profile = profile;
    }

    public String getDate() {
        return this.date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public String getCountry() {
        return this.country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    @Override
    public boolean isHumanAnnotation() {
        return false;
    }
}




import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class HumanAnnotationDto extends AnnotationDto {

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    private String text;
    private List<TagDto> tags;

    public HumanAnnotationDto() {
        super();
    }

    @JsonIgnore
    public static boolean canCreate(String acronym, String username) {
        WebClient.Builder webClientVirtual = WebClient.builder().baseUrl("http://localhost:8083/api");
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + acronym + "/canCreateHumanAnnotation")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return virtualProvidesInterface.canCreateHumanAnnotationOnVirtualEdition(acronym, username);
    }

    @JsonIgnore
    public boolean canUpdate(String id, String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/humanAnnotation/" + id + "/canUserUpdate")
                    .queryParam("user", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.canUserUpdateHumanAnnotation(id, username);
    }

    @JsonIgnore
    public void update(String text, List<String> tags) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/humanAnnotation/" + getExternalId() + "/update")
                    .queryParam("text", text)
                    .queryParam("tags", tags)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.updateHumanAnnotation(getExternalId(), text, tags);
    }

    @JsonIgnore
    public boolean canDelete(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/humanAnnotation/" + getExternalId() + "/canUserDelete")
                    .queryParam("user", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //       return this.virtualProvidesInterface.canUserDeleteHumanAnnotation(getExternalId(), username);
    }

    @JsonIgnore
    public void remove() {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeHumanAnnotation")
                    .queryParam("id", getExternalId())
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.removeHumanAnnotation(getExternalId());
    }

    @JsonIgnore
    public VirtualEditionInterDto getVirtualEditionInter() {
        return webClientVirtual.build()
                .get()
                .uri("/humanAnnotation/" + getExternalId() + "/virtualEditionInter")
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public List<TagDto> getTags() {
        return this.tags;
    }

    public void setTags(List<TagDto> tags) {
        this.tags = tags;
    }

    @Override
    public boolean isHumanAnnotation() {
        return true;
    }
}




import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class TaxonomyDto {

	private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);

	private boolean openManagement;
	private boolean openVocabulary;
	private boolean openAnnotation;
	private boolean hasCategories;

	private String editionAcronym;
	private String externalId;

	public TaxonomyDto() {
	}

	public String getExternalId() {
		return externalId;
	}

	public boolean isOpenManagement() {
		return this.openManagement;
	}

	public void setOpenManagement(boolean openManagement) {
		this.openManagement = openManagement;
	}

	public boolean isOpenVocabulary() {
		return this.openVocabulary;
	}

	public void setOpenVocabulary(boolean openVocabulary) {
		this.openVocabulary = openVocabulary;
	}

	public boolean isOpenAnnotation() {
		return this.openAnnotation;
	}

	public void setOpenAnnotation(boolean openAnnotation) {
		this.openAnnotation = openAnnotation;
	}

	public boolean getHasCategories() {
		return this.hasCategories;
	}

	public void setHasCategories(boolean hasCategories) {
		this.hasCategories = hasCategories;
	}

	public boolean isHasCategories() {
		return hasCategories;
	}

	public String getEditionAcronym() {
		return editionAcronym;
	}

	public void setEditionAcronym(String editionAcronym) {
		this.editionAcronym = editionAcronym;
	}

	public void setExternalId(String externalId) {
		this.externalId = externalId;
	}

	@JsonIgnore
	public VirtualEditionDto getEdition() {
		return webClientVirtual.build()
				.get()
				.uri("/virtualEdition/" + this.editionAcronym)
				.retrieve()
				.bodyToMono(VirtualEditionDto.class)
				.block();
		//		return this.virtualProvidesInterface.getVirtualEdition(this.editionAcronym);
	}

	@JsonIgnore
	public Set<CategoryDto> getCategoriesSet() {
		return webClientVirtual.build()
				.get()
				.uri("/virtualEdition/" + this.editionAcronym + "/categoriesFromTaxonomy")
				.retrieve()
				.bodyToFlux(CategoryDto.class)
				.toStream()
				.collect(Collectors.toSet());
		//		return this.virtualProvidesInterface.getCategoriesFromTaxonomy(editionAcronym);
	}

	@JsonIgnore
	public void edit(boolean management, boolean vocabulary, boolean annotation) {
		webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
					.path("/taxonomy/" + editionAcronym + "/edit")
					.queryParam("management", management)
					.queryParam("vocabulary", vocabulary)
					.queryParam("annotation", annotation)
				.build())
				.retrieve()
				.bodyToMono(Void.class)
				.block();
		//		this.virtualProvidesInterface.editTaxonomy(this.editionAcronym, management, vocabulary, annotation);
	}

	@JsonIgnore
	public void createGeneratedCategories(TopicListDto topicList) {
		webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
					.path("/createGeneratedCategories")
					.queryParam("editionAcronym", editionAcronym)
				.build())
				.body(BodyInserters.fromValue(topicList))
				.retrieve()
				.bodyToMono(Void.class)
				.block();
		//		this.virtualProvidesInterface.createGeneratedCategories(this.editionAcronym, topicList);
	}

	@JsonIgnore
	public void removeTaxonomy() {
		webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
					.path("/removeTaxonomy")
					.queryParam("editionAcronym", this.editionAcronym)
					.build())
				.retrieve()
				.bodyToMono(Void.class)
				.block();
		//		this.virtualProvidesInterface.removeTaxonomy(this.editionAcronym);
	}

	@JsonIgnore
	public void createCategory(String name) {
		webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
					.path("/createCategory")
					.queryParam("name", name)
					.queryParam("editionAcronym", editionAcronym)
				.build())
				.retrieve()
				.bodyToMono(Void.class)
				.block();
		//		this.virtualProvidesInterface.createCategory(this.editionAcronym, name);
	}

	@JsonIgnore
	public CategoryDto mergeCategories(List<CategoryDto> categories) {
		return webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
						.path("/mergeCategories")
						.queryParam("editionAcronym", editionAcronym)
						.build())
				.body(BodyInserters.fromValue(categories))
				.retrieve()
				.bodyToMono(CategoryDto.class)
				.block();

		//		return this.virtualProvidesInterface.mergeCategories(this.editionAcronym, categories);
	}

	@JsonIgnore
	public void deleteCategories(List<CategoryDto> categories) {
		webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
					.path("/deleteCategories")
					.queryParam("editionAcronym", editionAcronym)
					.build())
				.body(BodyInserters.fromValue(categories))
				.retrieve()
				.bodyToMono(Void.class)
				.block();
		//		this.virtualProvidesInterface.deleteCategories(this.editionAcronym, categories);
	}

	@JsonIgnore
	public CategoryDto extractCategory(String externalId, String[] interIds) {
		return webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
						.path("/extractCategories")
						.queryParam("externalId", externalId)
						.queryParam("editionAcronym", editionAcronym)
						.build())
				.body(BodyInserters.fromValue(interIds))
				.retrieve()
				.bodyToMono(CategoryDto.class)
				.block();
		//		return this.virtualProvidesInterface.extractCategories(this.editionAcronym, externalId, interIds);
	}

	@JsonIgnore
	public List<VirtualEditionDto> getUsedIn() {
		return webClientVirtual.build()
				.get()
				.uri("/taxonomy/" + editionAcronym + "/taxonomyUsedIn")
				.retrieve()
				.bodyToFlux(VirtualEditionDto.class)
				.collectList()
				.block();
		//		return this.virtualProvidesInterface.getTaxonomyUsedIn(this.editionAcronym);
	}

	@JsonIgnore
	public boolean canManipulateTaxonomy(String username) {
		return webClientVirtual.build()
				.get()
				.uri(uriBuilder -> uriBuilder
					.path("/virtualEdition/" + editionAcronym + "/canManipulateTaxonomy")
					.queryParam("username", username)
					.build())
				.retrieve()
				.bodyToMono(Boolean.class)
				.blockOptional()
				.orElse(false);
		//		return this.virtualProvidesInterface.canManipulateTaxonomy(this.editionAcronym, username);
	}

	@JsonIgnore
	public List<CategoryDto> getSortedCategories() {
		return getCategoriesSet().stream().sorted((c1, c2) -> c1.getName().compareTo(c2.getName()))
				.collect(Collectors.toList());
	}

	@JsonIgnore
	public CategoryDto createTestCategory(String name) {
		return webClientVirtual.build()
				.post()
				.uri(uriBuilder -> uriBuilder
						.path("/createTestCategory")
						.queryParam("editionAcronym", editionAcronym)
						.queryParam("name", name)
						.build())
				.retrieve()
				.bodyToMono(CategoryDto.class)
				.block();
	}
}



public class TagDto {

    private String username;
    private String acronym;
    private String urlId;
    private String nameInEdition;
    private String name;
    private String externalId;

    public TagDto() {}

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getAcronym() {
        return acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public String getUrlId() {
        return urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getNameInEdition() {
        return nameInEdition;
    }

    public void setNameInEdition(String nameInEdition) {
        this.nameInEdition = nameInEdition;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}


public class TopicInterPercentageDTO {
	private String externalId;
	private String title;
	private int percentage;

	public TopicInterPercentageDTO() {}

	public String getExternalId() {
		return externalId;
	}

	public void setExternalId(String externalId) {
		this.externalId = externalId;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public int getPercentage() {
		return percentage;
	}

	public void setPercentage(int percentage) {
		this.percentage = percentage;
	}

}


import java.util.List;

public class TopicDto {
	private String name;
	private List<TopicInterPercentageDTO> inters;

	public TopicDto() {

	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<TopicInterPercentageDTO> getInters() {
		return inters;
	}

	public void setInters(List<TopicInterPercentageDTO> inters) {
		this.inters = inters;
	}

}



public class MemberDto {

    private String user;
    private String role;

    public MemberDto() {

    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public boolean hasRole(String role) {
        return this.role.equals(role);
    }

}




import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;


public class VirtualEditionInterDto {

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    private String xmlId;

    // cached attributes
    private String externalId;
    private String title;
    private String fragmentXmlId;
    private String urlId;
    private String shortName;
    private String reference;
    private int number;
    private ScholarInterDto lastUsed;
    private VirtualEditionDto virtualEditionDto;



    public VirtualEditionInterDto() {}

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getExternalId() {
        //return this.virtualProvidesInterface.getVirtualEditionInterExternalId(this.xmlId);
        return this.externalId;
    }

    public String getTitle() {
        //return this.virtualProvidesInterface.getVirtualEditionInterTitle(this.xmlId);
        return this.title;
    }

    public FragScholarInterDto.InterType getType() {
        return FragScholarInterDto.InterType.VIRTUAL;
    }

    public String getFragmentXmlId() {
        //return this.virtualProvidesInterface.getFragmentXmlIdVirtualEditionInter(this.xmlId);
        return this.fragmentXmlId;
    }

    public String getUrlId() {
        //return this.virtualProvidesInterface.getVirtualEditionInterUrlId(this.xmlId);
        return this.urlId;
    }

    public String getShortName() {
        //return this.virtualProvidesInterface.getVirtualEditionInterShortName(this.xmlId);
        return this.shortName;
    }

    @JsonIgnore
    public ScholarInterDto getLastUsed() {
        //return this.virtualProvidesInterface.getVirtualEditionLastUsedScholarInter(this.xmlId);
        if (this.lastUsed == null)
            this.lastUsed = webClientVirtual.build()
                    .get()
                    .uri("/virtualEditionInter/" + this.xmlId + "/lastUsed")
                    .retrieve()
                    .bodyToMono(ScholarInterDto.class)
                    .block();

//            this.lastUsed = this.virtualProvidesInterface.getVirtualEditionLastUsedScholarInter(this.xmlId);
        return this.lastUsed;
    }

    @JsonIgnore
    public String getUsesScholarInterId() {
        return getLastUsed().getXmlId();
    }

    public String getReference() {
        //return this.virtualProvidesInterface.getVirtualEditionInterReference(this.xmlId);
        return this.reference;
    }

    public int getNumber() {
        //return this.virtualProvidesInterface.getVirtualEditionInterNumber(this.xmlId);
        return this.number;
    }

    @JsonIgnore
    public VirtualEditionInterDto getNextInter() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/nextInter")
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.getNextVirtualInter(this.xmlId);
    }

    @JsonIgnore
    public VirtualEditionInterDto getPrevInter() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/prevInter")
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.getPrevVirtualInter(this.xmlId);
    }

    @JsonIgnore
    public VirtualEditionInterDto getUsesInter() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/uses")
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterUses(this.xmlId);
    }

    @JsonIgnore
    public List<String> getSortedCategoriesName() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/sortedCategoriesName")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getSortedVirtualEditionInterCategoriesName(this.xmlId);
    }

    @JsonIgnore
    public List<CategoryDto> getSortedCategories(VirtualEditionDto virtualEditionDto) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                .path("/virtualEdition/"  + virtualEditionDto.getAcronym() + "/sortedVirtualEditionInterCategories")
                .queryParam("xmlId", this.xmlId)
                .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getSortedVirtualEditionInterCategoriesFromVirtualEdition(this.xmlId, virtualEditionDto.getAcronym());
    }

    @JsonIgnore
    public List<CategoryDto> getCategoriesUsedInTags(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/categoriesUsedInTags")
                    .queryParam("xmlId", xmlId)
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getCategoriesUsedInTags(this.xmlId, username);
    }

    @JsonIgnore
    public List<CategoryDto> getAllDepthCategoriesAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditionInter/" + this.xmlId + "/allDepthCategoriesAccessibleByUser")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterAllDepthCategoriesAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public Set<TagDto> getAllDepthTagsAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/allDepthTagsAcessibleByUser")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(TagDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterAllDepthTagsAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public Set<TagDto> getTagSet(){
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/allTags")
                .retrieve()
                .bodyToFlux(TagDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getAllTags(xmlId);
    }

    @JsonIgnore
    public List<CategoryDto> getAllDepthCategoriesUsedByUserInTags(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditionInter/" + this.xmlId + "/allDepthCategoriesUsedByUserInTags")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterAllDepthCategoriesUsedByUserInTags(this.xmlId, username);
    }

    @JsonIgnore
    public List<CategoryDto> getAllDepthCategoriesNotUsedInTags(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/allDepthCategoriesNotUsedInTags")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterAllDepthCategoriesNotUsedInTags(this.xmlId, username);
    }

    @JsonIgnore
    public VirtualEditionDto getVirtualEditionDto() {
        if (virtualEditionDto == null)
             virtualEditionDto =  webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + this.xmlId + "/virtualEdition")
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
        return virtualEditionDto;
        //        return this.virtualProvidesInterface.getVirtualEditionOfVirtualEditionInter(this.xmlId);
    }

    @JsonIgnore
    public List<AnnotationDto> getAllDepthAnnotationsAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                   .path("/virtualEditionInter/" + this.xmlId + "/allDepthAnnotationsAccessibleByUser")
                   .queryParam("username", username)
                   .build())
                .retrieve()
                .bodyToFlux(AnnotationDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getAllDepthAnnotationsAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public List<TagDto> getAllDepthTagsNotHumanAnnotationAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/allDepthTagsNotHumanAnnotationAccessibleByUser")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(TagDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getAllDepthTagsNotHumanAnnotationAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public List<HumanAnnotationDto> getVirtualEditionInterHumanAnnotationsAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/humanAnnotationsAccessibleByUser")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(HumanAnnotationDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterHumanAnnotationsAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public List<AwareAnnotationDto> getVirtualEditionInterAwareAnnotationsAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/awareAnnotationsAccessibleByUser")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(AwareAnnotationDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterAwareAnnotationsAccessibleByUser(this.xmlId, username);
    }

    @JsonIgnore
    public List<VirtualEditionInterDto> getUsesPath() {
        List<VirtualEditionInterDto> usesPath = new ArrayList<>();
        VirtualEditionInterDto uses = getUsesInter();
        while (uses != null) {
            usesPath.add(uses);
            uses = uses.getUsesInter();
        }

        return usesPath;
    }

    @JsonIgnore
    public List<CategoryDto> getAllDepthCategoriesUsedInTags(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/allDepthCategoriesUsedInTags")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToFlux(CategoryDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionInterAllDepthCategoriesUsedInTags(this.xmlId, username);
    }

    @JsonIgnore
    public FragmentDto getFragmentDto() {
        return getLastUsed().getFragmentDto();
    }

    @JsonIgnore
    public String getAllDepthCategoriesJSON(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEditionInter/" + this.xmlId + "/allDepthCategoriesJSON")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //        return this.virtualProvidesInterface.getAllDepthCategoriesJSON(this.xmlId, username);
    }

    @JsonIgnore
    public Set<String> getContributorSet(String externalId, String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditionInter/" + this.xmlId + "/contributorSet")
                    .queryParam("username", username)
                    .queryParam("externalId", externalId)
                    .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Set<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getContributorSetFromVirtualEditionInter(externalId, this.xmlId, username);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        VirtualEditionInterDto other = (VirtualEditionInterDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }

    @JsonIgnore
    public void dissociate(String authenticatedUser, String category) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/dissociateVirtualEditionInterCategory")
                    .queryParam("xmlId", xmlId)
                    .queryParam("username", authenticatedUser)
                    .queryParam("categoryExternalId", category)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.dissociateVirtualEditionInterCategory(this.xmlId, authenticatedUser, category);
    }

    @JsonIgnore
    public void associate(String authenticatedUser, Set<String> collect) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/associateVirtualEditionInterCategoriesByExternalId")
                        .queryParam("externalId", externalId)
                        .queryParam("username", authenticatedUser)
                        .queryParam("categories", collect)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.associateVirtualEditionInterCategoriesbyExternalId(this.externalId, authenticatedUser, collect);
    }

    @JsonIgnore
    public HumanAnnotationDto createHumanAnnotation(String quote, String text, String username, List<RangeJson> ranges, List<String> tags) {
        return webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/createHumanAnnotation")
                    .queryParam("xmlId", xmlId)
                    .queryParam("quote", quote)
                    .queryParam("text", text)
                    .queryParam("user", username)
                    .queryParam("tags", tags)
                    .build())
                .bodyValue(ranges)
                .retrieve()
                .bodyToMono(HumanAnnotationDto.class)
                .block();
        //       return this.virtualProvidesInterface.createHumanAnnotation(this.xmlId, quote, text, username, ranges, tags);
    }

    @JsonIgnore
    public List<HumanAnnotationDto> getAllDepthHumanAnnotationsAccessibleByUser(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEditionInter/" + xmlId + "/allDepthHumanAnnotationsAccessibleByUser")
                    .queryParam("username", username)
                .build())
                .retrieve()
                .bodyToFlux(HumanAnnotationDto.class)
                .collectList()
                .block();
    }

    @JsonIgnore
    public void removeInter() {
        webClientVirtual.build()
                .post()
                .uri("/virtualEditionInter/" + externalId + "/remove")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setTitle(String title) {
        this.title = title;
    }


    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public void setLastUsed(ScholarInterDto lastUsed) {
        this.lastUsed = lastUsed;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }
}



import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
@JsonSubTypes({@JsonSubTypes.Type(value = AwareAnnotationDto.class, name = AnnotationDto.AWARE),
        @JsonSubTypes.Type(value = HumanAnnotationDto.class, name = AnnotationDto.HUMAN)})
public abstract class AnnotationDto {

    public static final String AWARE = "aware";
    public static final String HUMAN = "human";

    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    private String quote;
    private String username;
    private String text;
    private String externalId;
    private String interExternalId;
    private String interXmlId;
    private String user;

    public AnnotationDto() {
    }

    public String getQuote() {
        return this.quote;
    }

    public void setQuote(String quote) {
        this.quote = quote;
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getExternalId() {
        return externalId;
    }

    public String getInterExternalId() {
        return interExternalId;
    }

//    public Set<Range> getRangeSet() {
//        return this.virtualProvidesInterface.getRangeSetFromAnnotation(externalId);
//    }

    @JsonIgnore
    public Set<RangeJson> getRangeSet() {
        return webClientVirtual.build()
                .get()
                .uri("/annotation/" + externalId + "/ranges")
                .retrieve()
                .bodyToFlux(RangeJson.class)
                .toStream()
                .collect(Collectors.toSet());
    }

    public String getUser() {
        return user;
    }

    @JsonIgnore
    public VirtualEditionDto getVirtualEdition() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInter/" + interXmlId + "/virtualEdition")
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionOfVirtualEditionInter(interXmlId);
    }

    public abstract boolean isHumanAnnotation();

    @JsonIgnore
    public void remove() {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeAnnotation")
                    .queryParam("externalId", externalId)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setInterExternalId(String interExternalId) {
        this.interExternalId = interExternalId;
    }

    public void setInterXmlId(String interXmlId) {
        this.interXmlId = interXmlId;
    }

    public void setUser(String user) {
        this.user = user;
    }
}


import java.util.List;

public class TopicListDto {
	private String taxonomyExternalId;
	private String username;
	private List<TopicDto> topics;

	public TopicListDto() {}

	public String getTaxonomyExternalId() {
		return taxonomyExternalId;
	}

	public void setTaxonomyExternalId(String taxonomyExternalId) {
		this.taxonomyExternalId = taxonomyExternalId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public List<TopicDto> getTopics() {
		return topics;
	}

	public void setTopics(List<TopicDto> topics) {
		this.topics = topics;
	}

}


import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.LocalDate;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateDeserializer;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateSerializer;
import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;

import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

public class VirtualEditionDto {
    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);

    private  String xmlId;
    private  String acronym;

    // cached attributes
    private String externalId;
    private String title;
    private String reference;
    private String synopsis;
    private boolean isLdoDEdition;
    private LocalDate date;
    private boolean pub;
    private boolean openVocabulary;
    private String shortAcronym;
    private int max;

    private Set<String> participants;

    public VirtualEditionDto() {}

    public String getXmlId() {
        return this.xmlId;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getExternalId() {
        //return this.virtualProvidesInterface.getVirtualEditionExternalIdByAcronym(this.acronym);
        return this.externalId;
    }

    public String getTitle() {
        //return this.virtualProvidesInterface.getVirtualEditionTitleByAcronym(this.acronym);
        return this.title;
    }

    @JsonIgnore
    public List<String> getSortedCategorySet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + this.acronym + "/sortedCategory")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionSortedCategoryList(this.acronym);
    }

    @JsonIgnore
    public List<VirtualEditionInterDto> getSortedVirtualEditionInterDtoList() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + this.acronym + "/sortedVirtualEditionInterList")
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getSortedVirtualEditionInterDtoList(this.acronym);
    }

    @JsonIgnore
    public Set<VirtualEditionInterDto> getVirtualEditionInterOfFragmentForVirtualEdition(String xmlId) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + this.acronym + "/virtualEditionInterOfFragment")
                    .queryParam("xmlId", xmlId)
                    .build())
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterOfFragmentForVirtualEdition(this.acronym, xmlId);
    }

    public String getReference() {
        //return this.virtualProvidesInterface.getVirtualEditionReference(this.acronym);
        return this.reference;
    }

    public boolean getTaxonomyVocabularyStatus() {
        //return this.virtualProvidesInterface.getVirtualEditionTaxonomyVocabularyStatus(this.acronym);
        return this.openVocabulary;
    }

    public String getShortAcronym() {
        return shortAcronym;
    }

    public boolean isLdoDEdition() {
        //return this.virtualProvidesInterface.isLdoDEdition(this.acronym);
        return this.isLdoDEdition;
    }

    @JsonIgnore
    public boolean isPublicOrIsParticipant(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + this.acronym + "/isPublicOrIsUserParticipant")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return this.virtualProvidesInterface.isVirtualEditionPublicOrIsUserParticipant(this.acronym, username);
    }

    @JsonIgnore
    public Set<String> getAdminSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/adminSet")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Set<String>>() {})
                .block();

        //        return this.virtualProvidesInterface.getVirtualEditionAdminSet(this.acronym);
    }

//    @JsonIgnore
//    public Set<String> getParticipantSet() {
//        return webClientVirtual.build()
//                .get()
//                .uri("/virtualEdition/" + this.acronym + "/participants")
//                .retrieve()
//                .bodyToMono(new ParameterizedTypeReference<Set<String>>() {})
//                .block();
//
//        //        return this.virtualProvidesInterface.getVirtualEditionParticipantSet(this.acronym);
//    }


    public Set<String> getParticipantSet() {
        return participants;
    }

    @JsonIgnore
    public List<UserDto> getParticipantList() {
        return getParticipantSet().stream().map(participant -> new UserDto(participant)).sorted(Comparator.comparing(UserDto::getFirstName))
                .collect(Collectors.toList());
    }

    @JsonIgnore
    public Set<String> getPendingSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + this.acronym + "/pending")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Set<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionPendingSet(this.acronym);
    }

    public boolean getPub() {
       //return this.virtualProvidesInterface.getVirtualEditionPub(this.acronym);
       return this.pub;
    }

    @JsonDeserialize(using = CustomLocalDateDeserializer.class)
    @JsonSerialize(using = CustomLocalDateSerializer.class)
    public LocalDate getDate() {
        //return this.virtualProvidesInterface.getVirtualEditionDate(this.acronym);
        return this.date;
    }

    @JsonIgnore
    public boolean canAddFragInter(String interXmlId) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + this.acronym + "canAddFragInter")
                    .queryParam("interXmlId", interXmlId)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.canAddFragInter(this.acronym, interXmlId);
    }

    @JsonIgnore
    public boolean canManipulateAnnotation(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + acronym + "/canManipulateAnnotation")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return this.virtualProvidesInterface.canManipulateAnnotation(this.acronym, username);
    }

    public boolean getOpenVocabulary() {
        //return this.virtualProvidesInterface.getOpenVocabulary(this.acronym);
        return this.openVocabulary;
    }

    public int getMaxFragNumber() {
        return max;
    }

    @JsonIgnore
    public boolean canManipulateTaxonomy(String username) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEdition/" + acronym + "/canManipulateTaxonomy")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional()
                .orElse(false);
        //        return this.virtualProvidesInterface.canManipulateTaxonomy(this.acronym, username);
    }

    public String getSynopsis() {
        return this.synopsis;
    }

    @JsonIgnore
    public TaxonomyDto getTaxonomy() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/taxonomy")
                .retrieve()
                .bodyToMono(TaxonomyDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionTaxonomy(this.acronym);
    }

    @JsonIgnore
    public String getMediaSourceName() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/mediaSource")
                .retrieve()
                .bodyToMono(String.class)
                .block();
        //        return this.virtualProvidesInterface.getMediaSourceName(this.acronym);
    }

    @JsonIgnore
    public LocalDate getTimeWindowBeginDate() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/timeWindowBeginDate")
                .retrieve()
                .bodyToMono(LocalDate.class)
                .block();
        //        return this.virtualProvidesInterface.getTimeWindowBeginDate(acronym);
    }

    @JsonIgnore
    public LocalDate getTimeWindowEndDate() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/timeWindowEndDate")
                .retrieve()
                .bodyToMono(LocalDate.class)
                .block();
        //        return this.virtualProvidesInterface.getTimeWindowEndDate(acronym);
    }

    @JsonIgnore
    public boolean containsEveryCountryinGeographicLocation() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/containsEveryCountryinGeographicLocation")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.containsEveryCountryinGeographicLocation(this.acronym);
    }

    @JsonIgnore
    public boolean containsCountryinGeographicLocation(String country) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEdition/" + acronym + "/containsCountryinGeographicLocation")
                        .queryParam("country", country)
                .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.containsCountryinGeographicLocation(this.acronym, country);
    }

    @JsonIgnore
    public int getIntegerFrequency() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/integerFrequency")
                .retrieve()
                .bodyToMono(Integer.class)
                .blockOptional().orElse(0);
        //        return this.virtualProvidesInterface.getIntegerFrequency(this.acronym);
    }

    @JsonIgnore
    public Set<VirtualEditionInterDto> getIntersSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEditionInterSet/" + acronym )
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getVirtualEditionInterSet(this.acronym);
    }

    @JsonIgnore
    public List<VirtualEditionInterDto> getSortedInterps() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/sortedVirtualEditionInterList" )
                .retrieve()
                .bodyToFlux(VirtualEditionInterDto.class)
                .collectList()
                .block();
        //        return this.virtualProvidesInterface.getSortedVirtualEditionInterDtoList(this.acronym);
    }

    @JsonIgnore
    public void edit(String acronym, String title, String synopsis, boolean pub, boolean management, boolean vocabulary, boolean annotation, String mediaSource, String beginDate, String endDate, String geoLocation, String frequency) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + xmlId + "/edit")
                    .queryParam("acronym", acronym)
                    .queryParam("title", title)
                    .queryParam("synopsis", synopsis)
                    .queryParam("pub", pub)
                    .queryParam("management", management)
                    .queryParam("vocabulary", vocabulary)
                    .queryParam("annotation", annotation)
                    .queryParam("mediaSource", mediaSource)
                    .queryParam("beginDate", beginDate)
                    .queryParam("endDate", endDate)
                    .queryParam("geoLocation", geoLocation)
                    .queryParam("frequency", frequency)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.editVirtualEdition(this.xmlId, acronym, title, synopsis, pub, management, vocabulary, annotation, mediaSource, beginDate, endDate, geoLocation, frequency);
    }

    @JsonIgnore
    public void removeByExternalId() {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/removeVirtualEdition")
                    .queryParam("externalId", externalId)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.removeVirtualEditionByExternalId(this.externalId);
    }

    @JsonIgnore
    public void updateVirtualEditionIntersFromExternalId(List<String> fragIntersXmlIds) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + externalId + "/updateVirtualEditionInters")
                    .queryParam("fragIntersXmlIds", fragIntersXmlIds)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.updateVirtualEditionInters(this.externalId, fragIntersXmlIds);
    }

    @JsonIgnore
    public void addMemberByExternalId(String user,  boolean b) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + externalId + "/addMember")
                    .queryParam("user", user)
                    .queryParam("b", b)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.addMemberByExternalId(this.externalId, user, b);
    }

    @JsonIgnore
    public void cancelParticipationSubmissionByExternalId(String user) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                .path("/virtualEdition/" + externalId + "/cancelParticipationSubmission")
                .queryParam("user", user)
                .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.cancelParticipationSubmissionByExternalId(this.externalId, user);
    }

    @JsonIgnore
    public void addApproveByExternalId(String username) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEdition/" + externalId + "/addApprove")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.addApproveByExternalId(externalId, username);
    }

    @JsonIgnore
    public boolean canSwitchRole(String authenticatedUser, String username) {
        return webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEdition/" + externalId + "/canSwitchRole")
                        .queryParam("authenticatedUser", authenticatedUser)
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //       return this.virtualProvidesInterface.canSwitchRole(this.externalId, authenticatedUser, username);
    }

    @JsonIgnore
    public void switchRole(String username) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + externalId + "/switchRole")
                    .queryParam("username", username)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.switchRole(this.externalId, username);
    }

    @JsonIgnore
    public boolean canRemoveMember(String authenticatedUser, String user) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + externalId + "/canRemoveMember")
                    .queryParam("authenticatedUser", authenticatedUser)
                    .queryParam( "user", user)
                .build())
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().orElse(false);
        //        return this.virtualProvidesInterface.canRemoveMember(externalId, authenticatedUser, user);
    }

    @JsonIgnore
    public void removeMember(String user) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + externalId + "/removeMember")
                    .queryParam("user", user)
                    .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //        this.virtualProvidesInterface.removeMember(externalId, user);
    }


    @JsonIgnore
    public VirtualEditionInterDto createVirtualEditionInterFromScholarInter(String xmlId, int max) {
        return webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                    .path("/createVirtualEditionInterFromScholarInter")
                    .queryParam("xmlId", xmlId)
                    .queryParam("externalId", externalId)
                    .queryParam("max", max)
                .build())
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.createVirtualEditionInterFromScholarInter(this.externalId, xmlId, max);
    }

    @JsonIgnore
    public VirtualEditionInterDto createVirtualEditionInterFromVirtualEditionInter(String externalId, int max) {
        return webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/createVirtualEditionInterFromVirtualEditionInter")
                        .queryParam("externalId", this.externalId)
                        .queryParam("interExternalId", externalId)
                        .queryParam("max", max)
                        .build())
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.createVirtualEditionInterFromVirtualEditionInter(this.externalId, externalId, max);
    }

    @JsonIgnore
    public Set<String> getAdminSetByExternalId() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + this.externalId + "/adminSetByExternalId")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Set<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionAdminSetByExternalId(this.externalId);
    }

    @JsonIgnore
    public Set<MemberDto> getActiveMemberSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/activeMembers")
                .retrieve()
                .bodyToFlux(MemberDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getActiveMembersFromVirtualEdition(this.acronym);
    }

    @JsonIgnore
    public Set<MemberDto> getPendingMemberSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/pendingMember")
                .retrieve()
                .bodyToFlux(MemberDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //        return this.virtualProvidesInterface.getPendingMemberFromVirtualEdition(this.acronym);
    }

    @JsonIgnore
    public List<String> getAnnotationTextList() {
        return webClientVirtual.exchangeStrategies(ExchangeStrategies.builder()
                .codecs(configurer -> configurer
                        .defaultCodecs()
                        .maxInMemorySize(16 * 1024 * 1024))
                .build())
                .build()
                .get()
                .uri("/virtualEdition/" + this.acronym + "/annotationTextList")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        this.virtualProvidesInterface.getAnnotationTextListFromVirtualEdition(this.acronym);
    }

    @JsonIgnore
    public VirtualEditionInterDto getFragInterByUrlId(String urlId) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + acronym + "/fragInter")
                    .queryParam("urlId", urlId)
                    .build())
                .retrieve()
                .bodyToMono(VirtualEditionInterDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionFragInterByUrlId(this.acronym, urlId);
    }

    @JsonIgnore
    public Set<MemberDto> getMemberSet() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/members")
                .retrieve()
                .bodyToFlux(MemberDto.class)
                .toStream()
                .collect(Collectors.toSet());

    }

    @JsonIgnore
    public void addMemberAdminByExternalId(String user, boolean b) {
        webClientVirtual.build()
                .post()
                .uri(uriBuilder -> uriBuilder
                        .path("/virtualEdition/" + externalId + "/addMemberAdmin")
                        .queryParam("user", user)
                        .queryParam("b", b)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    @JsonIgnore
    public int getNumberOfCriterias() {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/criteriaSize")
                .retrieve()
                .bodyToMono(Integer.class)
                .blockOptional().orElse(0);
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public void setSynopsis(String synopsis) {
        this.synopsis = synopsis;
    }

    public void setLdoDEdition(boolean ldoDEdition) {
        isLdoDEdition = ldoDEdition;
    }

    public void setDate(LocalDate date) {
        this.date = date;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public void setOpenVocabulary(boolean openVocabulary) {
        this.openVocabulary = openVocabulary;
    }

    public void setShortAcronym(String shortAcronym) {
        this.shortAcronym = shortAcronym;
    }

    public void setMax(int max) {
        this.max = max;
    }

    public void setParticipantSet(Set<String> participants) {
        this.participants = participants;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public void setSynopsis(String synopsis) {
        this.synopsis = synopsis;
    }

    public void setisLdoDEdition(boolean ldoDEdition) {
        isLdoDEdition = ldoDEdition;
    }

    public void setDate(LocalDate date) {
        this.date = date;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public void setOpenVocabulary(boolean openVocabulary) {
        this.openVocabulary = openVocabulary;
    }

    public void setShortAcronym(String shortAcronym) {
        this.shortAcronym = shortAcronym;
    }

    public void setMax(int max) {
        this.max = max;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;

public class RecommendVirtualEditionParam {
    private final String acronym;
    private final String id;
    private final List<PropertyDto> properties;

    public RecommendVirtualEditionParam(@JsonProperty("acronym") String acronym,
                                        @JsonProperty("id") String id,
                                        @JsonProperty("properties") List<PropertyDto> properties) {
        this.acronym = acronym;
        this.id = id;
        this.properties = properties;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getId() {
        return this.id;
    }

    public List<PropertyDto> getProperties() {
        return this.properties;
    }

}

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;


@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "type")
@JsonSubTypes({@JsonSubTypes.Type(value = HeteronymPropertyDto.class, name = PropertyDto.HETERONYM),
        @JsonSubTypes.Type(value = DatePropertyDto.class, name = PropertyDto.DATE),
        @JsonSubTypes.Type(value = TextPropertyDto.class, name = PropertyDto.TEXT),
        @JsonSubTypes.Type(value = TaxonomyPropertyDto.class, name = PropertyDto.TAXONOMY)})
public abstract class PropertyDto {
    public static final String HETERONYM = "heteronym";
    public static final String DATE = "date";
    public static final String TEXT = "text";
    public static final String TAXONOMY = "taxonomy";

    protected final double weight;
    protected final String acronym;

    public PropertyDto(double weight, String acronym) {
        this.weight = weight;
        this.acronym = acronym;
    }

//    public abstract Property getProperty();

    public abstract String getType();

    public double getWeight() {
        return this.weight;
    }

    public String getAcronym() {
        return this.acronym;
    }
}

public class InterIdDistancePairDto {
    private String interId;
    private double distance;

    public InterIdDistancePairDto(String interId, double distance) {
        this.interId = interId;
        this.distance = distance;
    }

    public InterIdDistancePairDto() {
    }

    public String getInterId() {
        return this.interId;
    }

    public void setInter(String interId) {
        this.interId = interId;
    }

    public double getDistance() {
        return this.distance;
    }

    public void setDistance(double distance) {
        this.distance = distance;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;


public class TextPropertyDto extends PropertyDto {
    public TextPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }


    @Override
    public String getType() {
        return TEXT;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;


public class DatePropertyDto extends PropertyDto {

    public DatePropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

//    @Override
//    public Property getProperty() {
//        return new DateProperty(this.weight);
//    }

    @Override
    public String getType() {
        return DATE;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;


public class TaxonomyPropertyDto extends PropertyDto {

    public TaxonomyPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }


    @Override
    public String getType() {
        return PropertyDto.TAXONOMY;
    }
}



public class WeightsDto {
    private float heteronymWeight;
    private float dateWeight;
    private float textWeight;
    private float taxonomyWeight;

    public WeightsDto() {
    }

    public WeightsDto(float heteronymWeight, float dateWeight, float textWeight, float taxonomyWeight) {
        this.heteronymWeight = heteronymWeight;
        this.dateWeight = dateWeight;
        this.textWeight = textWeight;
        this.taxonomyWeight = taxonomyWeight;
    }


    public float getHeteronymWeight() {
        return this.heteronymWeight;
    }

    public void setHeteronymWeight(float heteronymWeight) {
        this.heteronymWeight = heteronymWeight;
    }

    public float getDateWeight() {
        return this.dateWeight;
    }

    public void setDateWeight(float dateWeight) {
        this.dateWeight = dateWeight;
    }

    public float getTextWeight() {
        return this.textWeight;
    }

    public void setTextWeight(float textWeight) {
        this.textWeight = textWeight;
    }

    public float getTaxonomyWeight() {
        return this.taxonomyWeight;
    }

    public void setTaxonomyWeight(float taxonomyWeight) {
        this.taxonomyWeight = taxonomyWeight;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;


public class HeteronymPropertyDto extends PropertyDto {

    public HeteronymPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

//    @Override
//    public Property getProperty() {
//        return new HeteronymProperty(this.weight);
//    }

    @Override
    public String getType() {
        return HETERONYM;
    }

}



import pt.ist.socialsoftware.edition.notification.dtos.recommendation.WeightsDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;

import java.util.Set;

public class MostSimilarFragments {

    private FragmentDto toReadFragment;
    private Set<FragmentDto> toBeRecommended;
    private WeightsDto weightsDto;

    public MostSimilarFragments(FragmentDto fragmentDto, Set<FragmentDto> fragmentDtos, WeightsDto weightsDto) {
        this.toReadFragment = fragmentDto;
        this.toBeRecommended = fragmentDtos;
        this.weightsDto = weightsDto;
    }

    public FragmentDto getToReadFragment() {
        return toReadFragment;
    }

    public void setToReadFragment(FragmentDto toReadFragment) {
        this.toReadFragment = toReadFragment;
    }

    public Set<FragmentDto> getToBeRecommended() {
        return toBeRecommended;
    }

    public void setToBeRecommended(Set<FragmentDto> toBeRecommended) {
        this.toBeRecommended = toBeRecommended;
    }

    public WeightsDto getWeightsDto() {
        return weightsDto;
    }

    public void setWeightsDto(WeightsDto weightsDto) {
        this.weightsDto = weightsDto;
    }
}



import pt.ist.socialsoftware.edition.notification.dtos.recommendation.WeightsDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

public class IntersByDistance {

    private ScholarInterDto scholarInterDto;
    private WeightsDto weightsDto;
    private VirtualEditionInterDto virtualEditionInterDto;

    public IntersByDistance(ScholarInterDto scholarInterDto, WeightsDto weightsDto) {
        this.scholarInterDto = scholarInterDto;
        this.weightsDto = weightsDto;
    }

    public IntersByDistance(VirtualEditionInterDto virtualEditionInterDto, WeightsDto weightsDto) {
        this.virtualEditionInterDto = virtualEditionInterDto;
        this.weightsDto = weightsDto;
    }

    public ScholarInterDto getScholarInterDto() {
        return scholarInterDto;
    }

    public void setScholarInterDto(ScholarInterDto scholarInterDto) {
        this.scholarInterDto = scholarInterDto;
    }

    public WeightsDto getWeightsDto() {
        return weightsDto;
    }

    public void setWeightsDto(WeightsDto weightsDto) {
        this.weightsDto = weightsDto;
    }

    public VirtualEditionInterDto getVirtualEditionInterDto() {
        return virtualEditionInterDto;
    }

    public void setVirtualEditionInterDto(VirtualEditionInterDto virtualEditionInterDto) {
        this.virtualEditionInterDto = virtualEditionInterDto;
    }
}





import pt.ist.socialsoftware.edition.notification.dtos.recommendation.PropertyDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;

import java.util.List;

public class RecommendationVirtualEditionInter {

    private VirtualEditionInterDto inter;
    private String username;
    private VirtualEditionDto virtualEditionDto;
    private List<PropertyDto> properties;

    public RecommendationVirtualEditionInter(VirtualEditionInterDto inter,
                                             String username,
                                             VirtualEditionDto virtualEdition,
                                             List<PropertyDto> properties) {
        this.inter = inter;
        this.username = username;
        this.virtualEditionDto = virtualEdition;
        this.properties = properties;
    }

    public VirtualEditionInterDto getInter() {
        return inter;
    }

    public void setInter(VirtualEditionInterDto inter) {
        this.inter = inter;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public VirtualEditionDto getVirtualEditionDto() {
        return virtualEditionDto;
    }

    public void setVirtualEditionDto(VirtualEditionDto virtualEditionDto) {
        this.virtualEditionDto = virtualEditionDto;
    }

    public List<PropertyDto> getProperties() {
        return properties;
    }

    public void setProperties(List<PropertyDto> properties) {
        this.properties = properties;
    }
}


public class EventVirtualEditionUpdate extends Event {
    private String newAcronym;

    public EventVirtualEditionUpdate(String identifier, String newAcronym) {
        super(EventType.VIRTUAL_EDITION_UPDATE, identifier);
        this.newAcronym = newAcronym;
    }

    public String getNewAcronym() {
        return this.newAcronym;
    }

}


import java.io.Serializable;

public class Event implements Serializable {


    public enum EventType implements Serializable {
        FRAGMENT_REMOVE, SCHOLAR_INTER_REMOVE, USER_REMOVE, VIRTUAL_EDITION_REMOVE, VIRTUAL_EDITION_UPDATE,
        VIRTUAL_INTER_REMOVE, TAG_REMOVE, VIRTUAL_EXPORT, SIMPLE_TEXT_REMOVE
    }

    EventType type;

    String identifier;


    public Event(EventType type, String identifier) {
        this.type = type;
        this.identifier = identifier;
    }


    public EventType getType() {
        return this.type;
    }

    public String getIdentifier() {
        return this.identifier;
    }

    public void setType(EventType type) {
        this.type = type;
    }

    public void setIdentifier(String identifier) {
        this.identifier = identifier;
    }
}


public class EventTagRemove extends Event {
    private String interId;

    public EventTagRemove(String tagId, String interId) {
        super(EventType.TAG_REMOVE, tagId);
        this.interId = interId;
    }

    public String getInterId() {
        return interId;
    }
}


public interface SubscribeInterface {
    public void notify(Event event);
}


//import pt.ist.socialsoftware.edition.ldod.frontend.user.session.SessionRequiresInterface;
//import pt.ist.socialsoftware.edition.game.api.GameRequiresInterface;
//import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
//import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;

import groovy.transform.Synchronized;

import java.util.HashSet;
import java.util.Set;


public class EventInterface {

    private static EventInterface instance;

    public static EventInterface getInstance() {
        if (instance == null) {
            instance = new EventInterface();
        }
        return instance;
    }

    protected EventInterface() {}


    public Set<SubscribeInterface> subscribers = new HashSet<>();
//    private final VirtualRequiresInterface virtualRequiresInterface = new VirtualRequiresInterface();
//    private final GameRequiresInterface gameRequiresInterface = new GameRequiresInterface();
//    private final RecommendationRequiresInterface recommendationRequiresInterface = new RecommendationRequiresInterface();
//    private final SessionRequiresInterface sessionRequiresInterface = new SessionRequiresInterface();

    public void subscribe(SubscribeInterface subscriber){
        subscribers.add(subscriber);
    }


    public void publish(Event event) {
        for (int i = 0; i < subscribers.size(); i++) {
            ((SubscribeInterface) subscribers.toArray()[i]).notify(event);
        }

  //      subscribers.forEach(subscribeInterface -> subscribeInterface.notify(event));

//        this.virtualRequiresInterface.notifyEvent(event);
//        this.gameRequiresInterface.notifyEvent(event);
//        this.recommendationRequiresInterface.notifyEvent(event);
//        this.sessionRequiresInterface.notifyEvent(event);
    }
}


//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//
////import pt.ist.socialsoftware.edition.ldod.domain.VirtualEditionInter;
////import pt.ist.socialsoftware.edition.text.api.TextProvidesInterface;
////import pt.ist.socialsoftware.edition.text.domain.TextModule;
////import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
//
//
//import java.util.ArrayList;
//import java.util.List;
//
//// TO BE REMOVED SHOULD BE IN THE FRONTEND REQUIRES INTERFACES
//public class UiInterface {
//    private static final Logger logger = LoggerFactory.getLogger(UiInterface.class);
//
//    public List<FragInterDto> getFragInterUsed(VirtualEditionInter inter) {
//        List<FragInterDto> fragInterList = new ArrayList<>();
//        while (inter.getUses() != null) {
//            fragInterList.add(new FragInterDto(inter.getUses()));
//            inter = inter.getUses();
//        }
//
//        fragInterList.add(new FragInterDto(TextModule.getInstance().getScholarInterByXmlId(inter.getUsesScholarInterId())));
//
//        return fragInterList;
//    }
//
//    public boolean isExpertEdition(String acronym) {
//        TextProvidesInterface textProvidesInterface = new TextProvidesInterface();
//
//        return textProvidesInterface.isExpertEdition(acronym);
//    }
//
//    public boolean isVirtualEdition(String acronym) {
//        VirtualProvidesInterface virtualProvidesInterface = new VirtualProvidesInterface();
//
//        return virtualProvidesInterface.getVirtualEdition(acronym) != null;
//    }
//}



//import pt.ist.socialsoftware.edition.ldod.domain.VirtualEditionInter;
//import pt.ist.socialsoftware.edition.text.domain.ScholarInter;

//public class FragInterDto {
//
//    public enum InterType {
//        AUTHORIAL("authorial"), EDITORIAL("editorial"), VIRTUAL("virtual");
//
//        private final String desc;
//
//        InterType(String desc) {
//            this.desc = desc;
//        }
//
//        public String getDesc() {
//            return this.desc;
//        }
//    }
//
//    private InterType type;
//    private String fragmentXmlId;
//    private String urlId;
//    private String shortName;
//    private String externalId;
//
//
//    public FragInterDto(VirtualEditionInter uses) {
//        setType(InterType.VIRTUAL);
//        setFragmentXmlId(uses.getFragmentXmlId());
//        setUrlId(uses.getUrlId());
//        setShortName(uses.getShortName());
//        setExternalId(uses.getExternalId());
//    }
//
//    public FragInterDto(ScholarInter uses) {
//        setType(uses.isExpertInter() ? InterType.EDITORIAL : InterType.AUTHORIAL);
//        setFragmentXmlId(uses.getFragment().getXmlId());
//        setUrlId(uses.getUrlId());
//        setShortName(uses.getShortName());
//        setExternalId(uses.getExternalId());
//    }
//
//    public InterType getType() {
//        return this.type;
//    }
//
//    public void setType(InterType type) {
//        this.type = type;
//    }
//
//    public String getFragmentXmlId() {
//        return this.fragmentXmlId;
//    }
//
//    public void setFragmentXmlId(String fragmentXmlId) {
//        this.fragmentXmlId = fragmentXmlId;
//    }
//
//    public String getUrlId() {
//        return this.urlId;
//    }
//
//    public void setUrlId(String urlId) {
//        this.urlId = urlId;
//    }
//
//    public String getShortName() {
//        return this.shortName;
//    }
//
//    public void setShortName(String shortName) {
//        this.shortName = shortName;
//    }
//
//    public String getExternalId() {
//        return this.externalId;
//    }
//
//    public void setExternalId(String externalId) {
//        this.externalId = externalId;
//    }
//}


import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomLocalDateSerializer extends JsonSerializer<LocalDate> {

    private static DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");

    @Override
    public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider arg2)
            throws IOException, JsonProcessingException {

        gen.writeString(formatter.print(value));
    }
}


import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomDateTimeSerializer extends JsonSerializer<DateTime> {

    private static DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");

    @Override
    public void serialize(DateTime value, JsonGenerator gen, SerializerProvider arg2)
            throws IOException, JsonProcessingException {

        gen.writeString(formatter.print(value));
    }
}


import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomDateTimeDeserializer extends StdDeserializer<DateTime> {

    private static final long serialVersionUID = 1L;
    private static DateTimeFormatter format = DateTimeFormat.forPattern("yyyy-MM-dd");

    public CustomDateTimeDeserializer() {
        this(null);
    }

    public CustomDateTimeDeserializer(Class<DateTime> t) {
        super(t);
    }

    @Override
    public DateTime deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException {

        String date = parser.getText();

        return format.parseDateTime(date);

    }

}


import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.IOException;

public class CustomLocalDateDeserializer extends StdDeserializer<LocalDate> {

    private static final long serialVersionUID = 1L;
    private static DateTimeFormatter format = DateTimeFormat.forPattern("yyyy-MM-dd");

    public CustomLocalDateDeserializer() {
        this(null);
    }

    public CustomLocalDateDeserializer(Class<LocalDate> t) {
        super(t);
    }

    @Override
    public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException {

        String date = parser.getText();

        return format.parseLocalDate(date);

    }

}


import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import pt.ist.socialsoftware.edition.notification.event.Event;

import javax.jms.Queue;
import javax.jms.Topic;

@Component
public class VirtualEventPublisher {
    private static final Logger logger = LoggerFactory.getLogger(VirtualEventPublisher.class);


    @Autowired
    private final Topic queue = new ActiveMQTopic("test-topic");

    @Autowired
    private JmsTemplate jmsTemplate;


    @GetMapping("/publishEvent")
    public ResponseEntity<Event> publishEvent(Event event){
        jmsTemplate.convertAndSend(queue, event);
        logger.debug("published Event!");
        return new ResponseEntity(event, HttpStatus.OK);
    }

}



import org.springframework.http.HttpStatus;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.dtos.text.*;
import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;
import pt.ist.socialsoftware.edition.notification.event.Event;

import pt.ist.socialsoftware.edition.notification.event.EventInterface;
import pt.ist.socialsoftware.edition.notification.event.SubscribeInterface;
import pt.ist.socialsoftware.edition.virtual.domain.HumanAnnotation;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;
import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.USER_SERVICE_URL;

@Component
public class VirtualRequiresInterface implements SubscribeInterface {

    private static Map<String, ScholarInterDto> scholarInterMap = new HashMap<>();

    public static void cleanScholarInterMapCache() {
        scholarInterMap = new HashMap<>();
    }

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private static VirtualRequiresInterface instance;

    public static VirtualRequiresInterface getInstance() {
        if (instance == null) {
            instance = new VirtualRequiresInterface();
        }
        return instance;
    }

    protected VirtualRequiresInterface() {
    }


    @JmsListener(id = "2", containerFactory = "jmsListenerContainerFactory", destination = "test-topic")
    public void listener(Event message){
        this.notify(message);
    }


    @Atomic(mode = Atomic.TxMode.WRITE)
    // Requires asynchronous events
    public void notify(Event event) {
        if (event.getType().equals(Event.EventType.FRAGMENT_REMOVE)) {
            VirtualModule.getInstance().getVirtualEditionsSet().stream()
                    .flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream())
                    .filter(virtualEditionInter -> virtualEditionInter.getUsesScholarInterId() != null && virtualEditionInter.getFragmentXmlId().equals(event.getIdentifier()))
                    .forEach(this::removeAll);
        } else if (event.getType().equals(Event.EventType.SCHOLAR_INTER_REMOVE)) {

            VirtualModule.getInstance().getVirtualEditionsSet().stream()
                    .flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream())
                    .filter(virtualEditionInter -> virtualEditionInter.getUsesScholarInterId() != null && virtualEditionInter.getUsesScholarInterId().equals(event.getIdentifier()))
                    .forEach(this::removeAll);
        } else if (event.getType().equals(Event.EventType.USER_REMOVE)) {

            String username = event.getIdentifier();
            VirtualModule virtualModule = VirtualModule.getInstance();
            virtualModule.getVirtualEditionsSet().stream().flatMap(virtualEdition -> virtualEdition.getMemberSet().stream())
                    .filter(member -> member.getUser().equals(username))
                    .forEach(member -> member.remove());
            virtualModule.getVirtualEditionsSet().stream().flatMap(virtualEdition -> virtualEdition.getSelectedBySet().stream())
                    .filter(selectedBy -> selectedBy.getUser().equals(username))
                    .forEach(selectedBy -> selectedBy.remove());
            virtualModule.getVirtualEditionsSet().stream().flatMap(virtualEdition -> virtualEdition.getTaxonomy().getCategoriesSet().stream())
                    .flatMap(category -> category.getTagSet().stream())
                    .filter(tag -> tag.getContributor().equals(username))
                    .forEach(tag -> tag.remove());
            virtualModule.getVirtualEditionsSet().stream().flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream())
                    .flatMap(virtualEditionInter -> virtualEditionInter.getAnnotationSet().stream())
                    .filter(annotation -> annotation.getUser().equals(username))
                    .forEach(annotation -> annotation.remove());
        } else if (event.getType().equals(Event.EventType.SIMPLE_TEXT_REMOVE)){

            VirtualModule.getInstance().getVirtualEditionsSet().stream()
                    .flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream())
                    .flatMap(virtualEditionInter -> virtualEditionInter.getAnnotationSet().stream())
                    .filter(annotation -> annotation.isHumanAnnotation() && (((HumanAnnotation) annotation).getStartTextId().equals(event.getIdentifier())) || ((HumanAnnotation) annotation).getEndTextId().equals(event.getIdentifier()))
                    .forEach(annotation -> annotation.remove());
        }
    }

    private void removeAll(VirtualEditionInter vei) {
        for (VirtualEditionInter vi : vei.getIsUsedBySet()) {
            removeAll(vi);
        }
        vei.remove();
    }

    //Uses Text Module

    public Set<CitationDto> getCitationSet() {
        return webClient.build()
                .get()
                .uri("/citations")
                .retrieve()
                .bodyToFlux(CitationDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //       return this.textProvidesInterface.getCitationSet();
    }

    public CitationDto getCitationById(long id) {
        return webClient.build()
                .get()
                .uri("/citations/" + id)
                .retrieve()
                .bodyToMono(CitationDto.class)
                .blockOptional().get();
        //     return this.textProvidesInterface.getCitationById(id);
    }

    public List<CitationDto> getCitationsWithInfoRanges() {
        return webClient.build()
                .get()
                .uri("/citationsInfoRanges")
                .retrieve()
                .bodyToFlux(CitationDto.class)
                .collectList()
                .block();
    }

    public ScholarInterDto getScholarInterByXmlId(String xmlId) {
//        return webClient.get()
//                .uri("/scholarInter/" + xmlId)
//                .retrieve()
//                .bodyToMono(ScholarInterDto.class)
//                .blockOptional().get();
        return getScholarInterByXmlIdCache(xmlId).orElse(null);
        //    return this.textProvidesInterface.getScholarInter(xmlId);
    }

    public ScholarInterDto getScholarInterbyExternalId(String externalId) {
        return webClient.build()
                .get()
                .uri("/scholarInter/ext/" + externalId)
                .retrieve()
                .bodyToMono(ScholarInterDto.class)
                .blockOptional().get();
    }

    public void cleanLucene() {
        webClient.build()
                .get()
                .uri("/cleanLucene")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
        //    this.textProvidesInterface.cleanLucene();
    }

    public void removeAllCitations() {
        webClient.build()
                .delete()
                .uri("/removeAllCitations")
                .retrieve()
                .bodyToMono(Void.class)
                .block();
       // textProvidesInterface.removeAllCitations();
    }


    public FragmentDto getFragmentOfScholarInterDto(ScholarInterDto lastUsed) {
        return webClient.build()
                .get()
                .uri( "/scholarInter/fragment/" + lastUsed.getXmlId())
                .retrieve()
                .bodyToMono(FragmentDto.class)
                .blockOptional().get();
    }

    public FragmentDto getFragmentByXmlId(String xmlId) {
        return webClient.build()
                .get()
                .uri("/fragment/xmlId/" + xmlId)
                .retrieve()
                .bodyToMono(FragmentDto.class)
                .blockOptional().orElse(null);
    }
    
    


    public List<ScholarInterDto> getExpertEditionScholarInterDtoList(String acronymOfUsed) {
        return webClient.build()
                .get()
                .uri("/expertEdition/" + acronymOfUsed + "/scholarInterList")
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
    }

    public List<ScholarInterDto>  getScholarInterDtoListTwitterEdition(LocalDateTime editionBeginDateTime) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/scholarInter/fragment")
                        .queryParam("beginTime", editionBeginDateTime)
                        .build())
                .retrieve()
                .bodyToFlux(ScholarInterDto.class)
                .collectList()
                .block();
    }

    public void addDocumentToIndexer(String xmlId) throws IOException {
        webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/addDocument")
                        .queryParam("xmlId", xmlId)
                        .build())
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, clientResponse -> Mono.error(new IOException()))
                .bodyToMono(Void.class)
                .block();
    }


    public Set<InfoRangeDto> getInfoRangeDtoSetFromCitation(long id) {
        return webClient.build()
                .get()
                .uri("/citation/" + id + "/infoRange")
                .retrieve()
                .bodyToFlux(InfoRangeDto.class)
                .toStream()
                .collect(Collectors.toSet());
    }

    public boolean acronymExists(String acronym) {
        return webClient.build()
                .get()
                .uri("/expertEdition/" + acronym + "/exists")
                .retrieve()
                .bodyToMono(Boolean.class)
                .blockOptional().get();
    }

    public String getScholarInterTitle(String usesScholarInterId) {
//        return webClient.get()
//                .uri("/scholarInter/" + usesScholarInterId + "/title")
//                .retrieve()
//                .bodyToMono(String.class)
//                .blockOptional().get();
        ScholarInterDto scholarInterDto = getScholarInterByXmlIdCache(usesScholarInterId).orElse(null);
        return scholarInterDto != null ? scholarInterDto.getTitle() : null;
    }


    public String getWriteFromPlainTextFragmentWriter(String xmlId) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/writeFromPlainTextFragmentWriter")
                        .queryParam("xmlId", xmlId)
                        .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();
    }


    private Optional<ScholarInterDto> getScholarInterByXmlIdCache(String xmlId) {
        if (xmlId == null) {
            return Optional.empty();
        }
        ScholarInterDto scholarInterId = scholarInterMap.get(xmlId);
        if (scholarInterId == null) {
            scholarInterId = webClient.build()
                    .get()
                    .uri("/scholarInter/" + xmlId)
                    .retrieve()
                    .bodyToMono(ScholarInterDto.class)
                    .blockOptional().orElse(null);

            if (scholarInterId != null) {
                scholarInterMap.put(xmlId, scholarInterId);
            }
        }

        return Optional.ofNullable(scholarInterId);
    }

    public String getRepresentativeSourceInterExternalId(String fragmentXmlId) {
        return webClient.build()
                .get()
                .uri("/representativeSourceInter/" + fragmentXmlId + "/externalId")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional().get();
    }


    public void createInfoRange(long id, String xmlId, String s, int htmlStart, String s1, int htmlEnd, String infoQuote, String infoText) {
         webClient.build()
                .post()
                .uri( uriBuilder -> uriBuilder
                        .path("/createInfoRange")
                        .queryParam("id", id)
                        .queryParam("xmlId", xmlId)
                        .queryParam("s", s)
                        .queryParam("htmlStart", htmlStart)
                        .queryParam("s1", s1)
                        .queryParam("htmlEnd", htmlEnd)
                        .queryParam("infoQuote", infoQuote)
                        .queryParam("infoText", infoText)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public void createCitation(String fragXmlId, String sourceLink, String date, String fragText, long id) {
        webClient.build()
                .post()
                .uri( uriBuilder -> uriBuilder
                        .path("/createCitation")
                        .queryParam("fragXmlId", fragXmlId)
                        .queryParam("sourceLink", sourceLink)
                        .queryParam("date", date)
                        .queryParam("fragText", fragText)
                        .queryParam("id", id)
                        .build())
                .retrieve()
                .bodyToMono(Void.class)
                .block();
    }

    public String getWriteFromPlainHtmlWriter4OneInter(String xmlId, boolean highlightDiff) {
        return webClient.build()
                .get()
                .uri( uriBuilder -> uriBuilder
                        .path("/writeFromPlainHtmlWriter4OneInter/")
                        .queryParam("xmlId", xmlId)
                        .queryParam("highlightDiff", highlightDiff)
                        .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();

        //      return this.textProvidesInterface.getWriteFromPlainHtmlWriter4OneInter(xmlId, highlightDiff);
    }

    public Set<FragmentDto> getFragmentDtoSet() {
        return webClient.build()
                .get()
                .uri("/fragments")
                .retrieve()
                .bodyToFlux(FragmentDto.class)
                .toStream()
                .collect(Collectors.toSet());
    }

    public SimpleTextDto getSimpleTextFromExternalId(String startTextId) {
        return webClient.build()
                .get()
                .uri("/simpleText/" + startTextId)
                .retrieve()
                .bodyToMono(SimpleTextDto.class)
                .blockOptional().get();
    }

    // Uses User Service

    private final WebClient.Builder webClientUser = WebClient.builder().baseUrl(USER_SERVICE_URL);


    public UserDto getUser(String username) {
        return webClientUser.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                        .path("/user")
                        .queryParam("username", username)
                        .build())
                .retrieve()
                .bodyToMono(UserDto.class)
                .blockOptional()
                .orElse(null);
        //        return this.userProvidesInterface.getUser(username);
    }

    public String exportXMLUsers() {
        return webClientUser.build()
                .get()
                .uri("/exportXMLUsers")
                .retrieve()
                .bodyToMono(String.class)
                .blockOptional()
                .orElse("");
    }
}


import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.security.core.parameters.P;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.notification.dtos.text.CitationDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicListDTO;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;

import pt.ist.socialsoftware.edition.virtual.domain.*;


import pt.ist.socialsoftware.edition.virtual.api.dto.*;
import pt.ist.socialsoftware.edition.virtual.feature.inout.*;
import pt.ist.socialsoftware.edition.virtual.feature.socialaware.AwareAnnotationFactory;
import pt.ist.socialsoftware.edition.virtual.feature.socialaware.CitationDetecter;
import pt.ist.socialsoftware.edition.virtual.feature.socialaware.FetchCitationsFromTwitter;
import pt.ist.socialsoftware.edition.virtual.feature.socialaware.TweetFactory;
import pt.ist.socialsoftware.edition.virtual.feature.topicmodeling.TopicModeler;
import pt.ist.socialsoftware.edition.virtual.utils.*;


import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;


@RestController
@RequestMapping("/api")
public class VirtualProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(VirtualProvidesInterface.class);

    private static Map<String, String> virtualEditionMap = new HashMap<>();

    @PostMapping("/cleanVirtualEditionMapCache")
    public static void cleanVirtualEditionMapCache() {
        virtualEditionMap = new HashMap<>();
    }

    private static Map<String, String> virtualEditionInterMapByXmlId = new HashMap<>();

    @PostMapping("/cleanVirtualEditionInterMapByXmlIdCache")
    public static void cleanVirtualEditionInterMapByXmlIdCache() {
        virtualEditionInterMapByXmlId = new HashMap<>();
    }

    private static Map<String, String> virtualEditionInterMapByUrlId = new HashMap<>();

    @PostMapping("/cleanVirtualEditionInterMapByUrlIdCache")
    public static void cleanVirtualEditionInterMapByUrlIdCache() {
        virtualEditionInterMapByUrlId = new HashMap<>();
    }

    @GetMapping("/isInterInVirtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isInterInVirtualEdition(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "acronym") String acronym) {
       logger.debug("isInterInVirtualEdition: " + xmlId + ", " + acronym);
        return VirtualModule.getInstance().getVirtualEdition(acronym).getAllDepthVirtualEditionInters().stream()
                .anyMatch(virtualEditionInter -> virtualEditionInter.getXmlId().equals(xmlId));
    }

    @GetMapping("/virtualEdition/{acronym}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEdition(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEdition: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return new VirtualEditionDto(virtualEdition);
        }

        return null;
    }

    @GetMapping("/virtualEditions")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionDto> getVirtualEditions() {
       logger.debug("getVirtualEditions");
        return VirtualModule.getInstance().getVirtualEditionsSet().stream().map(VirtualEditionDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/virtualEdition/{acronym}/reference")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionReference(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionReference: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getReference).orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/isPublicOrIsUserParticipant")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isVirtualEditionPublicOrIsUserParticipant(@PathVariable("acronym") String acronym, @RequestParam(name = "username") String username) {
       logger.debug("isVirtualEditionPublicOrIsUserParticipant: " + acronym + ", " + username);
        return getVirtualEditionByAcronymUtil(acronym).orElseThrow(LdoDException::new).isPublicOrIsParticipant(username);
    }

    @GetMapping("/virtualEdition/{acronym}/isUserParticipant")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isUserParticipant(@PathVariable("acronym") String acronym, @RequestParam(name = "username") String username) {
       logger.debug("isUserParticipant: " + acronym + ", " + username);
        return getVirtualEditionByAcronymUtil(acronym).orElseThrow(LdoDException::new).getActiveMemberSet()
                .stream().anyMatch(m -> m.getUser().equals(username));
    }

    @GetMapping("/virtualEdition/{acronym}/virtualEditionInterOfFragment")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionInterDto> getVirtualEditionInterOfFragmentForVirtualEdition(@PathVariable("acronym") String acronym, @RequestParam(name = "xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterOfFragmentForVirtualEdition: " + acronym + ", " + xmlId);
        return getVirtualEditionByAcronymUtil(acronym)
                .map(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream()
                        .filter(virtualEditionInter -> virtualEditionInter
                                .getFragmentXmlId()
                                .equals(xmlId))
                        .map(VirtualEditionInterDto::new)
                        .collect(Collectors.toSet()))
                .orElse(new HashSet<>());
    }

    @GetMapping("/virtualEditions/getPublicVirtualEditionsOrUserIsParticipant")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionDto> getPublicVirtualEditionsOrUserIsParticipant(@RequestParam(name = "username") String username) {
       logger.debug("getPublicVirtualEditionsOrUserIsParticipant: " + username);
        return VirtualModule.getInstance().getPublicVirtualEditionsOrUserIsParticipant(username).stream().map(VirtualEditionDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/virtualEditionsInters/getVirtualEditionIntersUserIsContributor")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionInterDto> getVirtualEditionIntersUserIsContributor(@RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionIntersUserIsContributor: " + username);
        return VirtualModule.getInstance().getVirtualEditionIntersUserIsContributor(username).stream().map(VirtualEditionInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/virtualEditionsInters/getVirtualEditionIntersUserIsParticipant")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionDto> getVirtualEditionsUserIsParticipant(@RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionsUserIsParticipant: " + username);
        return VirtualModule.getInstance().getVirtualEditionsUserIsParticipant(username).stream().map(VirtualEditionDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/virtualEditionsInter/{interXmlId}/virtualEditionAcronym")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionAcronymByVirtualEditionInterXmlId(@PathVariable("interXmlId") String interXmlId) {
       logger.debug("getVirtualEditionAcronymByVirtualEditionInterXmlId: " + interXmlId);
        return getVirtualEditionInterByXmlId(interXmlId)
                .map(virtualEditionInter -> virtualEditionInter.getVirtualEdition().getAcronym())
                .orElse(null);
    }

    @GetMapping("/virtualEditionInterSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionInterDto> getVirtualEditionInterSet() {
       logger.debug("getVirtualEditionInterSet");
        return VirtualModule.getInstance().getVirtualEditionInterSet().stream().map(VirtualEditionInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/virtualEditionInterSet/{acronym}")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionInterDto> getVirtualEditionInterSet(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionInterSet: " + acronym);
        return VirtualModule.getInstance().getVirtualEdition(acronym).getAllDepthVirtualEditionInters().stream().map(VirtualEditionInterDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/scholarInter/ext/{interId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getScholarInterbyExternalId(String interId) {
       logger.debug("getScholarInterbyExternalId: " + interId);
        DomainObject domainObject = FenixFramework.getDomainObject(interId);

        if (domainObject instanceof VirtualEditionInter) {
            return ((VirtualEditionInter) domainObject).getLastUsed();
        }

        return null;
    }

    @GetMapping("/virtualEditionInter/{xmlId}/title")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionInterTitle(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterTitle: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getTitle).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/externalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionInterExternalId(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterExternalId: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getExternalId).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/fragmentXmlId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getFragmentXmlIdVirtualEditionInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getFragmentXmlIdVirtualEditionInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getFragmentXmlId).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/urlId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionInterUrlId(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterUrlId: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getUrlId).orElse(null);
    }

    @GetMapping("/virtualEditionInter/urlId/{urlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInterByUrlId(@PathVariable("urlId") String urlId) {
       logger.debug("getVirtualEditionInterByUrlId: " + urlId);
        return getVirtualEditionInterByUrlIdUtil(urlId).map(VirtualEditionInterDto::new).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/reference")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionInterReference(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterReference: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getReference).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/shortName")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionInterShortName(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterShortName: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getShortName).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/lastUsed")
    @Atomic(mode = Atomic.TxMode.READ)
    public ScholarInterDto getVirtualEditionLastUsedScholarInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionLastUsedScholarInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getLastUsed).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/uses")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInterUses(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterUses: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getUses).map(VirtualEditionInterDto::new).orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/title")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionTitleByAcronym(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionTitleByAcronym: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getTitle()).orElse(null);
    }

    @GetMapping("/publicVirtualEditionInterList")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionInterListDto> getPublicVirtualEditionInterListDto() {
       logger.debug("getPublicVirtualEditionInterListDto");
        return VirtualModule.getInstance().getVirtualEditionsSet().stream()
                .filter(virtualEdition -> virtualEdition.getPub())
                .map(virtualEdition -> new VirtualEditionInterListDto(virtualEdition, false))
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/sortedCategory")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getVirtualEditionSortedCategoryList(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionSortedCategoryList: " + acronym);
        return VirtualModule.getInstance()
                .getVirtualEdition(acronym)
                .getTaxonomy()
                .getCategoriesSet().stream()
                .map(Category::getName)
                .sorted()
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/fragmentCategories")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getFragmentCategoriesInVirtualEditon(@PathVariable("acronym") String acronym, @RequestParam(name = "xmlId") String xmlId) {
       logger.debug("getFragmentCategoriesInVirtualEditon: " + acronym + ", " + xmlId);
        return getVirtualEditionByAcronymUtil(acronym).orElse(null).getVirtualEditionInterSetForFragment(xmlId).stream()
                .flatMap(virtualEditionInter -> virtualEditionInter.getCategories().stream())
                .map(category -> category.getName())
                .distinct().collect(Collectors.toList());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/sortedCategoriesName")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getSortedVirtualEditionInterCategoriesName(@PathVariable("xmlId") String xmlId) {
       logger.debug("getSortedVirtualEditionInterCategoriesName: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).orElse(null).getCategories().stream()
                .map(category -> category.getName()).sorted()
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/sortedVirtualEditionInterCategories")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDto> getSortedVirtualEditionInterCategoriesFromVirtualEdition(@RequestParam(name = "xmlId") String xmlId, @PathVariable("acronym") String acronym) {
       logger.debug("getSortedVirtualEditionInterCategoriesFromVirtualEdition: " + xmlId + ", " + acronym);
        return getVirtualEditionInterByXmlId(xmlId).orElse(null).getCategories().stream()
                .filter(c -> c.getTaxonomy().getEdition().getAcronym() == acronym)
                .map(CategoryDto::new).sorted()
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/sortedVirtualEditionInterList")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionInterDto> getSortedVirtualEditionInterDtoList(@PathVariable("acronym") String acronym) {
       logger.debug("getSortedVirtualEditionInterDtoList: " + acronym);
        return VirtualModule.getInstance().getVirtualEdition(acronym).getAllDepthVirtualEditionInters().stream()
                .map(VirtualEditionInterDto::new).collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/acronym/{acronym}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionByAcronym(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionByAcronym: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEditionDto::new).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/number")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getVirtualEditionInterNumber(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterNumber: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter::getNumber).orElse(null);
    }

    @GetMapping("/categoriesUsedInTags")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDto> getCategoriesUsedInTags(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getCategoriesUsedInTags: " + xmlId + ", " + username);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        List<Category> categories = getVirtualEditionInterByXmlId(xmlId)
                .map(virtualEditionInter -> virtualEditionInter.getAllDepthCategoriesUsedInTags(username)).orElse(new ArrayList<>());
        return categories.stream().map(category -> new CategoryDto(category, inter, username)).collect(Collectors.toList());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthCategoriesUsedInTags")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDto> getVirtualEditionInterAllDepthCategoriesUsedInTags(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAllDepthCategoriesUsedInTags: " + xmlId + ", " + username);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        return getVirtualEditionInterByXmlId(xmlId)
                .map(virtualEditionInter -> virtualEditionInter.getAllDepthCategoriesUsedInTags(username).stream()
                        .map(category -> new CategoryDto(category, inter, username)).collect(Collectors.toList()))
                .orElse(new ArrayList<>());
    }


    @GetMapping("/virtualEditionInter/{xmlId}/allDepthCategoriesUsedByUserInTags")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDto> getVirtualEditionInterAllDepthCategoriesUsedByUserInTags(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAllDepthCategoriesUsedByUserInTags:" + xmlId + ", " + username );
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        List<Category> categories = getVirtualEditionInterByXmlId(xmlId).map(virtualEditionInter -> virtualEditionInter.getAllDepthCategoriesUsedByUserInTags(username)).orElse(new ArrayList<>());
        return categories.stream().map(category -> new CategoryDto(category, inter, username)).collect(Collectors.toList());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthCategoriesNotUsedInTags")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDto> getVirtualEditionInterAllDepthCategoriesNotUsedInTags(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAllDepthCategoriesNotUsedInTags: " + xmlId + ", " + username);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        List<Category> categories = getVirtualEditionInterByXmlId(xmlId)
                .map(virtualEditionInter -> virtualEditionInter.getAllDepthCategoriesNotUsedInTags(username)).orElse(new ArrayList<>());
        return categories.stream().map(category -> new CategoryDto(category, inter, username)).collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/taxonomyVocabularyStatus")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean getVirtualEditionTaxonomyVocabularyStatus(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionTaxonomyVocabularyStatus: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return virtualEdition.getTaxonomy().getOpenVocabulary();
        }
        return false;
    }

    @GetMapping("/virtualEdition/{acronym}/taxonomyAnnotationStatus")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean getVirtualEditionTaxonomyAnnotationStatus(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionTaxonomyAnnotationStatus: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return virtualEdition.getTaxonomy().getOpenAnnotation();
        }
        return false;
    }

    @GetMapping("/virtualEditionInter/{xmlId}/nextInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getNextVirtualInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getNextVirtualInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter.class::cast)
                .map(VirtualEditionInter::getNextNumberInter).map(VirtualEditionInterDto::new).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/prevInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getPrevVirtualInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getPrevVirtualInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInter.class::cast)
                .map(VirtualEditionInter::getPrevNumberInter).map(VirtualEditionInterDto::new).orElse(null);
    }

    @GetMapping("/virtualEditionInter/xmlId/{xmlId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId).map(VirtualEditionInterDto::new).orElseThrow(LdoDException::new);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/interFromModule")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInterFromModule(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionInterFromModule: " + xmlId);
        VirtualEditionInter inter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);

        if (inter != null) {
            return new VirtualEditionInterDto(inter);
        }
        return null;
    }

    @GetMapping("/virtualEditionInter/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInterByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getVirtualEditionInterByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof VirtualEditionInter) {
            return new VirtualEditionInterDto((VirtualEditionInter) domainObject);
        }

        return null;
    }

    @GetMapping("/virtualEdition/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getVirtualEditionByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof VirtualEdition) {
            return new VirtualEditionDto((VirtualEdition) domainObject);
        }

        return null;
    }

    @GetMapping("/virtualEditionInter/{xmlId}/virtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionOfVirtualEditionInter(@PathVariable("xmlId") String xmlId) {
       logger.debug("getVirtualEditionOfVirtualEditionInter: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId)
                .map(virtualEditionInter -> virtualEditionInter.getVirtualEdition())
                .map(VirtualEditionDto::new)
                .orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/externalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getVirtualEditionExternalIdByAcronym(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionExternalIdByAcronym: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getExternalId).orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthTagsNotHumanAnnotationAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<TagDto> getAllDepthTagsNotHumanAnnotationAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getAllDepthTagsNotHumanAnnotationAccessibleByUser: " + xmlId + ", " + username);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        return inter.getAllDepthTagsNotHumanAnnotationAccessibleByUser(username).stream().map(tag -> new TagDto(tag, inter)).collect(Collectors.toList());
    }


    @PostMapping("/createTagInInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public TagDto createTagInInter(@RequestParam(name = "editionId") String editionId, @RequestParam(name = "interId") String interId, @RequestParam(name = "tagName") String tagName, @RequestParam(name = "user") String user) {
       logger.debug("createTagInInter: " + editionId);
        VirtualEditionInter virtualEditionInter = getVirtualEditionInterByXmlId(interId).orElseThrow(LdoDException::new);
        VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(editionId);

        Tag tag = edition.getTaxonomy().createTag(virtualEditionInter, tagName, null, user);

        return new TagDto(tag, virtualEditionInter);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/tag")
    @Atomic(mode = Atomic.TxMode.READ)
    public TagDto getTagInInter(@PathVariable("xmlId") String xmlId, @RequestParam(name = "urlId") String urlId) {
        logger.debug(xmlId);
        logger.debug(urlId);
       logger.debug("getTagInInter: " + xmlId);

        VirtualEditionInter virtualEditionInter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        Tag tag = virtualEditionInter.getTagSet()
                .stream().filter(t -> t.getCategory().getUrlId().equals(urlId)).findAny().orElse(null);

        if (tag == null) {
            return null;
        }

        return new TagDto(tag, virtualEditionInter);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/tagCategory")
    @Atomic(mode = Atomic.TxMode.READ)
    public CategoryDto getTagCategory(@PathVariable("xmlId") String xmlId, @RequestParam(name = "urlId") String urlId) {
       logger.debug("getTagCategory: " + xmlId);
        VirtualEditionInter virtualEditionInter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        Tag tag = virtualEditionInter.getTagSet()
                .stream().filter(t -> t.getCategory().getUrlId().equals(urlId)).findAny().orElse(null);

        if (tag == null) {
            return null;
        }

        return new CategoryDto(tag.getCategory(), virtualEditionInter, null);
    }

    @PostMapping("/removeTagFromInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeTagFromInter(@RequestParam(name = "externalId") String externalId) {
       logger.debug("removeTagFromInter: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Tag) {
            ((Tag) domainObject).remove();
        }
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthAnnotationsAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<AnnotationDto> getAllDepthAnnotationsAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getAllDepthAnnotationsAccessibleByUser: " + xmlId);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        return inter.getAllDepthAnnotationsAccessibleByUser(username).stream()
                .map(annotation -> {
                    if (annotation instanceof HumanAnnotation) {
                        return new HumanAnnotationDto((HumanAnnotation) annotation, inter);
                    } else {
                        return new AwareAnnotationDto((AwareAnnotation) annotation);
                    }
                })
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/humanAnnotationsAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<HumanAnnotationDto> getVirtualEditionInterHumanAnnotationsAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterHumanAnnotationsAccessibleByUser: " + xmlId);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        return inter.getAllDepthAnnotationsAccessibleByUser(username).stream().filter(HumanAnnotation.class::isInstance)
                .map(HumanAnnotation.class::cast)
                .map(annotation -> new HumanAnnotationDto(annotation, inter))
                .collect(Collectors.toList());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/awareAnnotationsAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<AwareAnnotationDto> getVirtualEditionInterAwareAnnotationsAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAwareAnnotationsAccessibleByUser: " + xmlId + ", " + username);
        return getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new).getAllDepthAnnotationsAccessibleByUser(username)
                .stream().filter(AwareAnnotation.class::isInstance)
                .map(AwareAnnotation.class::cast)
                .map(AwareAnnotationDto::new)
                .collect(Collectors.toList());
    }

    @PostMapping("/associateVirtualEditionInterCategories")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void associateVirtualEditionInterCategories(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "username") String username, @RequestParam(name = "categories") Set<String> categories) {
       logger.debug("associateVirtualEditionInterCategories: " + xmlId + ", " + username + ", " + categories);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);

        if (username == null || !inter.getVirtualEdition().isPublicOrIsParticipant(username)) {
            throw new LdoDException("not authorized");
        }

        inter.associate(username, categories);
    }

    @PostMapping("/associateVirtualEditionInterCategoriesByExternalId")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void associateVirtualEditionInterCategoriesbyExternalId(@RequestParam(name = "externalId") String externalId, @RequestParam(name = "username") String username, @RequestParam(name = "categories") Set<String> categories) {
       logger.debug("associateVirtualEditionInterCategoriesByExternalId: " + externalId + ", " + username + ", " + categories);
        VirtualEditionInter inter = FenixFramework.getDomainObject(externalId);

        inter.associate(username, categories);
    }

    @PostMapping("/dissociateVirtualEditionInterCategory")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void dissociateVirtualEditionInterCategory(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "username") String username, @RequestParam(name = "categoryExternalId") String categoryExternalId) {
      logger.debug("dissociateVirtualEditionInterCategory: " + xmlId + ", " + username + ", " + categoryExternalId);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        Category category = FenixFramework.getDomainObject(categoryExternalId);
        if (category == null) {
            throw new LdoDException();
        }

        inter.dissociate(username, category);
    }

    @PostMapping("/saveVirtualEdition")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void saveVirtualEdition(@RequestParam(name = "acronym") String acronym, @RequestParam(name = "inters") String[] inters) {
       logger.debug("saveVirtualEdition: " + acronym + ", " + inters);
        if (inters != null) {
            VirtualEdition virtualEdition = getVirtualEditionByAcronymUtil(acronym).get();

            List<VirtualEditionInter> virtualEditionInters =
                    Arrays.stream(inters).map(externalId -> (VirtualEditionInter) FenixFramework.getDomainObject(externalId)).collect(Collectors.toList());

            virtualEdition.save(virtualEditionInters);
            virtualEditionMap.replace(acronym, virtualEdition.getExternalId());
        }
    }


    @PostMapping("/createVirtualEdition")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createVirtualEdition(@RequestParam(name = "username") String username, @RequestParam(name = "acronym") String acronym,
                                     @RequestParam(name = "title") String title, @RequestParam(name = "pub") boolean pub,
                                     @RequestParam(name = "acronymOfUsed", required = false) String acronymOfUsed, @RequestParam(name = "inters", required = false) String[] inters) {
       logger.debug("createVirtualEdition: " + username + ", " + acronym);

        VirtualEdition virtualEdition = VirtualModule.getInstance().createVirtualEdition(username,
                VirtualEdition.ACRONYM_PREFIX + acronym, title, new LocalDate(), pub, acronymOfUsed);

        if (inters != null) {
            VirtualEditionInter virtualInter;
            for (int i = 0; i < inters.length; i++) {
                virtualInter = FenixFramework.getDomainObject(inters[i]);
                virtualEdition.createVirtualEditionInter(virtualInter, i + 1);
            }
        }
    }

    @GetMapping("/isLdoDEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean isLdoDEdition(@RequestParam(name = "acronym") String acronym) {
       logger.debug("isLdoDEdition: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.isLdoDEdition()).orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/adminSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getVirtualEditionAdminSet(@PathVariable(name = "acronym") String acronym) {
       logger.debug("getVirtualEditionAdminSet: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getAdminSet()).orElse(new HashSet<>());
    }

    @GetMapping("/virtualEdition/{external}/adminSetByExternalId")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getVirtualEditionAdminSetByExternalId(@PathVariable("external") String external) {
        VirtualEdition virtualEdition = FenixFramework.getDomainObject(external);
       if (virtualEdition != null) {
           return virtualEdition.getAdminSet();
       }
        return new HashSet<>();
    }

    @GetMapping("/virtualEdition/{acronym}/participants")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getVirtualEditionParticipantSet(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionParticipantSet: " + acronym);
//        cleanVirtualEditionMapCache();
        return VirtualModule.getInstance().getVirtualEdition(acronym).getParticipantSet();
//        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getParticipantSet()).orElse(new HashSet<>());
    }


    @GetMapping("/virtualEdition/{acronym}/pending")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getVirtualEditionPendingSet(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionPendingSet: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym)
                .map(virtualEdition -> virtualEdition.getPendingSet().stream()
                        .map(userDto -> userDto.getUsername()).collect(Collectors.toSet()))
                .orElse(new HashSet<>());
    }

    @GetMapping("/virtualEdition/{acronym}/pub")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean getVirtualEditionPub(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionPub: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getPub()).orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/date")
    @Atomic(mode = Atomic.TxMode.READ)
    public LocalDate getVirtualEditionDate(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionDate: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getDate()).orElse(null);
    }

    @GetMapping("/userSelectedVirtualEditions")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getSelectedVirtualEditionsByUser(@RequestParam(name = "username") String username) {
       logger.debug("userSelectedVirtualEditions: " + username);
        return VirtualModule.getInstance().getUserSelectedVirtualEditions(username);
    }

    @PostMapping("/addToUserSelectedVirtualEditions")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addToUserSelectedVirtualEditions(@RequestParam(name = "username") String username, @RequestParam(name = "selectedAcronyms") List<String> selectedAcronyms) {
       logger.debug("addToUserSelectedVirtualEditions: " + username);
        VirtualModule.getInstance().addToUserSelectedVirtualEditions(username, selectedAcronyms);
    }

    @PostMapping("/removeVirtualEditionSelectedByUser")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeVirtualEditionSelectedByUser(@RequestParam(name = "user") String user, @RequestParam(name = "virtualEditionAcronym") String virtualEditionAcronym) {
       logger.debug("removeVirtualEditionSelectedByUser: " + user);
        getVirtualEditionByAcronymUtil(virtualEditionAcronym).get().removeSelectedByUser(user);
    }

    @PostMapping("/addVirtualEditionSelectedByUser")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addVirtualEditionSelectedByUser(@RequestParam(name = "user") String user, @RequestParam(name = "virtualEditionAcronym") String virtualEditionAcronym) {
       logger.debug("addVirtualEditionSelectedByUser: " + user);
        getVirtualEditionByAcronymUtil(virtualEditionAcronym).get().addSelectedByUser(user);
    }

    @GetMapping("/virtualEdition/{acronym}/canAddFragInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canAddFragInter(@PathVariable("acronym") String acronym, @RequestParam(name = "interXmlId") String interXmlId) {
       logger.debug("canAddFragInter: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.canAddFragInter(interXmlId)).orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/canManipulateAnnotation")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canManipulateAnnotation(@PathVariable("acronym") String acronym, @RequestParam(name = "username") String username) {
       logger.debug("canManipulateAnnotation: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym)
                .map(virtualEdition -> virtualEdition.getTaxonomy().canManipulateAnnotation(username))
                .orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/openVocabulary")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean getOpenVocabulary(@PathVariable("acronym") String acronym) {
       logger.debug("getOpenVocabulary: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym)
                .map(virtualEdition -> virtualEdition.getTaxonomy().getOpenVocabulary())
                .orElse(false);
    }


    @GetMapping("/virtualEditionInter/{xmlId}/allDepthCategoriesJSON")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getAllDepthCategoriesJSON(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getAllDepthCategoriesJSON: " + xmlId);
        return getVirtualEditionInterByXmlId(xmlId)
                .map(virtualEditionInter -> virtualEditionInter.getAllDepthCategoriesJSON(username))
                .orElse(null);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthTagsAcessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<TagDto> getVirtualEditionInterAllDepthTagsAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAllDepthTagsAccessibleByUser: " + xmlId);
        VirtualEditionInter virtualEditionInter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(() -> new LdoDException());
        return getVirtualEditionInterByXmlId(xmlId)
                .map(vei -> vei.getAllDepthTagsAccessibleByUser(username).stream()
                        .map(tag -> new TagDto(tag, virtualEditionInter))
                        .collect(Collectors.toSet()))
                .orElse(new HashSet<>());
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allTags")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<TagDto> getAllTags(@PathVariable("xmlId") String xmlId) {
       logger.debug("getAllTags: " + xmlId);
        VirtualEditionInter virtualEditionInter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(() -> new LdoDException());
        return getVirtualEditionInterByXmlId(xmlId)
                .map(vei -> vei.getTagSet().stream()
                        .map(tag -> new TagDto(tag, virtualEditionInter))
                        .collect(Collectors.toSet()))
                .orElse(new HashSet<>());
    }

    @GetMapping("/taxonomy/{externalId}/virtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionOfTaxonomyByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getVirtualEditionOfTaxonomyByExternalId: " + externalId);
        Taxonomy taxonomy = FenixFramework.getDomainObject(externalId);
        if (taxonomy != null) {
            return new VirtualEditionDto(taxonomy.getEdition());
        }
        return null;
    }

    @GetMapping("/category/{externalId}/virtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionOfCategoryByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getVirtualEditionOfCategoryByExternalId: " + externalId);
        Category category = FenixFramework.getDomainObject(externalId);
        if (category != null) {
            return new VirtualEditionDto(category.getTaxonomy().getEdition());
        }
        return null;
    }

    @GetMapping("/tag/{externalId}/virtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getVirtualEditionOfTagByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getVirtualEditionOfTagByExternalId: " + externalId);
        Tag tag = FenixFramework.getDomainObject(externalId);
        if (tag != null) {
            return new VirtualEditionDto(tag.getInter().getEdition());
        }
        return null;
    }

    @GetMapping("/virtualEdition/{acronym}/canManipulateTaxonomy")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canManipulateTaxonomy(@PathVariable("acronym") String acronym, @RequestParam(name = "username") String username) {
       logger.debug("canManipulateTaxonomy: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym)
                .map(virtualEdition -> virtualEdition.getTaxonomy()
                        .canManipulateTaxonomy(username)).orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/taxonomy")
    @Atomic(mode = Atomic.TxMode.READ)
    public TaxonomyDto getVirtualEditionTaxonomy(@PathVariable("acronym") String acronym) {
       logger.debug("getVirtualEditionTaxonomy: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getTaxonomy).map(TaxonomyDto::new).orElse(null);
    }

    @PostMapping("/loadTEICorpusVirtual")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void loadTEICorpusVirtual(@RequestBody byte[] inputStream) {
       logger.debug("loadTEICorpusVirtual");
        new VirtualEditionsTEICorpusImport().loadTEICorpusVirtual(new ByteArrayInputStream(inputStream));
    }

    @PostMapping("/loadTEIFragmentCorpus")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void loadTEIFragmentCorpus(@RequestBody Set<FragmentDto> fragments) {
       logger.debug("loadTEIFragmentCorpus");
        new GenerateTEIFragmentsCorpus().LoadFragmentCorpus(fragments);
    }

    @GetMapping("/virtualEdition/{acronym}/categoriesFromTaxonomy")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<CategoryDto> getCategoriesFromTaxonomy(@PathVariable("acronym") String acronym) {
       logger.debug("getCategoriesFromTaxonomy: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(virtualEdition -> virtualEdition.getTaxonomy().getCategoriesSet().stream()
                .map(CategoryDto::new)
                .collect(Collectors.toSet()))
                .orElse(new HashSet<>());
        //        return VirtualModule.getInstance().getVirtualEdition(acronym).getTaxonomy().getCategoriesSet().stream().map(CategoryDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/category/{externalId}/sortedInters")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionInterDto> getSortedInterFromCategoriesTag(@PathVariable("externalId") String externalId) {
       logger.debug("getSortedInterFromCategoriesTag: " + externalId);
        Category category = FenixFramework.getDomainObject(externalId);
        if (category != null) {
            return category.getSortedInters().stream().map(VirtualEditionInterDto::new).collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    @GetMapping(value = "/category/{externalId}/sortedInters", params = "acronym")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionInterDto> getSortedInterFromCategoriesTag(@PathVariable("externalId") String externalId, @RequestParam(name = "acronym", required = false) String acronym) {
       logger.debug("getSortedInterFromCategoriesTag: " + acronym);
        Category category = FenixFramework.getDomainObject(externalId);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (category != null && virtualEdition != null) {
            return category.getSortedInters(virtualEdition).stream().map(VirtualEditionInterDto::new).collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    @GetMapping("/category/{externalId}/sortedUsers")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getSortedUsersFromCategoriesTag(@PathVariable("externalId") String externalId) {
       logger.debug("getSortedUsersFromCategoriesTag: " + externalId );
        Category category = FenixFramework.getDomainObject(externalId);
        if (category != null) {
            return category.getSortedUsers();
        }
        return new ArrayList<>();
    }

    @GetMapping("/category/{externalId}/sortedEditions")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionDto> getSortedEditionsFromCategoriesTag(@PathVariable("externalId") String externalId) {
       logger.debug("getSortedEditionsFromCategoriesTag: " + externalId);
        Category category = FenixFramework.getDomainObject(externalId);
        if (category != null) {
            return category.getSortedEditions().stream().map(VirtualEditionDto::new).collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    @GetMapping("/virtualEditionInter/{xmlId}/contributorSet")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<String> getContributorSetFromVirtualEditionInter(@RequestParam(name = "externalId") String externalId, @PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getContributorSetFromVirtualEditionInter: " + xmlId);
        Category category = FenixFramework.getDomainObject(externalId);
        VirtualEditionInter inter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);

        if (category != null && inter != null) {
            Set<Tag> tagsAccessibleByUser = inter.getAllDepthTagsAccessibleByUser(username);
            return category.getTagSet().stream()
                    .filter(tag -> tagsAccessibleByUser.contains(tag))
                    .map(t -> t.getContributor())
                    .collect(Collectors.toSet());
        }
        return new HashSet<>();
    }

    @GetMapping("/annotation/{externalId}/ranges")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<RangeJson> getRangeSetFromAnnotation(@PathVariable("externalId") String externalId) {
       logger.debug("getRangeSetFromAnnotation: " + externalId);
        Annotation annotation = FenixFramework.getDomainObject(externalId);
        if (annotation != null) {
            return annotation.getRangeSet().stream().map(RangeJson::new).collect(Collectors.toSet());
        }
        return new HashSet<>();
    }

    @PostMapping("/createHumanAnnotation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public HumanAnnotationDto createHumanAnnotation(@RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "quote") String quote, @RequestParam(name = "text") String text, @RequestParam(name = "user") String user, @RequestBody List<RangeJson> ranges, @RequestParam(name = "tags") List<String> tags) {
      logger.debug("createHumanAnnotation: " + xmlId);
        VirtualEditionInter inter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);
        if (inter != null) {
            return new HumanAnnotationDto(inter.createHumanAnnotation(quote, text, user, ranges, tags), inter);
        }
        return null;
    }

    @GetMapping("/humanAnnotation/ext/{Id}")
    @Atomic(mode = Atomic.TxMode.READ)
    public HumanAnnotationDto getHumanAnnotationfromId(@PathVariable("Id") String Id) {
       logger.debug("getHumanAnnotationfromId: " + Id);
        HumanAnnotation annotation = FenixFramework.getDomainObject(Id);
        if (annotation != null) {
            return new HumanAnnotationDto(annotation, annotation.getVirtualEditionInter());
        }
        return null;
    }

    @GetMapping("/humanAnnotation/{Id}/canUserUpdate")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canUserUpdateHumanAnnotation(@PathVariable("Id") String Id, @RequestParam(name = "user") String user) {
       logger.debug("canUserUpdateHumanAnnotation: " + user);
        HumanAnnotation annotation = FenixFramework.getDomainObject(Id);
        if (annotation != null) {
            return annotation.canUpdate(user);
        }
        return false;
    }

    @PostMapping("/humanAnnotation/{id}/update")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public HumanAnnotationDto updateHumanAnnotation(@PathVariable("id") String id, @RequestParam(name = "text") String text, @RequestParam(name = "tags") List<String> tags) {
       logger.debug("updateHumanAnnotation: " + id);
        HumanAnnotation annotation = FenixFramework.getDomainObject(id);
        if (annotation != null) {
            annotation.update(text, tags);
            return new HumanAnnotationDto(annotation, annotation.getVirtualEditionInter());
        }
        return null;
    }

    @GetMapping("/humanAnnotation/{id}/canUserDelete")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canUserDeleteHumanAnnotation(@PathVariable("id") String id, @RequestParam(name = "user") String user) {
       logger.debug("canUserDeleteHumanAnnotation: " + id);
        HumanAnnotation annotation = FenixFramework.getDomainObject(id);
        if (annotation != null) {
            return annotation.canDelete(user);
        }
        return false;
    }

    @PostMapping("/removeHumanAnnotation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeHumanAnnotation(@RequestParam(name = "id") String id) {
       logger.debug("removeHumanAnnotation: " + id);
        HumanAnnotation annotation = FenixFramework.getDomainObject(id);
        if (annotation != null) {
            annotation.remove();
        }
    }

    @GetMapping("/archiveVirtualEdition")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionDto getArchiveVirtualEdition() {
       logger.debug("getArchiveVirtualEdition");
        VirtualEdition archive = VirtualModule.getInstance().getArchiveEdition();
        if (archive != null) {
            return new VirtualEditionDto(VirtualModule.getInstance().getArchiveEdition());
        }
        return null;
    }

    @PostMapping("/virtualEdition/{xmlId}/edit")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void editVirtualEdition(@PathVariable("xmlId") String xmlId, @RequestParam(name = "acronym") String acronym, @RequestParam(name = "title") String title, @RequestParam(name = "synopsis") String synopsis, @RequestParam(name = "pub") boolean pub, @RequestParam(name = "management") boolean management, @RequestParam(name = "vocabulary") boolean vocabulary, @RequestParam(name = "annotation") boolean annotation, @RequestParam(name = "mediaSource") String mediaSource, @RequestParam(name = "beginDate") String beginDate, @RequestParam(name = "endDate") String endDate, @RequestParam(name = "geoLocation") String geoLocation, @RequestParam(name = "frequency") String frequency) {
      logger.debug("editVirtualEdition: " + xmlId);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEditionByXmlId(xmlId);
        if (virtualEdition != null) {
            virtualEdition.edit(VirtualEdition.ACRONYM_PREFIX + acronym, title, synopsis, pub, management, vocabulary, annotation, mediaSource, beginDate, endDate, geoLocation, frequency);
        }
    }

    @PostMapping("/searchForAwareAnnotations")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void searchForAwareAnnotations(@RequestParam(name = "externalId") String externalId) {
       logger.debug("searchForAwareAnnotations: " + externalId);
        VirtualEdition virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition != null) {
            AwareAnnotationFactory awareFactory = new AwareAnnotationFactory();
            if (virtualEdition.isSAVE()) {
                awareFactory.searchForAwareAnnotations(virtualEdition);
            }
            // this virtual edition is not SAVE anymore, therefore we have to remove all the
            // aware annotations
            else {
                for (VirtualEditionInter inter : virtualEdition.getAllDepthVirtualEditionInters()) {
                    awareFactory.removeAllAwareAnnotationsFromVEInter(inter);
                }
            }
        }
    }

    @PostMapping("/removeVirtualEdition")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeVirtualEditionByExternalId(@RequestParam(name = "externalId") String externalId) {
       logger.debug("removeVirtualEditionByExternalId: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            virtualEditionMap.clear();
            virtualEditionInterMapByXmlId.clear();
            virtualEditionInterMapByUrlId.clear();
            ((VirtualEdition) virtualEdition).remove();
        }
    }

    @PostMapping("/virtualEdition/{externalId}/updateVirtualEditionInters")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateVirtualEditionInters(@PathVariable("externalId") String externalId, @RequestParam(name = "fragIntersXmlIds") List<String> fragIntersXmlIds) {
       logger.debug("updateVirtualEditionInters: " + externalId );
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).updateVirtualEditionInters(fragIntersXmlIds);
        }
    }

    @PostMapping("/virtualEdition/{externalId}/addMember")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addMemberByExternalId(@PathVariable("externalId") String externalId, @RequestParam(name = "user") String user, @RequestParam(name = "b") boolean b) {
       logger.debug("addMemberByExternalId: " + externalId + ", " + user);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).addMember(user, Member.MemberRole.MEMBER, b);
        }
    }

    @PostMapping("/virtualEdition/{externalId}/cancelParticipationSubmission")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void cancelParticipationSubmissionByExternalId(@PathVariable("externalId") String externalId, @RequestParam(name = "user") String user) {
       logger.debug("cancelParticipationSubmissionByExternalId: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).cancelParticipationSubmission(user);
        }
    }

    @PostMapping("/virtualEdition/{externalId}/addApprove")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addApproveByExternalId(@PathVariable("externalId") String externalId, @RequestParam(name = "username") String username) {
       logger.debug("addApproveByExternalId: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).addApprove(username);
        }
    }

    @PostMapping("/virtualEdition/{externalId}/canSwitchRole")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public boolean canSwitchRole(@PathVariable("externalId") String externalId, @RequestParam(name = "authenticatedUser") String authenticatedUser, @RequestParam(name = "username") String username) {
       logger.debug("canSwitchRole: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            return ((VirtualEdition) virtualEdition).canSwitchRole(authenticatedUser, username);
        }
       return false;
    }

    @PostMapping("/virtualEdition/{externalId}/switchRole")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void switchRole(@PathVariable("externalId") String externalId, @RequestParam(name = "username") String username) {
       logger.debug("switchRole: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).switchRole(username);
        }
    }

    @GetMapping("/virtualEdition/{externalId}/canRemoveMember")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canRemoveMember(@PathVariable("externalId") String externalId, @RequestParam(name = "authenticatedUser") String authenticatedUser, @RequestParam(name = "user") String user) {
       logger.debug("canRemoveMember: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            return ((VirtualEdition) virtualEdition).canRemoveMember(authenticatedUser, user);
        }
        return false;
    }


    @PostMapping("/virtualEdition/{externalId}/removeMember")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeMember(@PathVariable("externalId") String externalId, @RequestParam(name = "user") String user) {
       logger.debug("removeMember: " +externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).removeMember(user);
        }
    }

    @PostMapping("/createVirtualEditionInterFromScholarInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public VirtualEditionInterDto createVirtualEditionInterFromScholarInter(@RequestParam(name = "externalId") String externalId, @RequestParam(name = "xmlId") String xmlId, @RequestParam(name = "max") int max) {
       logger.debug("createVirtualEditionInterFromScholarInter: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        ScholarInterDto scholarInterDto = VirtualRequiresInterface.getInstance().getScholarInterByXmlId(xmlId);
        if (virtualEdition instanceof VirtualEdition && scholarInterDto != null) {
            return new VirtualEditionInterDto(((VirtualEdition) virtualEdition).createVirtualEditionInter(scholarInterDto, max));
        }
        return null;
    }

    @PostMapping("/createVirtualEditionInterFromVirtualEditionInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public VirtualEditionInterDto createVirtualEditionInterFromVirtualEditionInter(@RequestParam(name = "externalId") String externalId, @RequestParam(name = "interExternalId") String interExternalId, @RequestParam(name = "max") int max) {
       logger.debug("createVirtualEditionInterFromVirtualEditionInter: " + externalId);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        DomainObject inter = FenixFramework.getDomainObject(interExternalId);
        if (virtualEdition instanceof VirtualEdition && inter instanceof VirtualEditionInter) {
            return new VirtualEditionInterDto(((VirtualEdition) virtualEdition).createVirtualEditionInter((VirtualEditionInter) inter , max));
        }
        return null;
    }

    @PostMapping("/taxonomy/{editionAcronym}/edit")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void editTaxonomy(@PathVariable("editionAcronym") String editionAcronym, @RequestParam(name = "management") boolean management, @RequestParam(name = "vocabulary") boolean vocabulary, @RequestParam(name = "annotation") boolean annotation) {
       logger.debug("editTaxonomy: " + editionAcronym);
        getVirtualEditionByAcronymUtil(editionAcronym).map(VirtualEdition_Base::getTaxonomy).ifPresent(taxonomy -> taxonomy.edit(management, vocabulary, annotation));
    }

    @PostMapping("/generateTopicModeler")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public TopicListDTO generateTopicModeler(@RequestParam(name = "username") String username, @RequestParam(name = "externalId") String externalId, @RequestParam(name = "numTopics") int numTopics, @RequestParam(name = "numWords") int numWords, @RequestParam(name = "thresholdCategories") int thresholdCategories, @RequestParam("numIterations") int numIterations) throws IOException {
       logger.debug("generateTopicModeler: " + username);
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            TopicModeler topicModeler = new TopicModeler();
            return topicModeler.generate(username, (VirtualEdition) virtualEdition, numTopics, numWords, thresholdCategories, numIterations);
        }
        return null;
    }

    @PostMapping("/createGeneratedCategories")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createGeneratedCategories(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestBody TopicListDTO topicList) {
//        VirtualModule.getInstance().getVirtualEdition(editionAcronym).getTaxonomy().createGeneratedCategories(topicList);
      logger.debug("createGeneratedCategories: " + editionAcronym);
        getVirtualEditionByAcronymUtil(editionAcronym).map(VirtualEdition_Base::getTaxonomy).ifPresent(taxonomy -> taxonomy.createGeneratedCategories(topicList));
    }

    @GetMapping("/taxonomy/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public TaxonomyDto getTaxonomyByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getTaxonomyByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof Taxonomy) {
            return new TaxonomyDto((Taxonomy) domainObject);
        }
        return null;
    }

    @PostMapping("/removeTaxonomy")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeTaxonomy(@RequestParam(name = "editionAcronym") String editionAcronym) {
       logger.debug("removeTaxonomy: " + editionAcronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(editionAcronym);
        if (virtualEdition != null) {
            virtualEdition.getTaxonomy().remove();
            virtualEdition.setTaxonomy(new Taxonomy());
        }
    }

    @PostMapping("/createCategory")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createCategory(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestParam(name = "name") String name) {
       logger.debug("createCategory: " + editionAcronym);
        getVirtualEditionByAcronymUtil(editionAcronym).map(VirtualEdition_Base::getTaxonomy).ifPresent(taxonomy -> taxonomy.createCategory(name));
    }

    @GetMapping("/category/ext/{externalId}")
    @Atomic(mode = Atomic.TxMode.READ)
    public CategoryDto getCategoryByExternalId(@PathVariable("externalId") String externalId) {
       logger.debug("getCategoryByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Category) {
            return new CategoryDto((Category) domainObject);
        }

        return null;
    }

    @PostMapping("/category/{externalId}/updateName")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateCategoryNameByExternalId(@PathVariable("externalId") String externalId, @RequestParam(name = "name") String name) {
       logger.debug("updateCategoryNameByExternalId: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);
        if (domainObject instanceof Category) {
            ((Category) domainObject).setName(name);
        }
    }

    @PostMapping("/category/{externalId}/remove")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeCategory(@PathVariable("externalId") String externalId) {
       logger.debug("removeCategory: " + externalId);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Category) {
            ((Category) domainObject).remove();
        }

    }

    @PostMapping("/mergeCategories")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public CategoryDto mergeCategories(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestBody List<CategoryDto> categories) {
       logger.debug("mergeCategories: " + editionAcronym);
        List<Category> categoryList = categories.stream().map(categoryDto -> (Category) FenixFramework.getDomainObject(categoryDto.getExternalId())).collect(Collectors.toList());
        return new CategoryDto(VirtualModule.getInstance().getVirtualEdition(editionAcronym).getTaxonomy().merge(categoryList));
    }

    @PostMapping("/deleteCategories")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void deleteCategories(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestBody List<CategoryDto> categories) {
       logger.debug("deleteCategories: " + editionAcronym);
        List<Category> categoryList = categories.stream().map(categoryDto -> (Category) FenixFramework.getDomainObject(categoryDto.getExternalId())).collect(Collectors.toList());
        VirtualModule.getInstance().getVirtualEdition(editionAcronym).getTaxonomy().delete(categoryList);
    }

    @PostMapping("/extractCategories")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public CategoryDto extractCategories(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestParam(name = "externalId") String externalId, @RequestBody String[] interIds) {
       logger.debug("extractCategories: " + editionAcronym);
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Category) {
            Category category = ((Category) domainObject);
            Set<VirtualEditionInter> inters = Arrays.stream(interIds).map(s -> (VirtualEditionInter) FenixFramework.getDomainObject(s)).collect(Collectors.toSet());
            return new CategoryDto(VirtualModule.getInstance().getVirtualEdition(editionAcronym).getTaxonomy().extract(category, inters));
        }
        return null;

    }

    @GetMapping("/virtualEdition/{acronym}/mediaSource")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getMediaSourceName(@PathVariable("acronym") String acronym) {
       logger.debug("getMediaSourceName: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition:: getMediaSource).map(MediaSource::getName).orElse(null);

    }

    @GetMapping("/virtualEdition/{acronym}/timeWindowBeginDate")
    @Atomic(mode = Atomic.TxMode.READ)
    public LocalDate getTimeWindowBeginDate(@PathVariable("acronym") String acronym) {
       logger.debug("getTimeWindowBeginDate: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getTimeWindow).map(TimeWindow::getBeginDate).orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/timeWindowEndDate")
    @Atomic(mode = Atomic.TxMode.READ)
    public LocalDate getTimeWindowEndDate(@PathVariable("acronym") String acronym) {
       logger.debug("getTimeWindowEndDate: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getTimeWindow).map(TimeWindow::getEndDate).orElse(null);
    }

    @GetMapping("/virtualEdition/{acronym}/containsEveryCountryinGeographicLocation")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean containsEveryCountryinGeographicLocation(@PathVariable("acronym") String acronym) {
       logger.debug("containsEveryCountryinGeographicLocation: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getGeographicLocation).map(GeographicLocation::containsEveryCountry).orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/containsCountryinGeographicLocation")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean containsCountryinGeographicLocation(@PathVariable("acronym") String acronym, @RequestParam(name = "country") String country) {
       logger.debug("containsCountryinGeographicLocation: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getGeographicLocation)
                .map(geographicLocation -> geographicLocation.containsCountry(country)).orElse(false);
    }

    @GetMapping("/virtualEdition/{acronym}/integerFrequency")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getIntegerFrequency(@PathVariable("acronym") String acronym) {
       logger.debug("getIntegerFrequency: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).map(VirtualEdition::getFrequency).map(Frequency_Base::getFrequency).orElse(0);
    }

    @GetMapping("/virtualEdition/{acronym}/activeMembers")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<MemberDto> getActiveMembersFromVirtualEdition(@PathVariable("acronym") String acronym) {
       logger.debug("getActiveMembersFromVirtualEdition: " + acronym);
        VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (edition != null) {
            return edition.getActiveMemberSet().stream().map(MemberDto::new).collect(Collectors.toSet());
        }

        return new HashSet<>();
    }

    @GetMapping("/virtualEdition/{acronym}/pendingMember")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<MemberDto> getPendingMemberFromVirtualEdition(@PathVariable("acronym") String acronym) {
       logger.debug("getPendingMemberFromVirtualEdition: " + acronym);
        VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (edition != null ) {
            return edition.getPendingMemberSet().stream().map(MemberDto::new).collect(Collectors.toSet());
        }

        return new HashSet<>();
    }

    @GetMapping("/taxonomy/{editionAcronym}/taxonomyUsedIn")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionDto> getTaxonomyUsedIn(@PathVariable("editionAcronym") String editionAcronym) {
       logger.debug("getTaxonomyUsedIn: " + editionAcronym);
        VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(editionAcronym);
        if (edition != null) {
            return edition.getTaxonomy().getUsedIn().stream().map(VirtualEditionDto::new).collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    @GetMapping("/writeVirtualEditionToFileExport")
    @Atomic(mode = Atomic.TxMode.READ)
    public String getWriteVirtualEditionToFileExport() throws IOException {
       logger.debug("getWriteVirtualEditionToFileExport");
        WriteVirtualEditonsToFile write = new WriteVirtualEditonsToFile();
        return write.export();
    }

    @PostMapping("/importVirtualEditionCorpus")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void importVirtualEditionCorpus(@RequestBody byte[] inputStream) {
       logger.debug("importVirtualEditionCorpus");
        VirtualEditionsTEICorpusImport loader = new VirtualEditionsTEICorpusImport();
        loader.importVirtualEditionsCorpus(new ByteArrayInputStream(inputStream));
    }

    @PostMapping("/importVirtualEditionCorpusString")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void importVirtualEditionCorpus(@RequestBody String inputStream) {
       logger.debug("importVirtualEditionCorpus");
        VirtualEditionsTEICorpusImport loader = new VirtualEditionsTEICorpusImport();
        loader.importVirtualEditionsCorpus((inputStream));
    }

    @PostMapping("/importVirtualEditionFragmentFromTEI")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public String importVirtualEditionFragmentFromTEI(@RequestBody byte[] inputStream) {
       logger.debug("importVirtualEditionFragmentFromTEI");
        VirtualEditionFragmentsTEIImport loader = new VirtualEditionFragmentsTEIImport();
        return loader.importFragmentFromTEI(new ByteArrayInputStream(inputStream));
    }

    @PostMapping("/importVirtualEditionFragmentFromTEIString")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void importVirtualEditionFragmentFromTEI(@RequestBody String inputStream) {
       logger.debug("importVirtualEditionFragmentFromTEI");
        VirtualEditionFragmentsTEIImport loader = new VirtualEditionFragmentsTEIImport();
        loader.importFragmentFromTEI((inputStream));
    }

    @GetMapping("/allTwitterCitations")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public List<TwitterCitationDto> getAllTwitterCitations() {
       logger.debug("getAllTwitterCitations");
        DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
        return  VirtualModule.getInstance().getAllTwitterCitation().stream()
                .sorted((c1, c2) -> java.time.LocalDateTime.parse(c2.getDate(), formater)
                        .compareTo(java.time.LocalDateTime.parse(c1.getDate(), formater)))
                .map(TwitterCitationDto::new).collect(Collectors.toList());
    }

    @GetMapping("/allTweets")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<TweetDto> getAllTweets() {
       logger.debug("getAllTweets");
        return VirtualModule.getInstance().getTweetSet().stream().map(TweetDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/removeTweets")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeTweets() {
       logger.debug("removeTweets");
        VirtualModule.getInstance().removeTweets();
    }

    @PostMapping("/detectCitation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void detectCitation() throws IOException {
       logger.debug("detectCitation");
        CitationDetecter detecter = new CitationDetecter();
        detecter.detect();
    }

    @PostMapping("/createTweetFactory")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createTweetFactory() throws IOException {
       logger.debug("createTweetFactory");
        TweetFactory tweetFactory = new TweetFactory();
        tweetFactory.create();
    }

    @PostMapping("/generateAwareAnnotations")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void generateAwareAnnotations() throws IOException {
       logger.debug("generateAwareAnnotations");
        AwareAnnotationFactory awareFactory = new AwareAnnotationFactory();
        awareFactory.generate();
    }

    @PostMapping("/dailyRegenerateTwitterCitationEdition")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void dailyRegenerateTwitterCitationEdition() {
       logger.debug("dailyRegenerateTwitterCitationEdition");
        VirtualModule.dailyRegenerateTwitterCitationEdition();
    }

    @GetMapping("/virtualEdition/{acronym}/annotationTextList")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> getAnnotationTextListFromVirtualEdition(@PathVariable("acronym") String acronym) {
       logger.debug("getAnnotationTextListFromVirtualEdition: " + acronym);
        VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (edition != null && !edition.getAnnotationTextList().isEmpty()) {
            return edition.getAnnotationTextList();
        }
        return new ArrayList<>();
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthCategoriesAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<CategoryDTO> getVirtualEditionInterAllDepthCategoriesAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionInterAllDepthCategoriesAccessibleByUser: " + xmlId);
        VirtualEditionInter inter = getVirtualEditionInterByXmlId(xmlId).orElseThrow(LdoDException::new);
        return inter.getAllDepthCategoriesAccessibleByUser(username).stream()
                .sorted((c1, c2) -> c1.compareInEditionContext(inter.getVirtualEdition(), c2))
                .map(c -> new CategoryDTO(inter.getVirtualEdition(), c)).collect(Collectors.toList());
    }

    @GetMapping("/virtualEdition/{acronym}/canCreateHumanAnnotation")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean canCreateHumanAnnotationOnVirtualEdition(@PathVariable("acronym") String acronym, @RequestParam(name = "username") String username) {
       logger.debug("canCreateHumanAnnotationOnVirtualEdition: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return HumanAnnotation.canCreate(virtualEdition, username);
        }
        return false;
    }

    @GetMapping("/virtualEdition/{acronym}/fragInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionFragInterByUrlId(@PathVariable("acronym") String acronym, @RequestParam(name = "urlId") String urlId) {
       logger.debug("getVirtualEditionFragInterByUrlId: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return virtualEdition.getIntersSet().stream().filter(i -> i.getUrlId().equals(urlId)).findFirst().map(VirtualEditionInterDto::new).orElse(null);
        }
        return null;
    }

    @GetMapping("/virtualEdition/{acronym}/interList")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterListDto getVirtualEditionInterList(@PathVariable("acronym") String acronym, @RequestParam(name = "deep") boolean deep) {
       logger.debug("getVirtualEditionInterList: " + acronym);
        VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronym);
        if (virtualEdition != null) {
            return new VirtualEditionInterListDto(virtualEdition, deep);
        }
        return null;
    }

    @GetMapping("/virtualEditionsUserIsParticipantSelectedOrPublic")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<VirtualEditionDto> getVirtualEditionsUserIsParticipantSelectedOrPublic(@RequestParam(name = "username") String username) {
       logger.debug("getVirtualEditionsUserIsParticipantSelectedOrPublic: " + username);
        return VirtualModule.getInstance().getVirtualEditionsUserIsParticipantSelectedOrPublic(username).stream().map(VirtualEditionDto::new).collect(Collectors.toList());
    }




    private Optional<VirtualEditionInter> getVirtualEditionInterByXmlId(String xmlId) {
        if (xmlId == null) {
            return Optional.empty();
        }

        String virtualEditionInterInter = virtualEditionInterMapByXmlId.get(xmlId);

        if (virtualEditionInterInter == null) {
            virtualEditionInterInter = VirtualModule.getInstance().getVirtualEditionInterSet().stream()
                    .filter(vei -> vei.getXmlId().equals(xmlId))
                    .findAny()
                    .map(vi -> vi.getExternalId())
                    .orElse(null);

            if (virtualEditionInterInter != null) {
                virtualEditionInterMapByXmlId.put(xmlId, virtualEditionInterInter);
            }
        }

        return Optional.ofNullable(virtualEditionInterInter != null ? FenixFramework.getDomainObject(virtualEditionInterInter) : null);
    }

    private Optional<VirtualEditionInter> getVirtualEditionInterByUrlIdUtil(String urlId) {
        if (urlId == null) {
            return Optional.empty();
        }

        String virtualEditionInterId = virtualEditionInterMapByUrlId.get(urlId);

        if (virtualEditionInterId == null) {
            virtualEditionInterId = VirtualModule.getInstance().getVirtualEditionInterSet().stream()
                    .filter(vei -> vei.getUrlId().equals(urlId))
                    .findAny()
                    .map(vei -> vei.getExternalId())
                    .orElse(null);

            if (virtualEditionInterId != null) {
               virtualEditionInterMapByUrlId.put(urlId, virtualEditionInterId);
            }
        }

        return Optional.ofNullable(virtualEditionInterId != null ? FenixFramework.getDomainObject(virtualEditionInterId) : null);
    }

    private Optional<VirtualEdition> getVirtualEditionByAcronymUtil(String acronym) {
        if (acronym == null) {
            return Optional.empty();
        }

        String virtualEditionId = virtualEditionMap.get(acronym);

        if (virtualEditionId == null) {
            virtualEditionId = VirtualModule.getInstance().getVirtualEditionsSet().stream()
                    .filter(ve -> ve.getAcronym().equals(acronym))
                    .findAny()
                    .map(ve -> ve.getExternalId())
                    .orElse(null);

            if (virtualEditionId != null) {
                virtualEditionMap.put(acronym, virtualEditionId);
            }
        }

        return Optional.ofNullable(virtualEditionId != null ? FenixFramework.getDomainObject(virtualEditionId) : null);
    }

    @PostMapping("/initializeVirtualModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public boolean initializeVirtualModule() {
       logger.debug("initializeVirtualModule");
        return VirtualBootstrap.initializeVirtualModule();
    }

    @PostMapping("/fetchCitationsFromTwitter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void fetchCitationsFromTwitter() throws IOException {
       logger.debug("fetchCitationsFromTwitter");
        FetchCitationsFromTwitter fetch = new FetchCitationsFromTwitter();
        fetch.fetch();
    }

    // Test methods

    @PostMapping("/createTwitterCitation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public TwitterCitationDto createTwitterCitation(@RequestParam(name = "fragmentXmlId") String fragmentXmlId, @RequestParam(name = "sourceLink") String sourceLink, @RequestParam(name = "date") String date, @RequestParam(name = "fragText") String fragText, @RequestParam(name = "tweetText") String tweetText,
                                      @RequestParam(name = "tweetID") long tweetID, @RequestParam(name = "location") String location, @RequestParam(name = "country") String country, @RequestParam(name = "username") String username, @RequestParam(name = "profURL") String profURL, @RequestParam(name = "profImgURL") String profImgURL) {
        logger.debug("createTwitterCitation");
        return new TwitterCitationDto(new TwitterCitation(VirtualRequiresInterface.getInstance().getFragmentByXmlId(fragmentXmlId), sourceLink, date, fragText,
                tweetText, tweetID, location, country, username, profURL, profImgURL));
    }

    @PostMapping("/createTweet")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createTweet(@RequestParam(name = "sourceLink") String sourceLink, @RequestParam(name = "date") String date, @RequestParam(name = "tweetText") String tweetText, @RequestParam(name = "tweetID") long tweetID, @RequestParam(name = "location") String location,
                           @RequestParam(name = "country") String country, @RequestParam(name = "username") String username, @RequestParam(name = "profURL") String profURL, @RequestParam(name = "profImgURL") String profImgURL, @RequestParam(name = "originalTweetID") long originalTweetID, @RequestParam(name = "isRetweet") boolean isRetweet) {
       logger.debug("createTweet");
        TwitterCitation twitterCitation = VirtualModule.getInstance().getTwitterCitationByTweetID(23);
        new Tweet(VirtualModule.getInstance(), sourceLink, date, tweetText, tweetID, location, country, username, profURL, profImgURL, originalTweetID, isRetweet, twitterCitation);
    }

    @GetMapping("/virtualEditionInter/{xmlId}/allDepthHumanAnnotationsAccessibleByUser")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<HumanAnnotationDto> getAllDepthHumanAnnotationsAccessibleByUser(@PathVariable("xmlId") String xmlId, @RequestParam(name = "username") String username) {
        VirtualEditionInter inter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);
        return inter.getAllDepthHumanAnnotationsAccessibleByUser(username).stream().map(humanAnnotation -> new HumanAnnotationDto(humanAnnotation, inter)).collect(Collectors.toList());
    }

    @PostMapping("/removeAnnotation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeAnnotation(@RequestParam(name = "externalId") String externalId) {
        DomainObject domainObject = FenixFramework.getDomainObject(externalId);

        if (domainObject instanceof Annotation) {
            ((Annotation) domainObject).remove();
        }
    }

//    @GetMapping("/virtualEditionInter/xmlId/{xmlId}")
//    @Atomic(mode = Atomic.TxMode.READ)
//    public VirtualEditionInterDto getVirtualEditionInterDtoByXmlId(@PathVariable("xmlId") String xmlId) {
//        return new VirtualEditionInterDto(getVirtualEditionInterByXmlId(xmlId).get());
//    }

    @GetMapping("/virtualEdition/{acronym}/members")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<MemberDto> getMemberSet(@PathVariable("acronym") String acronym) {
       logger.debug("getMemberSet: " + acronym);
        return getVirtualEditionByAcronymUtil(acronym).get().getMemberSet().stream().map(MemberDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/virtualEdition/{externalId}/addMemberAdmin")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void addMemberAdminByExternalId(@PathVariable("externalId") String externalId, @RequestParam(name = "user") String user, @RequestParam(name = "b") boolean b) {
        DomainObject virtualEdition = FenixFramework.getDomainObject(externalId);
        if (virtualEdition instanceof VirtualEdition) {
            ((VirtualEdition) virtualEdition).addMember(user, Member.MemberRole.ADMIN, b);
        }
    }

    @PostMapping("/createTestCategory")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public CategoryDto createTestCategory(@RequestParam(name = "editionAcronym") String editionAcronym, @RequestParam(name = "name") String name) {
        return new CategoryDto(getVirtualEditionByAcronymUtil(editionAcronym).get().getTaxonomy().createCategory(name));
    }

    @PostMapping("/virtualEditionInter/{externalId}/remove")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeVirtualEditionInter(@PathVariable("externalId") String externalId) {
        DomainObject inter = FenixFramework.getDomainObject(externalId);
        if (inter instanceof VirtualEditionInter) {
            cleanVirtualEditionMapCache();
            virtualEditionInterMapByXmlId.clear();
            virtualEditionInterMapByUrlId.clear();
            ((VirtualEditionInter) inter).remove();
        }
    }

    @GetMapping("/humanAnnotation/{id}/virtualEditionInter")
    @Atomic(mode = Atomic.TxMode.READ)
    public VirtualEditionInterDto getVirtualEditionInterFromAnnotation(@PathVariable("id") String id) {
        DomainObject domainObject = FenixFramework.getDomainObject(id);
        if (domainObject instanceof HumanAnnotation) {
            return new VirtualEditionInterDto((((HumanAnnotation) domainObject).getVirtualEditionInter()));
        }
        return null;
    }

    @GetMapping("/exportVirtualEditionFragments")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportVirtualEditionFragments(@RequestParam(name = "fragXmlId") String fragXmlId) {
        VirtualEditionFragmentsTEIExport export = new VirtualEditionFragmentsTEIExport();
        return export.exportFragment(fragXmlId);
    }

    @GetMapping("/virtualEditionIntersFromFragment")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<VirtualEditionInterDto> getVirtualEditionInterSetFromFragment(@RequestParam(name = "fragXmlId") String xmlId) {
        return VirtualModule.getInstance().getVirtualEditionInterSet(xmlId).stream().map(VirtualEditionInterDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/createTwitterCitationFromCitation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public TwitterCitationDto createTwitterCitationFromCitation(@RequestBody CitationDto citationDto) {
       logger.debug("createTwitterCitationFromCitation: " + citationDto.getId());
        return new TwitterCitationDto(new TwitterCitation(citationDto));
    }

    @GetMapping("/twitterCitation/{id}/awareAnnotations")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public Set<AwareAnnotationDto> getAwareAnnotations(@PathVariable("id") long id) {
       logger.debug("getAwareAnnotations: " + id);
        return VirtualModule.getInstance().getTwitterCitationByTweetID(id).getAwareAnnotationSet().stream().map(AwareAnnotationDto::new).collect(Collectors.toSet());
    }

    @GetMapping("/exportVirtualEditionsTEICorpus")
    @Atomic(mode = Atomic.TxMode.READ)
    public String exportVirtualEditionsTEICorpus() {
        return new VirtualEditionsTEICorpusExport().export();
    }

    @PostMapping("/removeTweet")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeTweet(@RequestParam(name = "id") long id) {
        VirtualModule.getInstance().getTweetByTweetID(id).remove();
    }

    @GetMapping("/virtualEdition/{acronym}/criteriaSize")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getVirtualEditionCriteriaSetSize(@PathVariable("acronym") String acronym) {
        return VirtualModule.getInstance().getVirtualEdition(acronym).getCriteriaSet().size();
    }

    @PostMapping("/virtualEdition/{acronym}/createMediaSource")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createMediaSource(@PathVariable("acronym") String acronym, @RequestParam(name = "name") String name) {
        new MediaSource(VirtualModule.getInstance().getVirtualEdition(acronym), name );
    }

    @PostMapping("/virtualEdition/{acronym}/createTimeWindow")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createTimeWindow(@PathVariable("acronym") String acronym, @RequestParam(name = "beginDate") @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate beginDate,  @RequestParam(name = "endDate") @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate endDate) {
        new TimeWindow(VirtualModule.getInstance().getVirtualEdition(acronym), beginDate, endDate);
    }

    @PostMapping("/virtualEdition/{acronym}/createFrequency")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createFrequency(@PathVariable("acronym") String acronym, @RequestParam(name = "frequency") int frequency) {
        new Frequency(VirtualModule.getInstance().getVirtualEdition(acronym), frequency);
    }

    @PostMapping("/virtualEdition/{acronym}/createGeographicLocation")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void createGeographicLocation(@PathVariable("acronym") String acronym, @RequestParam(name = "country") String country, @RequestParam(name = "location") String location) {
        new GeographicLocation(VirtualModule.getInstance().getVirtualEdition(acronym), country, location);
    }

    @GetMapping("/citationDetecterLastIndexOfCapitalLetter")
    @Atomic(mode = Atomic.TxMode.READ)
    public int citationDetecterLastIndexOfCapitalLetter(@RequestParam(name = "teste") String teste, @RequestParam(name = "i") int i) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.lastIndexOfCapitalLetter(teste, i);
    }

    @GetMapping("/citationDetecterPatternFinding")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> citationDetecterPatternFinding(@RequestParam(name = "text") String text, @RequestParam(name = "pattern") String pattern) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.patternFinding(text, pattern);
    }

    @GetMapping("/citationDetecterMaxJaroValue")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> citationDetecterMaxJaroValue(@RequestParam(name = "text") String text, @RequestParam(name = "wordToFind") String wordToFind) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.maxJaroValue(text, wordToFind);
    }

    @GetMapping("/citationDetecterCleanTweetText")
    @Atomic(mode = Atomic.TxMode.READ)
    public String citationDetecterCleanTweetText(@RequestParam(name = "s") String s) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.cleanTweetText(s);
    }

    @GetMapping("/citationDetecterCountOccurencesOfSubstring")
    @Atomic(mode = Atomic.TxMode.READ)
    public int countOccurencesOfSubstring(@RequestParam(name = "string") String string, @RequestParam(name = "substring") String substring, @RequestParam(name = "position") int position) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.countOccurencesOfSubstring(string, substring, position);
    }

    @GetMapping("/citationDetecterStartBiggerThanEnd")
    @Atomic(mode = Atomic.TxMode.READ)
    public boolean startBiggerThanEnd(@RequestParam(name = "hStart") int hStart, @RequestParam(name = "hEnd") int hEnd, @RequestParam(name = "nStart") int nStart, @RequestParam(name = "nEnd") int nEnd ) throws IOException {
        CitationDetecter citationDetecter = new CitationDetecter();
        return citationDetecter.startBiggerThanEnd(hStart, hEnd, nStart, nEnd);
    }

    @GetMapping("/checkTitleStmtLoad")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<String> checkTitleStmtLoad() {
        List<String> list = new ArrayList<>();
        list.add(VirtualModule.getInstance().getTitle());
        list.add(VirtualModule.getInstance().getAuthor());
        list.add(VirtualModule.getInstance().getEditor());
        list.add(VirtualModule.getInstance().getSponsor());
        list.add(VirtualModule.getInstance().getFunder());
        list.add(VirtualModule.getInstance().getPrincipal());
        return list;
    }

    @GetMapping("/twitterCitation/{tweetId}/numberOfRetweets")
    @Atomic(mode = Atomic.TxMode.READ)
    public int getTwitterCitationNumberOfRetweets(@PathVariable("tweetId") long tweetId) {
       return VirtualModule.getInstance().getTwitterCitationByTweetID(tweetId).getNumberOfRetweets();
    }

    @GetMapping("/twitterCitation/{tweetId}/tweets")
    @Atomic(mode = Atomic.TxMode.READ)
    public Set<TweetDto> getTwitterCitationTweets(@PathVariable("tweetId") long tweetId) {
        return VirtualModule.getInstance().getTwitterCitationByTweetID(tweetId).getTweetSet().stream().map(TweetDto::new).collect(Collectors.toSet());
    }

    @PostMapping("/removeVirtualModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeVirtualModule() {
        VirtualModule virtualModule = VirtualModule.getInstance();
        if (virtualModule != null) {
            virtualModule.remove();
        }
    }
}







public class VirtualEditionInterGameDto {
    private String fragmentId;
    private String title;
    private int number;
    private String urlId;
    private String text;

    public VirtualEditionInterGameDto() {
    }

    public VirtualEditionInterGameDto(VirtualEditionInterDto inter) {
        this.setFragmentId(inter.getFragmentXmlId());
        this.title = inter.getTitle();
        this.number = inter.getNumber();
        this.urlId = inter.getUrlId();

//        this.text = inter.getLastUsed().getTranscription();
    }

    public String getFragmentId() {
        return this.fragmentId;
    }

    public void setFragmentId(String fragmentId) {
        this.fragmentId = fragmentId;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getNumber() {
        return this.number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

}




import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;

import javax.validation.constraints.NotBlank;

public class LdoDUserViewDto {
    @NotBlank
    private String username;
    private String password;
    private String firstName;
    private String lastName;
    private boolean enabled;
    private boolean active;

    public LdoDUserViewDto() {
    }

    public LdoDUserViewDto(UserDto user) {
        this.username = user.getUsername();
        this.enabled = user.isEnabled();
        this.active = user.isActive();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
    }

    public LdoDUserViewDto(String user) {
        UserDto userDto = new UserDto(user);
        this.username = user;
        this.enabled = userDto.isEnabled();
        this.active = userDto.isActive();
        this.firstName = userDto.getFirstName();
        this.lastName = userDto.getLastName();
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return this.password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public boolean isEnabled() {
        return this.enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public boolean isActive() {
        return this.active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

}


import pt.ist.socialsoftware.edition.virtual.domain.Tweet;

public class TweetDto {

    private long id;

    public TweetDto(Tweet tweet) {
        this.id = tweet.getTweetID();
    }

    public long getId() {
        return id;
    }
}


import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class VirtualEditionInterListDto {

    private List<VirtualEditionInterGameDto> virtualEditionInterList = new ArrayList<>();
    private String title;
    private String acronym;
    private String type;
    private boolean pub;
    private int numberOfInters;
    private TaxonomyDto taxonomy;
    private List<LdoDUserViewDto> members;

    public VirtualEditionInterListDto(VirtualEdition virtualEdition, boolean deep) {
        if (deep) {
            this.setVirtualEditionInterList(virtualEdition.getIntersSet().stream().sorted()
                    .map(i -> new VirtualEditionInterGameDto(new VirtualEditionInterDto(
                            virtualEdition.getFragInterByUrlId(i.getUrlId()))))
                    .collect(Collectors.toList()));
        }
        this.setTitle(virtualEdition.getTitle());
        this.setAcronym(virtualEdition.getAcronym());
        this.type = "virtual";
        this.setPub(virtualEdition.getPub());
        this.numberOfInters = virtualEdition.getIntersSet().size();
        TaxonomyDto taxonomyDto = new TaxonomyDto(virtualEdition.getTaxonomy());
        this.setTaxonomy(taxonomyDto);
        if (deep) {
            this.setMembers(virtualEdition.getActiveMemberSet().stream()
                    .map(member -> new LdoDUserViewDto(member.getUser())).collect(Collectors.toList()));
        }
    }

    public List<VirtualEditionInterGameDto> getVirtualEditionInterList() {
        return this.virtualEditionInterList;
    }

    public void setVirtualEditionInterList(List<VirtualEditionInterGameDto> virtualEditionInterList) {
        this.virtualEditionInterList = virtualEditionInterList;
    }

    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public boolean isPub() {
        return this.pub;
    }

    public void setPub(boolean pub) {
        this.pub = pub;
    }

    public int getNumberOfInters() {
        return this.numberOfInters;
    }

    public void setNumberOfInters(int numberOfInters) {
        this.numberOfInters = numberOfInters;
    }


    public TaxonomyDto getTaxonomy() {
        return this.taxonomy;
    }

    public void setTaxonomy(TaxonomyDto taxonomy) {
        this.taxonomy = taxonomy;
    }

    public List<LdoDUserViewDto> getMembers() {
        return this.members;
    }

    public void setMembers(List<LdoDUserViewDto> members) {
        this.members = members;
    }

    public String getType() {
        return this.type;
    }

    public void setType(String type) {
        this.type = type;
    }


}


import pt.ist.socialsoftware.edition.virtual.domain.TwitterCitation;

public class TwitterCitationDto  {

    private String tweetText;
    private String country;
    private String location;
    private String username;
    private String userProfileUrl;
    private long id;
    private long tweetId;

    public TwitterCitationDto(TwitterCitation citation) {
        //super(citation);
        this.tweetText = citation.getTweetText();
        this.country = citation.getCountry();
        this.location = citation.getLocation();
        this.username = citation.getUsername();
        this.userProfileUrl = citation.getUserProfileURL();
        this.id = citation.getId();
        this.tweetId = citation.getTweetID();
    }

    public String getTweetText() {
        return tweetText;
    }

    public String getCountry() {
        return country;
    }

    public String getLocation() {
        return location;
    }

    public String getUsername() {
        return username;
    }


    public boolean isTwitterCitation() {
        return true;
    }

    public String getUserProfileURL() {
        return this.userProfileUrl;
    }

    public long getId() {
        return id;
    }

    public long getTweetId() {
        return tweetId;
    }
}


import com.fasterxml.jackson.annotation.JsonIgnore;
import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;
import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.domain.Category;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;

import java.util.List;
import java.util.stream.Collectors;

public class CategoryDto {

    private String externalId;
    private String acronym;
    private String urlId;
    private String nameInEdition;
    private String name;
    private List<UserDto> users;
    private boolean hasTags;

    public CategoryDto(Category category, VirtualEditionInter inter, String username) {
        setExternalId(category.getExternalId());
        setAcronym(category.getTaxonomy().getEdition().getAcronym());
        setUrlId(category.getUrlId());
        setNameInEdition(category.getNameInEditionContext(inter.getEdition().getTaxonomy().getEdition()));
        setName(category.getName());
        setUsers(inter.getContributorSet(category, username).stream().map(UserDto::new).collect(Collectors.toList()));
        this.hasTags = category.getTagSet().isEmpty();
    }

    public CategoryDto(Category category) {
        setExternalId(category.getExternalId());
        setAcronym(category.getTaxonomy().getEdition().getAcronym());
        setUrlId(category.getUrlId());
//        setNameInEdition(category.getNameInEditionContext(inter.getEdition().getTaxonomy().getEdition()));
        setName(category.getName());
        this.hasTags = category.getTagSet().isEmpty();
    }

    public CategoryDto() {}

    public String getExternalId() {
        return this.externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getNameInEdition() {
        return this.nameInEdition;
    }

    public void setNameInEdition(String name) {
        this.nameInEdition = name;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<UserDto> getUsers() {
        return this.users;
    }

    public void setUsers(List<UserDto> users) {
        this.users = users;
    }

    @JsonIgnore
    public List<String> getUsernames() {
        return getUsers().stream().map(userDto -> userDto.getUsername()).collect(Collectors.toList());
    }

    public boolean isHasTags() { return this.hasTags; }

}


import pt.ist.socialsoftware.edition.virtual.domain.AwareAnnotation;

public class AwareAnnotationDto extends AnnotationDto {

    private String source;
    private String profile;
    private String date;
    private String country;

    public AwareAnnotationDto(AwareAnnotation annotation) {
        super(annotation);

        setSource(annotation.getSourceLink());
        setProfile(annotation.getProfileURL());
        setDate(annotation.getDate());
        setCountry(annotation.getCountry());
    }

    public String getSource() {
        return this.source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getProfile() {
        return this.profile;
    }

    public void setProfile(String profile) {
        this.profile = profile;
    }

    public String getDate() {
        return this.date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public String getCountry() {
        return this.country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    @Override
    public boolean isHumanAnnotation() {
        return false;
    }
}


import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.domain.HumanAnnotation;
import pt.ist.socialsoftware.edition.virtual.domain.Tag;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;

import java.util.ArrayList;
import java.util.List;

public class HumanAnnotationDto extends AnnotationDto {

    private String text;
    private List<TagDto> tags;

    public HumanAnnotationDto(HumanAnnotation annotation, VirtualEditionInter inter) {
        super(annotation);

        setText(annotation.getText());
        List<TagDto> tags = new ArrayList<>();
        for (Tag tag : annotation.getTagSet()) {
            tags.add(new TagDto(tag, inter));
        }
        setTags(tags);

    }

    public static boolean canCreate(String acronym, String username) {
        VirtualProvidesInterface virtualProvidesInterface = new VirtualProvidesInterface();
        return virtualProvidesInterface.canCreateHumanAnnotationOnVirtualEdition(acronym, username);
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public List<TagDto> getTags() {
        return this.tags;
    }

    public void setTags(List<TagDto> tags) {
        this.tags = tags;
    }

    @Override
    public boolean isHumanAnnotation() {
        return true;
    }
}


import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.domain.Category;
import pt.ist.socialsoftware.edition.virtual.domain.Taxonomy;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class TaxonomyDto {

	private boolean openManagement;
	private boolean openVocabulary;
	private boolean openAnnotation;
	private boolean hasCategories;

	private String editionAcronym;
	private String externalId;

	public TaxonomyDto() {
	}

	public TaxonomyDto(Taxonomy taxonomy) {
		this.setOpenManagement(taxonomy.getOpenManagement());
		this.setOpenVocabulary(taxonomy.getOpenVocabulary());
		this.setOpenAnnotation(taxonomy.getOpenAnnotation());
		this.setHasCategories(!taxonomy.getCategoriesSet().isEmpty());
		this.editionAcronym = taxonomy.getEdition().getAcronym();
		this.externalId = taxonomy.getExternalId();
	}

	public String getExternalId() {
		return externalId;
	}

	public boolean isOpenManagement() {
		return this.openManagement;
	}

	public void setOpenManagement(boolean openManagement) {
		this.openManagement = openManagement;
	}

	public boolean isOpenVocabulary() {
		return this.openVocabulary;
	}

	public void setOpenVocabulary(boolean openVocabulary) {
		this.openVocabulary = openVocabulary;
	}

	public boolean isOpenAnnotation() {
		return this.openAnnotation;
	}

	public void setOpenAnnotation(boolean openAnnotation) {
		this.openAnnotation = openAnnotation;
	}

	public boolean getHasCategories() {
		return this.hasCategories;
	}

	public void setHasCategories(boolean hasCategories) {
		this.hasCategories = hasCategories;
	}

	public String getEditionAcronym() {
		return editionAcronym;
	}

	public void setEditionAcronym(String editionAcronym) {
		this.editionAcronym = editionAcronym;
	}

	public void setExternalId(String externalId) {
		this.externalId = externalId;
	}
}


import pt.ist.socialsoftware.edition.virtual.domain.Tag;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;

public class TagDto {

    private String username;
    private String acronym;
    private String urlId;
    private String nameInEdition;
    private String name;
    private String externalId;

    public TagDto(Tag tag, VirtualEditionInter inter){
        setUsername(tag.getContributor());
        setAcronym(tag.getCategory().getTaxonomy().getEdition().getAcronym());
        setUrlId(tag.getCategory().getUrlId());
        setNameInEdition(tag.getCategory().getNameInEditionContext(inter.getEdition()));
        setName(tag.getCategory().getName());
        setExternalId(tag.getExternalId());
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getAcronym() {
        return acronym;
    }

    public void setAcronym(String acronym) {
        this.acronym = acronym;
    }

    public String getUrlId() {
        return urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getNameInEdition() {
        return nameInEdition;
    }

    public void setNameInEdition(String nameInEdition) {
        this.nameInEdition = nameInEdition;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getExternalId() {
        return externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}


import pt.ist.socialsoftware.edition.virtual.domain.Member;

public class MemberDto {

    private String user;
    private String role;

    public MemberDto(Member member) {
        this.user = member.getUser();
        this.role = member.getRole().name();
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public boolean hasRole(String role) {
        return this.role.equals(role);
    }

}



import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;
import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.utils.CategoryDTO;
import pt.ist.socialsoftware.edition.virtual.utils.FragInterDto;
import pt.ist.socialsoftware.edition.virtual.utils.RangeJson;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;


public class VirtualEditionInterDto {

    private String xmlId;

    // cached attributes
    private String externalId;
    private String title;
    private String fragmentXmlId;
    private String urlId;
    private String shortName;
    private String reference;
    private int number;

    /*public VirtualEditionInterDto(String xmlId) {
        setXmlId(xmlId);
        VirtualEditionInter virtualEditionInter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);

        this.externalId = virtualEditionInter.getExternalId();
        this.title = virtualEditionInter.getTitle();
        this.fragmentXmlId = virtualEditionInter.getFragmentXmlId();
        this.urlId = virtualEditionInter.getUrlId();
        this.shortName = virtualEditionInter.getShortName();
        this.reference = virtualEditionInter.getReference();
        this.number = virtualEditionInter.getNumber();
    }*/

    public VirtualEditionInterDto(VirtualEditionInter virtualEditionInter) {
        setXmlId(virtualEditionInter.getXmlId());
        this.externalId = virtualEditionInter.getExternalId();
        this.title = virtualEditionInter.getTitle();
        this.fragmentXmlId = virtualEditionInter.getFragmentXmlId();
        this.urlId = virtualEditionInter.getUrlId();
        this.shortName = virtualEditionInter.getShortName();
        this.reference = virtualEditionInter.getReference();
        this.number = virtualEditionInter.getNumber();
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public void setXmlId(String xmlId) {
        this.xmlId = xmlId;
    }

    public String getExternalId() {
        //return this.virtualProvidesInterface.getVirtualEditionInterExternalId(this.xmlId);
        return this.externalId;
    }

    public String getTitle() {
        //return this.virtualProvidesInterface.getVirtualEditionInterTitle(this.xmlId);
        return this.title;
    }

    public FragInterDto.InterType getType() {
        return FragInterDto.InterType.VIRTUAL;
    }

    public String getFragmentXmlId() {
        //return this.virtualProvidesInterface.getFragmentXmlIdVirtualEditionInter(this.xmlId);
        return this.fragmentXmlId;
    }

    public String getUrlId() {
        //return this.virtualProvidesInterface.getVirtualEditionInterUrlId(this.xmlId);
        return this.urlId;
    }

    public String getShortName() {
        //return this.virtualProvidesInterface.getVirtualEditionInterShortName(this.xmlId);
        return this.shortName;
    }


    public String getReference() {
        //return this.virtualProvidesInterface.getVirtualEditionInterReference(this.xmlId);
        return this.reference;
    }

    public int getNumber() {
        //return this.virtualProvidesInterface.getVirtualEditionInterNumber(this.xmlId);
        return this.number;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        VirtualEditionInterDto other = (VirtualEditionInterDto) o;
        return this.xmlId.equals(other.getXmlId());
    }

    @Override
    public int hashCode() {
        return this.xmlId.hashCode();
    }

}


import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.domain.Annotation;
import pt.ist.socialsoftware.edition.virtual.domain.Range;

import java.util.Set;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
@JsonSubTypes({@JsonSubTypes.Type(value = AwareAnnotationDto.class, name = AnnotationDto.AWARE),
        @JsonSubTypes.Type(value = HumanAnnotationDto.class, name = AnnotationDto.HUMAN)})
public abstract class AnnotationDto {

    public static final String AWARE = "aware";
    public static final String HUMAN = "human";

    private String quote;
    private String username;
    private String text;
    private String externalId;
    private String interExternalId;
    private String interXmlId;
    private String user;

    public AnnotationDto(Annotation annotation) {
        setQuote(annotation.getQuote());
        setUsername(annotation.getUser());
        setText(annotation.getText());
        this.externalId = annotation.getExternalId();
        this.interExternalId = annotation.getVirtualEditionInter().getExternalId();
        this.interXmlId = annotation.getVirtualEditionInter().getXmlId();
        this.user = annotation.getUser();
    }

    public String getQuote() {
        return this.quote;
    }

    public void setQuote(String quote) {
        this.quote = quote;
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getExternalId() {
        return externalId;
    }

    public String getInterExternalId() {
        return interExternalId;
    }

    public String getUser() {
        return user;
    }

    public abstract boolean isHumanAnnotation();

    public String getInterXmlId() {
        return interXmlId;
    }
}


import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.joda.time.LocalDate;
import org.springframework.core.ParameterizedTypeReference;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateDeserializer;
import pt.ist.socialsoftware.edition.notification.config.CustomLocalDateSerializer;
import pt.ist.socialsoftware.edition.virtual.domain.Member;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;
import pt.ist.socialsoftware.edition.virtual.api.VirtualProvidesInterface;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;

import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class VirtualEditionDto {

    private final VirtualProvidesInterface virtualProvidesInterface = new VirtualProvidesInterface();

    private final String xmlId;
    private final String acronym;

    // cached attributes
    private String externalId;
    private String title;
    private String reference;
    private String synopsis;
    private boolean isLdoDEdition;
    private LocalDate date;
    private boolean pub;
    private boolean openVocabulary;
    private String shortAcronym;
    private int max;

    public VirtualEditionDto(VirtualEdition virtualEdition) {
        this.xmlId = virtualEdition.getXmlId();
        this.acronym = virtualEdition.getAcronym();
        this.externalId = virtualEdition.getExternalId();
        this.title = virtualEdition.getTitle();
        this.reference = virtualEdition.getReference();
        this.isLdoDEdition = virtualEdition.isLdoDEdition();
        this.date = virtualEdition.getDate();
        this.pub = virtualEdition.getPub();
        this.openVocabulary = virtualEdition.getTaxonomy().getOpenVocabulary();
        this.synopsis = virtualEdition.getSynopsis();
        this.shortAcronym = virtualEdition.getShortAcronym();
        this.max = virtualEdition.getMaxFragNumber();
    }

    public String getXmlId() {
        return this.xmlId;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getExternalId() {
        //return this.virtualProvidesInterface.getVirtualEditionExternalIdByAcronym(this.acronym);
        return this.externalId;
    }

    public String getTitle() {
        //return this.virtualProvidesInterface.getVirtualEditionTitleByAcronym(this.acronym);
        return this.title;
    }

    public String getReference() {
        //return this.virtualProvidesInterface.getVirtualEditionReference(this.acronym);
        return this.reference;
    }

    public boolean getTaxonomyVocabularyStatus() {
        //return this.virtualProvidesInterface.getVirtualEditionTaxonomyVocabularyStatus(this.acronym);
        return this.openVocabulary;
    }

    public String getShortAcronym() {
        return shortAcronym;
    }

    public boolean isLdoDEdition() {
        //return this.virtualProvidesInterface.isLdoDEdition(this.acronym);
        return this.isLdoDEdition;
    }


    public boolean getPub() {
       //return this.virtualProvidesInterface.getVirtualEditionPub(this.acronym);
       return this.pub;
    }

    @JsonSerialize(using = CustomLocalDateSerializer.class)
    public LocalDate getDate() {
        //return this.virtualProvidesInterface.getVirtualEditionDate(this.acronym);
        return this.date;
    }


    public boolean getOpenVocabulary() {
        //return this.virtualProvidesInterface.getOpenVocabulary(this.acronym);
        return this.openVocabulary;
    }

    public int getMaxFragNumber() {
        return max;
    }


    public String getSynopsis() {
        return this.synopsis;
    }

    public Set<String> getParticipantSet() {
         return this.virtualProvidesInterface.getVirtualEditionParticipantSet(this.acronym);
    }

}



import pt.ist.socialsoftware.edition.virtual.domain.Range;

import java.io.Serializable;

public class RangeJson implements Serializable {
	private static final long serialVersionUID = 1L;

	private String start;
	private int startOffset;
	private String end;
	private int endOffset;

	public RangeJson() {
	}

	public RangeJson(Range range) {
		setStart(range.getStart());
		setStartOffset(range.getStartOffset());
		setEnd(range.getEnd());
		setEndOffset(range.getEndOffset());
	}

	public String getStart() {
		return start;
	}

	public void setStart(String start) {
		this.start = start;
	}

	public int getStartOffset() {
		return startOffset;
	}

	public void setStartOffset(int startOffset) {
		this.startOffset = startOffset;
	}

	public String getEnd() {
		return end;
	}

	public void setEnd(String end) {
		this.end = end;
	}

	public int getEndOffset() {
		return endOffset;
	}

	public void setEndOffset(int endOffset) {
		this.endOffset = endOffset;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}
}


import org.joda.time.LocalDate;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.domain.Member;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;
import pt.ist.socialsoftware.edition.virtual.feature.topicmodeling.TopicModeler;

public class VirtualBootstrap {

    private static final String ARS = "ars";


    public static boolean initializeVirtualModule() {

        boolean virtualCreate = false;
        if (VirtualModule.getInstance() == null) {
            new VirtualModule();
            cleanTopicModeler();
            cleanLucene();
            createVirtualEditionsForTest();
            createLdoDArchiveVirtualEdition();
            virtualCreate = true;
        }
        VirtualRequiresInterface.getInstance();
        return virtualCreate;
    }

    private static void cleanTopicModeler() {
        TopicModeler topicModeler = new TopicModeler();
        topicModeler.cleanDirectory();
    }

    private static void cleanLucene() {
        VirtualRequiresInterface.getInstance().cleanLucene();
    }

    public static void createVirtualEditionsForTest() {
//        logger.debug("createVirtualEditionsForTest size{}", UserModule.getInstance().getUsersSet().size());

        // User ars = ldod.getUser("ars");
        // User diego = ldod.getUser("diego");
        // User mp = ldod.getUser("mp");
        // User tiago = ldod.getUser("tiago");
        // User nuno = ldod.getUser("nuno");
        // User luis = ldod.getUser("luis");
        // User andre = ldod.getUser("afs");
        // User daniela = ldod.getUser("daniela");
        // User joana = ldod.getUser("joana");
        // User bernardosoares = ldod.getUser("bernardosoares");
        // User rita = ldod.getUser("rita");
        // User osvaldo = ldod.getUser("osvaldo");
        // User jose = ldod.getUser("jose");
        //
        // VirtualEdition classX = new VirtualEdition(ldod, ars, "VirtualModule-ClassX", "VirtualModule
        // Edition of Class X", new LocalDate(),
        // false, null);
        // classX.addMember(luis, MemberRole.ADMIN, true);
        // classX.addMember(mp, MemberRole.ADMIN, true);
        // classX.addMember(diego, MemberRole.ADMIN, true);
        // classX.addMember(tiago, MemberRole.ADMIN, true);
        // classX.addMember(ars, MemberRole.ADMIN, true);
        // classX.addMember(andre, MemberRole.ADMIN, true);
        // classX.addMember(daniela, MemberRole.ADMIN, true);
        // classX.addMember(joana, MemberRole.ADMIN, true);
        // classX.addMember(bernardosoares, MemberRole.ADMIN, true);
        // classX.addMember(rita, MemberRole.ADMIN, true);
        // classX.addMember(osvaldo, MemberRole.ADMIN, true);
        // classX.addMember(jose, MemberRole.ADMIN, true);
        // luis.addSelectedVirtualEditions(classX);
        // mp.addSelectedVirtualEditions(classX);
        // ars.addSelectedVirtualEditions(classX);
        // diego.addSelectedVirtualEditions(classX);
        // tiago.addSelectedVirtualEditions(classX);
        // nuno.addSelectedVirtualEditions(classX);
        // andre.addSelectedVirtualEditions(classX);
        // bernardosoares.addSelectedVirtualEditions(classX);
        // rita.addSelectedVirtualEditions(classX);
        // osvaldo.addSelectedVirtualEditions(classX);
        // jose.addSelectedVirtualEditions(classX);
        //
        // VirtualEdition classY = new VirtualEdition(ldod, ars, "VirtualModule-ClassY", "VirtualModule
        // Edition of Class Y", new LocalDate(),
        // false, null);
        // classY.addMember(luis, MemberRole.ADMIN, true);
        // classY.addMember(mp, MemberRole.ADMIN, true);
        // classY.addMember(diego, MemberRole.ADMIN, true);
        // classY.addMember(tiago, MemberRole.ADMIN, true);
        // classY.addMember(ars, MemberRole.ADMIN, true);
        // luis.addSelectedVirtualEditions(classY);
        // mp.addSelectedVirtualEditions(classY);
        // ars.addSelectedVirtualEditions(classY);
        // diego.addSelectedVirtualEditions(classY);
        // tiago.addSelectedVirtualEditions(classY);
        // nuno.addSelectedVirtualEditions(classY);
        //
        // VirtualEdition classW = new VirtualEdition(ldod, ars, "VirtualModule-ClassW", "VirtualModule
        // Edition of Class W", new LocalDate(),
        // false, null);
        // classW.addMember(diego, MemberRole.ADMIN, true);
        // classW.addMember(mp, MemberRole.ADMIN, true);
        // classW.addMember(luis, MemberRole.ADMIN, true);
        // classW.addMember(andre, MemberRole.ADMIN, true);
        // classW.addMember(tiago, MemberRole.ADMIN, true);
        // classW.addMember(nuno, MemberRole.ADMIN, true);
        // mp.addSelectedVirtualEditions(classW);
        // ars.addSelectedVirtualEditions(classW);
        // diego.addSelectedVirtualEditions(classW);
        // tiago.addSelectedVirtualEditions(classW);
        // nuno.addSelectedVirtualEditions(classW);
    }

    private static void createLdoDArchiveVirtualEdition() {
        VirtualEdition ldoDArchiveEdition = new VirtualEdition(VirtualModule.getInstance(), ARS, VirtualEdition.ARCHIVE_EDITION_ACRONYM,
                VirtualEdition.ARCHIVE_EDITION_NAME, new LocalDate(), true, null);

        ldoDArchiveEdition.addMember(ARS, Member.MemberRole.ADMIN, true);
    }
}


import pt.ist.socialsoftware.edition.virtual.domain.Category;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;

import java.io.Serializable;

//@JsonIgnoreProperties(ignoreUnknown = true)
public class CategoryDTO implements Serializable {
	private static final long serialVersionUID = 1L;

	private String id;
	private String text;
	private String selected;

	public CategoryDTO() {
	}

	public CategoryDTO(VirtualEdition virtualEdition, Category category) {
		this.id = category.getNameInEditionContext(virtualEdition);
		this.text = category.getNameInEditionContext(virtualEdition);
	}

	public String getId() {
		return this.id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getText() {
		return this.text;
	}

	public void setText(String name) {
		this.text = name;
	}

	public String getSelected() {
		return this.selected;
	}

	public void setSelected(String selected) {
		this.selected = selected;
	}

}



import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;

public class FragInterDto {

    public enum InterType {
        AUTHORIAL("authorial"), EDITORIAL("editorial"), VIRTUAL("virtual");

        private final String desc;

        InterType(String desc) {
            this.desc = desc;
        }

        public String getDesc() {
            return this.desc;
        }
    }

    private InterType type;
    private String fragmentXmlId;
    private String urlId;
    private String shortName;
    private String externalId;


    public FragInterDto(VirtualEditionInter uses) {
        setType(InterType.VIRTUAL);
        setFragmentXmlId(uses.getFragmentXmlId());
        setUrlId(uses.getUrlId());
        setShortName(uses.getShortName());
        setExternalId(uses.getExternalId());
    }

//    public FragInterDto(ScholarInter uses) {
//        setType(uses.isExpertInter() ? InterType.EDITORIAL : InterType.AUTHORIAL);
//        setFragmentXmlId(uses.getFragment().getXmlId());
//        setUrlId(uses.getUrlId());
//        setShortName(uses.getShortName());
//        setExternalId(uses.getExternalId());
//    }

    public InterType getType() {
        return this.type;
    }

    public void setType(InterType type) {
        this.type = type;
    }

    public String getFragmentXmlId() {
        return this.fragmentXmlId;
    }

    public void setFragmentXmlId(String fragmentXmlId) {
        this.fragmentXmlId = fragmentXmlId;
    }

    public String getUrlId() {
        return this.urlId;
    }

    public void setUrlId(String urlId) {
        this.urlId = urlId;
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getExternalId() {
        return this.externalId;
    }

    public void setExternalId(String externalId) {
        this.externalId = externalId;
    }
}



import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;
import javax.jms.Queue;

@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.virtual")
@SpringBootApplication
@Configuration
@EnableJms
public class VirtualApplication extends SpringBootServletInitializer implements InitializingBean {


    public static void main(String[] args) {
        SpringApplication.run(VirtualApplication.class, args);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }

}


import org.apache.activemq.ActiveMQConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration
@EnableJms
public class ConsumerConfig {


//    @Value("${activemqbrokerurl}")
//    private String brokerUrl;

    @Primary
    @Bean
    public ActiveMQConnectionFactory activeMQConnectionFactory() {
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
//        activeMQConnectionFactory.setBrokerURL("tcp://localhost:61616");
        activeMQConnectionFactory.setBrokerURL("tcp://activemq:61616");
        activeMQConnectionFactory.setTrustAllPackages(true);
        return activeMQConnectionFactory;
    }

    @Primary
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(activeMQConnectionFactory());
        factory.setPubSubDomain(true);
        return factory;
    }
}

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}


import org.joda.time.LocalDate;

public class Member extends Member_Base {

    public enum MemberRole {
        ADMIN, MEMBER
    }

    public Member(VirtualEdition virtualEdition, String user, MemberRole role, Boolean active) {
        setVirtualEdition(virtualEdition);
        setUser(user);
        setRole(role);
        setDate(LocalDate.now());
        setActive(active);
    }

    public boolean hasRole(String role) {
        return getRole().name().equals(role);
    }

    public void remove() {
        setVirtualEdition(null);

        deleteDomainObject();
    }

}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.LdoDDuplicateNameException;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;


import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class Category extends Category_Base implements Comparable<Category> {

    public String getUrlId() {
        String result = Normalizer.normalize(getName(), Normalizer.Form.NFD);
        return result.replaceAll("[^\\p{ASCII}]", "");
    }

    @Override
    public String getXmlId() {
        return getTaxonomy().getEdition().getXmlId() + "." + getName();
    }

    public Category init(Taxonomy taxonomy) {
        setTaxonomy(taxonomy);

        return this;
    }

    public Category init(Taxonomy taxonomy, String name) {
        setTaxonomy(taxonomy);
        setName(name);

        return this;
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        for (Tag tag : getTagSet()) {
            tag.remove();
        }

        setTaxonomy(null);

        deleteDomainObject();
    }

    public static String purgeName(String name) {
        String EXPRESSION = "[^\\p{L}0-9\\-\\s]+";

        String[] values = name.split("\\.");
        if (values.length == 2) {
            return values[0].replaceAll(EXPRESSION, "").trim() + "." + values[1].replaceAll(EXPRESSION, "").trim();
        }

        return name.replaceAll(EXPRESSION, "").trim();
    }

    @Atomic(mode = TxMode.WRITE)
    @Override
    public void setName(String name) {
        String purgedName = Category.purgeName(name);

        if (purgedName == null || purgedName.equals("")) {
            throw new LdoDException("Category::setName is null or empty name");
        }

        for (Category category : getTaxonomy().getCategoriesSet()) {
            if (category != this && category.getName().equals(purgedName)) {
                throw new LdoDDuplicateNameException(purgedName);
            }
        }
        super.setName(purgedName);
    }

    @Override
    public int compareTo(Category other) {
        return getName().compareTo(other.getName());
    }

    public List<Tag> getSortedTags() {
        List<Tag> tags = new ArrayList<>(getTagSet());
        Collections.sort(tags);
        return tags;
    }

    public List<Tag> getSortedTags(VirtualEdition virtualEdition) {
        return getTagSet().stream().filter(t -> t.getInter().getVirtualEdition() == virtualEdition).sorted()
                .collect(Collectors.toList());
    }

    public List<VirtualEditionInter> getSortedInters() {
        return getTagSet().stream().map(t -> t.getInter()).distinct()
                .sorted((i1, i2) -> i1.getTitle().compareTo(i2.getTitle())).collect(Collectors.toList());
    }

    public List<VirtualEditionInter> getSortedInters(VirtualEdition virtualEdition) {
        return getTagSet().stream().map(t -> t.getInter()).filter(i -> i.getVirtualEdition() == virtualEdition)
                .distinct().sorted((i1, i2) -> i1.getTitle().compareTo(i2.getTitle())).collect(Collectors.toList());
    }


    public List<String> getSortedUsers() {
        return getTagSet().stream().map(t -> t.getContributor()).distinct().sorted().collect(Collectors.toList());
    }

    public List<VirtualEdition> getSortedEditions() {
        return getTagSet().stream().map(t -> t.getInter().getVirtualEdition()).distinct()
                .sorted((ve1, ve2) -> ve1.getTitle().compareTo(ve2.getTitle())).collect(Collectors.toList());
    }

    public String getNameInEditionContext(VirtualEdition edition) {
        return edition == getTaxonomy().getEdition() ? getName()
                : getTaxonomy().getEdition().getAcronym().toUpperCase() + "." + getName();
    }

    public int compareInEditionContext(VirtualEdition edition, Category other) {
        if (this.getTaxonomy() == other.getTaxonomy()) {
            return compareTo(other);
        } else if (edition.getTaxonomy() == this.getTaxonomy()) {
            return -1;
        } else if (edition.getTaxonomy() == other.getTaxonomy()) {
            return 1;
        } else {
            return this.getTaxonomy().getEdition().getAcronym()
                    .compareTo(other.getTaxonomy().getEdition().getAcronym());
        }
    }

}


import org.apache.commons.lang.StringEscapeUtils;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;


public abstract class Annotation extends Annotation_Base {

    @Override
    public String getText() {
        if (super.getText() == null) {
            return super.getText();
        } else {
            return StringEscapeUtils.escapeHtml(super.getText());
        }
    }

    // protected, maybe
    public void init(VirtualEditionInter inter, String quote, String text) {
        setVirtualEditionInter(inter);
        setQuote(quote);
        setText(text);
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        setUser(null);

        for (Range range : getRangeSet()) {
            range.remove();
        }
        setVirtualEditionInter(null);

        deleteDomainObject();
    }

    public abstract boolean isAwareAnnotation();

    public abstract boolean isHumanAnnotation();

}


import org.joda.time.LocalDate;

import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

public class TimeWindow extends TimeWindow_Base {
	public TimeWindow(VirtualEdition edition, LocalDate beginDate, LocalDate endDate) {
		super.init(edition, TimeWindow.class);
		setBeginDate(beginDate);
		setEndDate(endDate);
	}

	@Atomic(mode = TxMode.WRITE)
	public void edit(LocalDate beginDate, LocalDate endDate) {
		setBeginDate(beginDate);
		setEndDate(endDate);
	}
}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

public class MediaSource extends MediaSource_Base {
	public MediaSource(VirtualEdition edition, String name) {
		super.init(edition, MediaSource.class);
		setName(name);
	}

	@Atomic(mode = TxMode.WRITE)
	public void edit(String name) {
		this.setName(name);
	}
}


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.HeteronymDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.LdoDDateDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.event.Event;


import pt.ist.socialsoftware.edition.notification.event.EventTagRemove;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.virtual.api.VirtualEventPublisher;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;

import pt.ist.socialsoftware.edition.virtual.config.BeanUtil;
import pt.ist.socialsoftware.edition.virtual.utils.CategoryDTO;
import pt.ist.socialsoftware.edition.virtual.utils.RangeJson;


import java.util.*;
import java.util.stream.Collectors;

public class VirtualEditionInter extends VirtualEditionInter_Base implements Comparable<VirtualEditionInter> {
    private static final Logger logger = LoggerFactory.getLogger(VirtualEditionInter.class);

    public String getUrlId() {
        return getXmlId().replace(".", "_");
    }

    @Override
    public String getXmlId() {
        return getFragmentXmlId() + ".WIT.ED.VIRT." + getVirtualEdition().getAcronym() + "." + super.getXmlId();
    }

    public HeteronymDto getHeteronym() {
        return getLastUsed().getHeteronym();
    }

    public LdoDDateDto getLdoDDate() {
        return getLastUsed().getLdoDDate();
    }

    public VirtualEditionInter(Section section, VirtualEditionInter inter, int number) {
        setUses(inter);
        setUsesScholarInterId(null);
        setFragmentXmlId(null);

        setSection(section);
        setNumber(number);
        // needs to store the number of interpretations in this fragment for this
        // edition
        setXmlId(Integer.toString(getVirtualEdition().getVirtualEditionInterSetForFragment(getFragmentXmlId()).size()));
    }

    public VirtualEditionInter(Section section, ScholarInterDto scholarInterDto, int number) {
        setUses(null);
        setUsesScholarInterId(scholarInterDto.getXmlId());
        setFragmentXmlId(scholarInterDto.getFragmentXmlId());

        setSection(section);
        setNumber(number);
        // needs to store the number of interpretations in this fragment for this
        // edition
        setXmlId(Integer.toString(getVirtualEdition().getVirtualEditionInterSetForFragment(getFragmentXmlId()).size()));
    }

    public void remove() {

        String XmlId = getXmlId();

        for (Tag tag : getTagSet()) {
            tag.remove();
        }

        for (Annotation annotation : getAnnotationSet()) {
            annotation.remove();
        }

        if (getSection() != null) {
            setSection(null);
        }

        for (VirtualEditionInter inter : getIsUsedBySet()) {
            inter.setUses(getUses());
            inter.setUsesScholarInterId(getUsesScholarInterId()); // set usesfraginter so that first level vei can now the fraginter they point too
        }

        setUses(null);

        VirtualEventPublisher virtualEventPublisher = BeanUtil.getBean(VirtualEventPublisher.class);
        virtualEventPublisher.publishEvent(new Event(Event.EventType.VIRTUAL_INTER_REMOVE, XmlId));

        deleteDomainObject();
    }

    public String getShortName() {
        return getVirtualEdition().getAcronym();
    }

    public String getTitle() {
        return getUses() != null ? getUses().getTitle() : VirtualRequiresInterface.getInstance().getScholarInterTitle(getUsesScholarInterId());
    }

    public String getUsesXmlId() {
        if (getUses() == null) {
            return getUsesScholarInterId();
        } else {
            return getUses().getXmlId();
        }
    }

    @Override
    public int compareTo(VirtualEditionInter other) {
        if (this.getVirtualEdition() == other.getVirtualEdition()) {
            int diff = getNumber() - other.getNumber();
            int result = diff > 0 ? 1 : diff < 0 ? -1 : 0;
            if (result != 0) {
                return result;
            } else {
                String myTitle = getTitle();
                String otherTitle = other.getTitle();
                return myTitle.compareTo(otherTitle);
            }
        } else {
            return this.getVirtualEdition().getTitle().compareTo(other.getVirtualEdition().getTitle());
        }

    }

    public ScholarInterDto getLastUsed() {
        return getUses() != null ? getUses().getLastUsed() : VirtualRequiresInterface.getInstance().getScholarInterByXmlId(getUsesScholarInterId());
    }

    public String getScholarInterXmlId() {
        return getUses() != null ? getUses().getScholarInterXmlId() : getUsesScholarInterId();
    }

    public VirtualEdition getEdition() {
        return getVirtualEdition();
    }

    public String getReference() {
        return Integer.toString(getNumber());
    }

    // Foi alterado por causa das human annotations
    public Set<String> getHumanAnnotationContributorSet() {
        Set<String> contributors = new HashSet<>();
        for (Annotation annotation : getAnnotationSet()) {
            if (annotation instanceof HumanAnnotation) {
                contributors.add(annotation.getUser());
            }
        }
        return contributors;
    }

    public VirtualEdition getVirtualEdition() {
        return getSection().getRootSection().getVirtualEdition();
    }

    @Atomic(mode = TxMode.WRITE)
    public HumanAnnotation createHumanAnnotation(String quote, String text, String user, List<RangeJson> rangeList,
                                                 List<String> tagList) {
        logger.debug("createHumanAnnotation start:{}, startOffset:{}, end:{}, endOffset:{}",
                rangeList.get(0).getStart(), rangeList.get(0).getStartOffset(), rangeList.get(0).getEnd(),
                rangeList.get(0).getEndOffset());

   //     SimpleText startText = null;
        // startText =
        // getFragment().getTextPortion().getSimpleText(getLastUsed(), 0,
        // rangeList.get(0).getStartOffset());
   //     SimpleText endText = null;
        // endText = getFragment().getTextPortion().getSimpleText(getLastUsed(),
        // 0, rangeList.get(0).getEndOffset());

        HumanAnnotation annotation = new HumanAnnotation(this, null, null, quote, text, user);

        for (RangeJson rangeJson : rangeList) {
            new Range(annotation, rangeJson.getStart(), rangeJson.getStartOffset(), rangeJson.getEnd(),
                    rangeJson.getEndOffset());
        }

        for (String tag : tagList) {
            createTag(annotation.getUser(), tag, annotation);
        }

        return annotation;
    }

    // TODO: createAwareAnnotation
    @Atomic(mode = TxMode.WRITE)
    public AwareAnnotation createAwareAnnotation(String quote, String text, TwitterCitation citation,
                                                 List<RangeJson> rangeList) {
        logger.debug("createAwareAnnotation start:{}, startOffset:{}, end:{}, endOffset:{}",
                rangeList.get(0).getStart(), rangeList.get(0).getStartOffset(), rangeList.get(0).getEnd(),
                rangeList.get(0).getEndOffset());

        AwareAnnotation annotation = new AwareAnnotation(this, quote, text, citation);
        for (RangeJson rangeJson : rangeList) {
            new Range(annotation, rangeJson.getStart(), rangeJson.getStartOffset(), rangeJson.getEnd(),
                    rangeJson.getEndOffset());
        }
        return annotation;
    }

    @Atomic(mode = TxMode.WRITE)
    public void associate(String user, Set<String> categoryNames) {
        Set<String> purgedCategoryNames = categoryNames.stream().map(n -> Category.purgeName(n))
                .collect(Collectors.toSet());

        getAllDepthCategoriesUsedByUserInTags(user).stream()
                .filter(c -> !purgedCategoryNames.contains(c.getNameInEditionContext(getVirtualEdition())))
                .forEach(c -> dissociate(user, c));

        Set<String> existingCategories = getAllDepthCategoriesUsedByUserInTags(user).stream()
                .map(c -> c.getNameInEditionContext(getVirtualEdition())).collect(Collectors.toSet());

        Set<String> toAssociate = purgedCategoryNames.stream().filter(cname -> !existingCategories.contains(cname))
                .collect(Collectors.toSet());

        for (String categoryName : toAssociate) {
            createTag(user, categoryName, null);
        }

    }

    // Foi alterado por causa das HumanAnnotation
    @Atomic(mode = TxMode.WRITE)
    public void dissociate(String username, Category category) {
        Set<Tag> tags = getTagSet().stream().filter(t -> t.getCategory() == category && t.getContributor().equals(username))
                .collect(Collectors.toSet());
        for (Tag tag : tags) {
            tag.remove();
        }

        Set<HumanAnnotation> annotations = getAnnotationSet().stream().filter(HumanAnnotation.class::isInstance)
                .map(HumanAnnotation.class::cast).filter(a -> a.getTagSet().isEmpty() && a.getText() == null)
                .collect(Collectors.toSet());
        for (HumanAnnotation annotation : annotations) {
            annotation.remove();
        }
    }

    public Set<Category> getCategories() {
        // return getTagSet().stream().map(t ->
        // t.getCategory()).collect(Collectors.toSet());
        Set<Category> categories = new HashSet<>();
        for (Tag tag : getTagSet()) {
            categories.add(tag.getCategory());
        }
        return categories;
    }

    public List<Category> getSortedCategories(VirtualEdition virtualEdition) {
        return getCategories().stream().filter(c -> c.getTaxonomy().getEdition() == virtualEdition)
                .collect(Collectors.toList());
    }

    public List<Category> getAllDepthCategoriesUsedInTags(String username) {
        return getAllDepthTagsAccessibleByUser(username).stream().map(t -> t.getCategory()).distinct()
                .sorted((c1, c2) -> c1.compareInEditionContext(this.getVirtualEdition(), c2))
                .collect(Collectors.toList());
    }

    public List<Category> getAllDepthCategoriesNotUsedInTags(String username) {
        List<Category> interCategories = getAllDepthCategoriesUsedByUserInTags(username);

        List<Category> categories = getAllDepthCategoriesAccessibleByUser(username).stream()
                .filter(c -> !interCategories.contains(c))
                .sorted((c1, c2) -> c1.compareInEditionContext(this.getVirtualEdition(), c2))
                .collect(Collectors.toList());

        return categories;
    }

    public List<Category> getAllDepthCategoriesUsedByUserInTags(String username) {
        List<Category> categories = getAllDepthTagsAccessibleByUser(username).stream().filter(t -> t.getContributor().equals(username))
                .map(t -> t.getCategory()).distinct()
                .sorted((c1, c2) -> c1.compareInEditionContext(this.getVirtualEdition(), c2))
                .collect(Collectors.toList());

        return categories;
    }

    public Set<Category> getAllDepthCategoriesAccessibleByUser(String username) {
        Set<Category> categories;
        if (getVirtualEdition().isPublicOrIsParticipant(username)) {
            categories = new HashSet<>(getVirtualEdition().getTaxonomy().getCategoriesSet());
        } else {
            categories = new HashSet<>();
        }

        if (getUses() != null) {
            categories.addAll(getUses().getAllDepthCategoriesAccessibleByUser(username));
        }

        return categories;
    }

    // Estava a dar erro
    /*
     * @Override public Set<HumanAnnotation> getAllDepthAnnotationsAccessibleByUser() {
     * Set<HumanAnnotation> annotations = null; if
     * (getVirtualEdition().isPublicOrIsParticipant()) { annotations = new
     * HashSet<>(getAnnotationSet()); } else { annotations = new HashSet<>(); }
     *
     * annotations.addAll(getUses().getAllDepthAnnotationsAccessibleByUser());
     *
     * return annotations; }
     */

    // Solução - a funcionar
    public Set<HumanAnnotation> getAllDepthHumanAnnotationsAccessibleByUser(String username) {
        Set<HumanAnnotation> annotations;
        if (getVirtualEdition().isPublicOrIsParticipant(username)) {
            annotations = new HashSet<>(getAnnotationSet().stream().filter(HumanAnnotation.class::isInstance)
                    .map(HumanAnnotation.class::cast).collect(Collectors.toSet()));
        } else {
            annotations = new HashSet<>();
        }

        if (getUses() != null) {
            annotations.addAll(getUses().getAllDepthHumanAnnotationsAccessibleByUser(username));
        }

        return annotations;
    }

    // Solução para suportar os dois tipos de annotation
    public Set<Annotation> getAllDepthAnnotationsAccessibleByUser(String username) {
        Set<Annotation> annotations;
        if (getVirtualEdition().isPublicOrIsParticipant(username)) {
            annotations = new HashSet<>(getAnnotationSet());
        } else {
            annotations = new HashSet<>();
        }

        if (getUses() != null) {
            annotations.addAll(getUses().getAllDepthAnnotationsAccessibleByUser(username));
        }

        return annotations;
    }

    public Set<Tag> getAllDepthTagsAccessibleByUser(String username) {
        Set<Tag> tags;

        if (getVirtualEdition().isPublicOrIsParticipant(username)) {
            tags = new HashSet<>(getTagSet());
        } else {
            tags = new HashSet<>();
        }


        if (getUses() != null) {
            tags.addAll(getUses().getAllDepthTagsAccessibleByUser(username));
        }

        return tags;
    }

    public Set<String> getContributorSet(Category category, String username) {
        Set<Tag> tagsAccessibleByUser = getAllDepthTagsAccessibleByUser(username);
        return category.getTagSet().stream()
                .filter(tag -> tagsAccessibleByUser.contains(tag))
                .map(t -> t.getContributor())
                .collect(Collectors.toSet());
    }

    public String getAllDepthCategoriesJSON(String username) {
        ObjectMapper mapper = new ObjectMapper();

        List<CategoryDTO> categories = getAllDepthCategoriesAccessibleByUser(username).stream()
                .sorted((c1, c2) -> c1.compareInEditionContext(getVirtualEdition(), c2))
                .map(c -> new CategoryDTO(getVirtualEdition(), c)).collect(Collectors.toList());

        try {
            return mapper.writeValueAsString(categories);
        } catch (JsonProcessingException e) {
            throw new LdoDException("VirtualEditionInter::getAllDepthCategoriesJSON");
        }
    }

    private void createTag(String user, String categoryName, HumanAnnotation annotation) {
        if (categoryName.contains(".")) {
            String[] values = categoryName.split("\\.");
            VirtualEdition edition = VirtualModule.getInstance().getVirtualEdition(values[0]);
            if (edition.getTaxonomy().getCategory(values[1]) != null) {
                edition.getTaxonomy().createTag(this, values[1], annotation, user);
            } else {
                throw new LdoDException("Cannot create Category in an inherited Virtual Edition");
            }
        } else {
            getVirtualEdition().getTaxonomy().createTag(this, categoryName, annotation, user);
        }
    }

    public void updateTags(HumanAnnotation annotation, List<String> tags) {
        List<String> purgedTags = tags.stream().map(n -> Category.purgeName(n)).distinct().collect(Collectors.toList());

        for (Tag tag : annotation.getTagSet()) {
            if (!purgedTags.contains(tag.getCategory().getNameInEditionContext(getVirtualEdition()))) {
                tag.remove();
            }
        }

        for (String tag : purgedTags) {
            if (!annotation.existsTag(tag, getVirtualEdition())) {
                createTag(annotation.getUser(), tag, annotation);
            }
        }
    }

    public Set<VirtualEdition> getUsedIn() {
        Set<VirtualEdition> editions = getIsUsedBySet().stream().flatMap(i -> i.getUsedIn().stream())
                .collect(Collectors.toSet());
        editions.add(getVirtualEdition());

        return editions;
    }

    public Set<Tag> getAllDepthTagsNotHumanAnnotationAccessibleByUser(String username) {
        Set<Tag> result = new HashSet<>(getAllDepthTagsAccessibleByUser(username));
        result.removeAll(getAllDepthHumanAnnotationsAccessibleByUser(username).stream().flatMap(t -> t.getTagSet().stream())
                .collect(Collectors.toSet()));
        return result;
    }

    public List<Section> getParentSectionsPath() {
        List<Section> result = new ArrayList<>();
        Section parent = getSection();
        while (parent != null) {
            result.add(0, parent);
            parent = parent.getParentSection();
        }
        return result;
    }

    public int getUsesDepth() {
        return getUses() != null ? getUses().getUsesDepth() + 1 : 1;
    }

    public int getNumberOfTimesCited() {

        return getLastUsed().getNumberOfTimesCited();
    }

    public int getNumberOfTimesCitedIncludingRetweets() {

        return getLastUsed().getNumberOfTimesCitedIncludingRetweets();
    }

    public Set<VirtualEditionInter> getIsUsedByDepthSet() {
        Set<VirtualEditionInter> isUsedBy = new HashSet<>(getIsUsedBySet());
        for (VirtualEditionInter inter : getIsUsedBySet()) {
            isUsedBy.addAll(inter.getIsUsedByDepthSet());
        }
        return isUsedBy;
    }

    @Override
    public String getFragmentXmlId() {
        return super.getFragmentXmlId() != null ? super.getFragmentXmlId() : getUses() != null ? getUses().getFragmentXmlId() : getScholarInterXmlId();
    }


    public VirtualEditionInter getNextNumberInter() {
        List<VirtualEditionInter> interps = new ArrayList<>(this.getVirtualEdition().getIntersSet());

        Collections.sort(interps);

        return findNextElementByNumber(interps);
    }

    public VirtualEditionInter getPrevNumberInter() {
        List<VirtualEditionInter> interps = new ArrayList<>(this.getVirtualEdition().getIntersSet());

        Collections.sort(interps, Collections.reverseOrder());

        return findNextElementByNumber(interps);
    }


    private VirtualEditionInter findNextElementByNumber(List<VirtualEditionInter> interps) {
        Boolean stopNext = false;
        for (VirtualEditionInter tmpInter : interps) {
            if (stopNext) {
                return tmpInter;
            }
            if (tmpInter.getNumber() == getNumber() && tmpInter == this) {
                stopNext = true;
            }
        }
        return interps.get(0);
    }

    public FragmentDto getFragmentDto() {
        return VirtualRequiresInterface.getInstance().getFragmentOfScholarInterDto(getLastUsed());
    }

}


import pt.ist.fenixframework.Atomic;

public class LastTwitterID extends LastTwitterID_Base {

    public static final String FP_CITATIONS = "fp";
    public static final String LIVRO_CITATIONS = "livro";
    public static final String BERNARDO_CITATIONS = "bernardo";
    public static final String VICENTE_CITATIONS = "vicente";

    public LastTwitterID() {
        super();
    }

    public long getLastTwitterID(String fileName) {
        if (fileName.contains(FP_CITATIONS)) {
            return getPessoaLastTwitterID();
        } else if (fileName.contains(LIVRO_CITATIONS)) {
            return getBookLastTwitterID();
        } else if (fileName.contains(BERNARDO_CITATIONS)) {
            return getBernardoLastTwitterID();
        } else if (fileName.contains(VICENTE_CITATIONS)) {
            return getVicenteLastTwitterID();
        }
        return 0; // is it the best policy by default to return 0 instead?
    }

    public String getLastParsedFile(String fileName) {
        if (fileName.contains(FP_CITATIONS)) {
            return getLastPessoaParsedFile();
        } else if (fileName.contains(LIVRO_CITATIONS)) {
            return getLastBookParsedFile();
        } else if (fileName.contains(BERNARDO_CITATIONS)) {
            return getLastBernardoParsedFile();
        } else if (fileName.contains(VICENTE_CITATIONS)) {
            return getLastVicenteParsedFile();
        }
        return null;

    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateLastTwitterID(String fileName, long newID) {
        if (fileName.contains(FP_CITATIONS)) {
            setPessoaLastTwitterID(newID);
        } else if (fileName.contains(LIVRO_CITATIONS)) {
            setBookLastTwitterID(newID);
        } else if (fileName.contains(BERNARDO_CITATIONS)) {
            setBernardoLastTwitterID(newID);
        } else if (fileName.contains(VICENTE_CITATIONS)) {
            setVicenteLastTwitterID(newID);
        }
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public void updateLastParsedFile(String fileName) {
        if (fileName.contains(FP_CITATIONS)) {
            setLastPessoaParsedFile(fileName);
        } else if (fileName.contains(LIVRO_CITATIONS)) {
            setLastBookParsedFile(fileName);
        } else if (fileName.contains(BERNARDO_CITATIONS)) {
            setLastBernardoParsedFile(fileName);
        } else if (fileName.contains(VICENTE_CITATIONS)) {
            setLastVicenteParsedFile(fileName);
        }
    }

    public void resetTwitterIDS() {
        setLastPessoaParsedFile(null);
        setLastBookParsedFile(null);
        setLastBernardoParsedFile(null);
        setLastVicenteParsedFile(null);

        setPessoaLastTwitterID(0);
        setBookLastTwitterID(0);
        setBernardoLastTwitterID(0);
        setVicenteLastTwitterID(0);
    }

    public void remove() {
        setVirtualModule(null);
        deleteDomainObject();
    }

}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

public class Frequency extends Frequency_Base {
	public Frequency(VirtualEdition edition, int frequency) {
		super.init(edition, Frequency.class);
		setFrequency(frequency);
	}

	@Atomic(mode = TxMode.WRITE)
	public void edit(int frequency) {
		setFrequency(frequency);
	}
}


import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.notification.dtos.text.CitationDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;


import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class VirtualModule extends VirtualModule_Base {
    private static final Logger log = LoggerFactory.getLogger(VirtualModule.class);


    public static VirtualModule getInstance() {
        return FenixFramework.getDomainRoot().getVirtualModule();
    }

    public VirtualModule() {
        FenixFramework.getDomainRoot().setVirtualModule(this);
        setLastTwitterID(new LastTwitterID()); // check if this is supposed to be here
        VirtualRequiresInterface.getInstance();
    }

    public void remove() {

        VirtualRequiresInterface.getInstance().removeAllCitations();

        getTweetSet().forEach(t -> t.remove());

        getVirtualEditionsSet().forEach(v -> v.remove());

        getLastTwitterID().remove();
        setRoot(null);

        deleteDomainObject();
    }

    public VirtualEdition getVirtualEdition(String acronym) {
        for (VirtualEdition edition : getVirtualEditionsSet()) {
            if (edition.getAcronym().toUpperCase().equals(acronym.toUpperCase())) {
                return edition;
            }
        }

        return null;
    }

    @Atomic(mode = TxMode.WRITE)
    public VirtualEdition createVirtualEdition(String user, String acronym, String title, LocalDate date, boolean pub,
                                               String acronymOfUsed) {
        log.debug("createVirtualEdition user:{}, acronym:{}, title:{}", user, acronym, title);
        return new VirtualEdition(this, user, acronym, title, date, pub, acronymOfUsed);
    }

    public VirtualEdition getArchiveEdition() {
        return getVirtualEditionsSet().stream().filter(ve -> ve.getAcronym().equals(VirtualEdition.ARCHIVE_EDITION_ACRONYM))
                .findAny().orElse(null);
    }

    public VirtualEdition getVirtualEditionByXmlId(String xmlId) {
        return getVirtualEditionsSet().stream().filter(ve -> ve.getXmlId().equals(xmlId)).findFirst().orElse(null);
    }

    public VirtualEditionInter getVirtualEditionInterByUrlId(String urlId) {
        return getVirtualEditionsSet().stream().map(virtualEdition -> virtualEdition.getFragInterByUrlId(urlId))
                .filter(Objects::nonNull).map(VirtualEditionInter.class::cast).findAny().orElse(null);
    }

    public VirtualEditionInter getVirtualEditionInterByXmlId(String xmlId) {
        return getVirtualEditionsSet().stream().map(virtualEdition -> virtualEdition.getFragInterByXmlId(xmlId))
                .filter(Objects::nonNull).map(VirtualEditionInter.class::cast).findAny().orElse(null);
    }

    public Set<VirtualEditionInter> getVirtualEditionInterSet() {
        return getVirtualEditionsSet().stream().flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream()).collect(Collectors.toSet());
    }

    public Set<VirtualEditionInter> getVirtualEditionInterSet(String fragmentXmlId) {
        return getVirtualEditionInterSet().stream().filter(virtualEditionInter -> virtualEditionInter.getFragmentXmlId().equals(fragmentXmlId)).collect(Collectors.toSet());
    }

    public Set<TwitterCitation> getAllTwitterCitation() {
        // allTwitterCitations -> all twitter citations in the archive
        Set<TwitterCitation> allTwitterCitations = VirtualRequiresInterface.getInstance().getCitationSet().stream().map(TwitterCitation::new).collect(Collectors.toSet());
        return allTwitterCitations;
    }

    @Atomic(mode = TxMode.WRITE)
    public static void deleteTweetCitationsWithoutInfoRangeOrTweet() {
        VirtualModule.getInstance().getAllTwitterCitation().stream()
                .filter(c -> c.getInfoRangeDtoSet().isEmpty() || c.getTweetSet().isEmpty()).forEach(c -> c.remove());
    }

    @Atomic(mode = TxMode.WRITE)
    public static void deleteTweetsWithoutCitation() {
        VirtualModule.getInstance().getTweetSet().stream().filter(t -> t.getCitation() == null).forEach(t -> t.remove());
    }

    public TwitterCitation getTwitterCitationByTweetID(long id) {
        TwitterCitation result = null;
        Set<TwitterCitation> allTwitterCitations = getAllTwitterCitation();
        for (TwitterCitation tc : allTwitterCitations) {
            if (tc.getTweetID() == id) {
                result = tc;
            }
        }
        return result;
    }

    public Tweet getTweetByTweetID(long id) {
        Tweet result = null;
        Set<Tweet> allTweets = getTweetSet();
        for (Tweet t : allTweets) {
            if (t.getTweetID() == id) {
                result = t;
            }
        }
        return result;
    }

    public boolean checkIfTweetExists(long id) {
        Set<Tweet> allTweets = getTweetSet();
        for (Tweet t : allTweets) {
            if (t.getTweetID() == id) {
                return true;
            }
        }
        return false;
    }

//    public Set<Citation> getCitationSet() {
//        // NOTE: This is a workaround until citations and tweets and in their own module
//        if (TextModule.getInstance() == null) {
//            return new HashSet<>();
//        }
//
//        return TextModule.getInstance()
//                .getFragmentsSet().stream()
//                .flatMap(f -> f.getCitationSet().stream()).collect(Collectors.toSet());
//    }

//    public Citation getCitationById(long id) {
//        return textProvidesInterface.getCitationSet().stream().filter(citation -> citation.getId() == id).findFirst().orElse(null);
//    }

//    public long getLastTwitterCitationId() {
//        long res = 0;
//        for (CitationDto c : textProvidesInterface.getCitationSet()) {
//            if (c instanceof TwitterCitation) {
//                if (((TwitterCitation) c).getTweetID() > res) {
//                    res = ((TwitterCitation) c).getTweetID();
//                }
//            }
//        }
//        return res;
//    }

//    public List<Citation> getCitationsWithInfoRanges() {
//        DateTimeFormatter formater = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");
//
//        return textProvidesInterface.getCitationSet().stream().filter(c -> !c.getInfoRangeSet().isEmpty())
//                .sorted((c1, c2) -> LocalDateTime.parse(c2.getDate(), formater)
//                        .compareTo(LocalDateTime.parse(c1.getDate(), formater)))
//                .collect(Collectors.toList());
//    }

    public long getLastTwitterCitationId() {
        long res = 0;
        for (CitationDto c : VirtualRequiresInterface.getInstance().getCitationSet()) {
            if (c.isTwitterCitation()) {
                TwitterCitation twitterCitation = FenixFramework.getDomainObject(c.getExternalId());
                if (twitterCitation.getTweetID() > res) {
                    res = twitterCitation.getTweetID();
                }
            }
        }
        return res;
    }



    public int getNumberOfCitationsWithInfoRanges() {
        return VirtualRequiresInterface.getInstance().getCitationsWithInfoRanges().size();
    }

    @Atomic(mode = TxMode.WRITE)
    public void removeTweets() {
        getLastTwitterID().resetTwitterIDS();
        getTweetSet().forEach(t -> t.remove());
    }

    @Atomic(mode = TxMode.WRITE)
    public void removeTweetsWithoutCitationsWithInfoRange() {
        getTweetSet().forEach(t -> {
            if (t.getCitation() == null || t.getCitation().getInfoRangeDtoSet().isEmpty()) {
                t.remove();
            }
        });
    }

    public static String TWITTER_EDITION_ACRONYM = "VirtualModule-Twitter";
    public static int TWITTER_EDITION_DAYS = 30;

    @Atomic(mode = TxMode.WRITE)
    public static void dailyRegenerateTwitterCitationEdition() {
        VirtualEdition twitterEdition = VirtualModule.getInstance().getVirtualEdition("LdoD-" + TWITTER_EDITION_ACRONYM);

        System.out.println(twitterEdition);
        twitterEdition.getAllDepthVirtualEditionInters().stream().
                forEach(inter ->
                        inter.remove());

        LocalDate editionBeginDateJoda = LocalDate.now().minusDays(TWITTER_EDITION_DAYS);
        if (twitterEdition.getTimeWindow() == null) {
            new TimeWindow(twitterEdition, editionBeginDateJoda, null);
        } else {
            twitterEdition.getTimeWindow().setBeginDate(editionBeginDateJoda);
        }

        LocalDateTime editionBeginDateTime = LocalDateTime.of(editionBeginDateJoda.getYear(),
                editionBeginDateJoda.getMonthOfYear(), editionBeginDateJoda.getDayOfMonth(), 0, 0);
        int number = 0;



        VirtualRequiresInterface.getInstance().getScholarInterDtoListTwitterEdition(editionBeginDateTime);

        for (ScholarInterDto scholarInterDto : VirtualRequiresInterface.getInstance().getScholarInterDtoListTwitterEdition(editionBeginDateTime)) {
            twitterEdition.createVirtualEditionInter(scholarInterDto, ++number);
        }
    }

    public List<VirtualEdition> getVirtualEditionsUserIsParticipant(String username) {
        return getVirtualEditionsSet().stream()
                .filter(virtualEdition -> virtualEdition.getParticipantSet().contains(username))
                .collect(Collectors.toList());
    }

    public List<VirtualEdition> getVirtualEditionsUserIsParticipantSelectedOrPublic(String user) {
        List<VirtualEdition> manageVE = new ArrayList<>();
        List<VirtualEdition> selectedVE = new ArrayList<>();
        List<VirtualEdition> mineVE = new ArrayList<>();
        List<VirtualEdition> publicVE = new ArrayList<>();

        for (VirtualEdition virtualEdition : getVirtualEditionsSet()) {
            if (user != null
                    && virtualEdition.getSelectedBySet().stream().anyMatch(selectedBy -> selectedBy.getUser().equals(user))) {
                selectedVE.add(virtualEdition);
            } else if (virtualEdition.getParticipantSet().contains(user)) {
                mineVE.add(virtualEdition);
            } else if (virtualEdition.getPub() && !selectedVE.contains(virtualEdition)) {
                publicVE.add(virtualEdition);
            }
        }

        manageVE.addAll(selectedVE);
        manageVE.addAll(mineVE);
        manageVE.addAll(publicVE);

        return manageVE;
    }

    public List<VirtualEditionInter> getVirtualEditionIntersUserIsContributor(String username) {
        Set<VirtualEditionInter> virtualEditionIntersPublicAndParticipant =
                getVirtualEditionsSet().stream()
                        .filter(virtualEdition -> virtualEdition.getPub() || virtualEdition.getParticipantSet().contains(username))
                        .flatMap(virtualEdition -> virtualEdition.getAllDepthVirtualEditionInters().stream())
                        .collect(Collectors.toSet());

        Stream<VirtualEditionInter> virtualEditionIntersAnnotated = virtualEditionIntersPublicAndParticipant.stream()
                .filter(virtualEditionInter -> virtualEditionInter.getAnnotationSet().stream()
                        .anyMatch(annotation -> annotation.getUser().equals(username)));

        Stream<VirtualEditionInter> virtualEditionIntersTagged = virtualEditionIntersPublicAndParticipant.stream()
                .filter(virtualEditionInter -> virtualEditionInter.getTagSet().stream()
                        .anyMatch(tag -> tag.getContributor().equals(username)));

        return Stream.concat(virtualEditionIntersAnnotated, virtualEditionIntersTagged).distinct()
                .sorted(Comparator.comparing(VirtualEditionInter::getTitle)).collect(Collectors.toList());
    }

    public List<VirtualEdition> getPublicVirtualEditionsOrUserIsParticipant(String username) {
        return getVirtualEditionsSet().stream()
                .filter(virtualEdition -> virtualEdition.getPub() || virtualEdition.getParticipantSet().contains(username))
                .distinct()
                .sorted(Comparator.comparing(VirtualEdition::getTitle))
                .collect(Collectors.toList());
    }

    public Set<VirtualEdition> getSelectedVirtualEditionsByUser(String username) {
        return getVirtualEditionsSet().stream()
                .filter(virtualEdition -> virtualEdition.getSelectedBySet().stream().
                        anyMatch(selectedBy -> selectedBy.getUser().equals(username)))
                .collect(Collectors.toSet());
    }

    public List<String> getUserSelectedVirtualEditions(String username) {
        return getVirtualEditionsSet().stream()
                .filter(virtualEdition -> virtualEdition.getSelectedBySet().stream().map(selectedBy -> selectedBy.getUser())
                        .anyMatch(user -> user.equals(username)))
                .map(virtualEdition -> virtualEdition.getAcronym())
                .collect(Collectors.toList());

    }

    public void addToUserSelectedVirtualEditions(String username, List<String> selectedAcronyms) {
        getVirtualEditionsSet().stream()
                .filter(virtualEdition -> selectedAcronyms.contains(virtualEdition.getAcronym()))
                .forEach(virtualEdition -> virtualEdition.addSelectedByUser(username));
    }

}



import pt.ist.socialsoftware.edition.notification.utils.LdoDException;

public class SelectedBy extends SelectedBy_Base {

    public SelectedBy(VirtualEdition virtualEdition, String user) {
        if (virtualEdition.isSelectedBy(user)) {
            throw new LdoDException();
        }

        setVirtualEdition(virtualEdition);
        setUser(user);
    }

    public void remove() {
        setVirtualEdition(null);

        deleteDomainObject();
    }

}


import pt.ist.socialsoftware.edition.notification.dtos.text.CitationDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.InfoRangeDto;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;


import java.util.Set;

public class TwitterCitation extends TwitterCitation_Base {



	public TwitterCitation(FragmentDto fragment, String sourceLink, String date, String fragText, String tweetText,
						   long tweetID, String location, String country, String username, String profURL, String profImgURL) {

	//	super.init(fragment.getXmlId(), sourceLink, date.trim(), fragText.trim());

//		infoRangeDtos = VirtualRequiresInterface.getInstance().getInfoRangeDtoSetFromCitation("");

		setFragmentXmlId(fragment.getXmlId());
		setDate(date);
		setSourceLink(sourceLink);
		setFragText(fragText.trim());

		setTweetText(tweetText.trim());
		setTweetID(tweetID);
		setLocation(location.trim());
		setCountry(country.trim());
		setUsername(username);
		setUserProfileURL(profURL);
		setUserImageURL(profImgURL);
		VirtualRequiresInterface.getInstance().createCitation(getFragmentXmlId(), sourceLink, date, fragText, tweetID);
	}

	public TwitterCitation(CitationDto citationDto) {
		setFragmentXmlId(citationDto.getFragmentXmlId());
		setSourceLink(citationDto.getSourceLink());
		setDate(citationDto.getDate());
		setTweetText("");
		setTweetID(citationDto.getId());
		setLocation("");
		setCountry("");
		setUsername("");
		setUserProfileURL("");
		setUserImageURL("");
	}


	public boolean isTwitterCitation() {
		return false;
	}


	public void remove() {
		getTweetSet().stream().forEach(t -> removeTweet(t));

	//	super.remove();
	}


	public long getId() {
		return getTweetID();
	}


	public int getNumberOfRetweets() {
		return this.getTweetSet().size() - 1; // -1 to not include the original tweet
	}


//	public Set<InfoRangeDto> getInfoRangeDtoSet() {
//		return VirtualRequiresInterface.getInstance().getInfoRangeDtoSetFromCitation(getExternalId());
//	}



	public Set<InfoRangeDto> getInfoRangeDtoSet() {
		return VirtualRequiresInterface.getInstance().getInfoRangeDtoSetFromCitation(getId());
	}
}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

public class AwareAnnotation extends AwareAnnotation_Base {

    public static String USER_TWITTER = "Twitter";

    public AwareAnnotation(VirtualEditionInter inter, String quote, String text, TwitterCitation citation) {
        super.init(inter, quote, text);
        this.setCitation(citation);
        this.setUser(USER_TWITTER);
    }

    @Override
    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        setCitation(null);

        super.remove();
    }

    @Override
    public boolean isAwareAnnotation() {
        return true;
    }

    @Override
    public boolean isHumanAnnotation() {
        return false;
    }

    public String getSourceLink() {
        return this.getCitation().getSourceLink();
    }

    public String getDate() {
        return this.getCitation().getDate().split(" ")[0];
    }

    public String getCountry() {
        return ((TwitterCitation) this.getCitation()).getCountry();
    }

    public String getProfileURL() {
        return ((TwitterCitation) this.getCitation()).getUserProfileURL();
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;


import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicDTO;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicInterPercentageDTO;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicListDTO;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;


import java.util.*;
import java.util.stream.Collectors;

public class Taxonomy extends Taxonomy_Base {
    private static final Logger logger = LoggerFactory.getLogger(Taxonomy.class);

    public Taxonomy() {
        setOpenManagement(false);
        setOpenVocabulary(true);
        setOpenAnnotation(false);
    }

    public String getName() {
        return getEdition().getTitle();
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        setEdition(null);

        for (Category category : getCategoriesSet()) {
            category.remove();
        }

        deleteDomainObject();
    }

    public Set<Tag> getTagSet(VirtualEditionInter inter) {
        Set<Tag> set = new HashSet<>();
        for (Tag tag : inter.getTagSet()) {
            if (tag.getCategory().getTaxonomy() == this) {
                set.add(tag);
            }
        }
        return set;
    }

    public List<VirtualEditionInter> getSortedFragInter() {
        Set<VirtualEditionInter> set = new HashSet<>();
        for (Category category : getCategoriesSet()) {
            for (Tag tag : category.getTagSet()) {
                set.add(tag.getInter());
            }
        }
        List<VirtualEditionInter> list = new ArrayList<>(set);
        Collections.sort(list);

        return list;
    }

    public List<Category> getSortedCategories() {
        return getCategoriesSet().stream().sorted((c1, c2) -> c1.getName().compareTo(c2.getName()))
                .collect(Collectors.toList());
    }

    public List<Tag> getSortedTags(VirtualEdition virtualEdition) {
        return getCategoriesSet().stream().flatMap(c -> c.getTagSet().stream())
                .filter(t -> t.getInter().getVirtualEdition() == virtualEdition).distinct().sorted()
                .collect(Collectors.toList());
    }

    public Set<String> getTagContributorSet(VirtualEditionInter inter) {
        Set<String> contributors = new HashSet<>();
        for (Tag tag : getTagSet(inter)) {
            contributors.add(tag.getContributor());
        }
        return contributors;
    }

    public Category getCategory(String name) {
        for (Category category : getCategoriesSet()) {
            if (name.equals(category.getName())) {
                return category;
            }
        }
        return null;
    }

    public Category getCategoryByUrlId(String urlId) {
        for (Category category : getCategoriesSet()) {
            if (urlId.equals(category.getUrlId())) {
                return category;
            }
        }
        return null;
    }

    public List<VirtualEdition> getUsedIn() {
        Set<VirtualEdition> editions = new HashSet<>();
        for (VirtualEditionInter inter : getEdition().getAllDepthVirtualEditionInters()) {
            editions.addAll(inter.getUsedIn());
        }

        editions.remove(getEdition());

        return editions.stream().sorted((ve1, ve2) -> ve1.getAcronym().compareTo(ve2.getAcronym()))
                .collect(Collectors.toList());
    }

    @Atomic(mode = TxMode.WRITE)
    public Category merge(List<Category> categories) {

        String name = categories.stream().map(c -> c.getName()).collect(Collectors.joining(" "));

        while (getCategory(name) != null) {
            name = name + "1";
        }

        Category category = new Category().init(this, name);

        categories.stream().flatMap(c -> c.getTagSet().stream()).forEach(t -> category.addTag(t));

        categories.stream().forEach(c -> c.remove());

        return category;
    }

    @Atomic(mode = TxMode.WRITE)
    public Category extract(Category category, Set<VirtualEditionInter> inters) {
        String suffix = "_Extracted";
        String newName = category.getName() + suffix;
        while (getCategory(newName) != null) {
            newName = newName + suffix;
        }

        Category newCategory = new Category().init(this, newName);

        for (VirtualEditionInter inter : inters) {
            inter.getTagSet().stream().filter(t -> t.getCategory() == category)
                    .forEach(t -> t.setCategory(newCategory));
        }

        return newCategory;
    }

    public Tag createTag(VirtualEditionInter virtualEditionInter, String categoryName, HumanAnnotation annotation,
                         String user) {
        if (!getOpenVocabulary() && getCategory(categoryName) == null) {
            throw new LdoDException("Tag name does not exist in taxonomy with closed vocabulary");
        }
        return new Tag().init(this.getEdition(), virtualEditionInter, categoryName, annotation, user);
    }

    @Atomic(mode = TxMode.WRITE)
    public Category createCategory(String name) {
        return new Category().init(this, name);
    }

    @Atomic(mode = TxMode.WRITE)
    public void createGeneratedCategories(TopicListDTO topicList) {
        if (topicList.getTopics() == null) {
            return;
        }


        UserDto user = VirtualRequiresInterface.getInstance().getUser(topicList.getUsername());

        for (TopicDTO topic : topicList.getTopics()) {
            Category category = new Category();
            category.init(this, topic.getName());
            for (TopicInterPercentageDTO topicPercentage : topic.getInters()) {
                VirtualEditionInter inter = FenixFramework.getDomainObject(topicPercentage.getExternalId());
                new Tag().init(inter, category, user.getUsername());
            }
        }

    }

    @Atomic(mode = TxMode.WRITE)
    public void delete(List<Category> categories) {
        categories.stream().forEach(c -> c.remove());
    }

    @Atomic(mode = TxMode.WRITE)
    public void edit(boolean openManagement, boolean openVocabulary, boolean openAnnotation) {
        setOpenManagement(openManagement);
        setOpenVocabulary(openVocabulary);
        setOpenAnnotation(openAnnotation);
    }

    public boolean canManipulateAnnotation(String user) {
        if (user != null && getOpenAnnotation()) {
            return true;
        } else {
            return getEdition().getParticipantSet().contains(user);
        }
    }

    public boolean canManipulateTaxonomy(String user) {
        if (getOpenManagement()) {
            return getEdition().getParticipantSet().contains(user);
        } else {
            return getEdition().getAdminSet().contains(user);
        }
    }
}



import pt.ist.socialsoftware.edition.notification.utils.LdoDException;

public class Tweet extends Tweet_Base {

    public Tweet(VirtualModule virtualModule, String sourceLink, String date, String tweetText, long tweetID, String location,
                 String country, String username, String profURL, String profImgURL, long originalTweetID, boolean isRetweet,
                 TwitterCitation twitterCitation) {
        if (!isRetweet && originalTweetID != -1l) {
            throw new LdoDException("This tweet is not a retweet, therefore its original tweet id must be -1!");
        }
        setVirtualModule(virtualModule);
        setSourceLink(sourceLink);
        setDate(date);
        setTweetText(tweetText);

        setTweetID(tweetID);
        setLocation(location);
        setCountry(country);
        setUsername(username);
        setUserProfileURL(profURL);
        setUserImageURL(profImgURL);

        setOriginalTweetID(originalTweetID);
        setIsRetweet(isRetweet);
        setCitation(twitterCitation);
    }

    public void remove() {
        setVirtualModule(null);
        if (getCitation() != null) {
            getCitation().remove();
        }

        deleteDomainObject();
    }
}


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

public class GeographicLocation extends GeographicLocation_Base {
	// never used because "location" on Twitter can be anything weirdly written
	public GeographicLocation(VirtualEdition virtualEdition, String country, String location) {
		super.init(virtualEdition, GeographicLocation.class);
		setCountry(country);
		setLocation(location);
	}

	public GeographicLocation(VirtualEdition virtualEdition, String country) {
		super.init(virtualEdition, GeographicLocation.class);
		setCountry(country);
	}

	@Atomic(mode = TxMode.WRITE)
	public void edit(String country) {
		setCountry(country);
	}

	public boolean containsCountry(String country) {
		return Arrays.stream(this.getCountry().split(",")).anyMatch(country::equals);
	}

	public boolean containsEveryCountry() {
		List<String> countriesList = new ArrayList<String>();
		countriesList.add("Portugal");
		countriesList.add("Brazil");
		countriesList.add("Spain");
		countriesList.add("United Kingdom");
		countriesList.add("United States");
		countriesList.add("Lebanon");
		countriesList.add("Angola");
		countriesList.add("Mozambique");

		boolean res = false;
		for (String country : countriesList) {
			if (this.getCountry().contains(country)) {
				res = true;
			} else {
				res = false;
				break;
			}
		}

		return res;
	}
}


import org.apache.commons.lang.StringUtils;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

import java.util.*;

public class Section extends Section_Base implements Comparable<Section> {
    public static String DEFAULT = "default";

    public Section(VirtualEdition virtualEdition, String title, int number) {
        setTitle(title);
        setVirtualEdition(virtualEdition);
        setNumber(number);
    }

    public Section(Section section, String title, int number) {
        setParentSection(section);
        setTitle(title);
        setNumber(number);
    }

    public Set<VirtualEditionInter> getAllDepthVirtualEditionInterSet() {
        Set<VirtualEditionInter> inters = new HashSet<>();

        // Add section's inters
        Set<VirtualEditionInter> virtualEditionInterSet = getVirtualEditionInterSet();
        if (virtualEditionInterSet != null) {
            inters.addAll(virtualEditionInterSet);
        }

        // add subsection's inters
        Set<Section> subSectionSet = getSubSectionsSet();
        if (subSectionSet != null) {
            for (Section section : subSectionSet) {
                inters.addAll(section.getAllDepthVirtualEditionInterSet());
            }
        }
        return inters;
    }

    @Override
    public int compareTo(Section section) {
        return ((Integer) this.getNumber()).compareTo(section.getNumber());
    }

    @Atomic(mode = TxMode.WRITE)
    public Section createSection(String title, int number) {
        Section subSection = new Section(this, title, number);
        return subSection;
    }

    public boolean isRootSection() {
        return getParentSection() == null;
    }

    public Section getRootSection() {
        return isRootSection() ? this : getParentSection().getRootSection();
    }

    public void clear() {
        for (Section section : getSubSectionsSet()) {
            section.clear();
        }

        for (VirtualEditionInter inter : getVirtualEditionInterSet()) {
            inter.setSection(null);
        }

        setParentSection(null);
        setVirtualEdition(null);

        deleteDomainObject();
    }

    public void remove() {
        for (Section section : getSubSectionsSet()) {
            section.remove();
        }

        for (VirtualEditionInter inter : getVirtualEditionInterSet()) {
            inter.remove();
        }

        setParentSection(null);
        setVirtualEdition(null);

        deleteDomainObject();
    }

    public Section getSection(String title) {
        for (Section section : getSubSectionsSet()) {
            if (section.getTitle().equals(title)) {
                return section;
            }
        }

        return null;
    }

    public Section createSection(String title) {
        int number = getSubSectionsSet().size();
        return createSection(title, number);
    }

    @Atomic(mode = TxMode.WRITE)
    public void addVirtualEditionInter(VirtualEditionInter virtualEditionInter, int i) {
        virtualEditionInter.setNumber(i);
        virtualEditionInter.setSection(this);
    }

    public boolean isLeaf() {
        if (getSubSectionsSet() == null) {
            return true;
        } else if (getSubSectionsSet().size() == 0) {
            return true;
        } else {
            return false;
        }
    }

    public int getDepth() {
        if (isLeaf()) {
            return 1;
        } else {
            int max = 0;
            for (Section section : getSubSectionsSet()) {
                int depth = section.getDepth();
                if (max < depth) {
                    max = depth;
                }
            }
            return 1 + max;
        }
    }

    public String print(int i) {
        String result = StringUtils.repeat("\t", i) + getNumber() + ":" + getTitle() + "\n";
        for (Section section : getSubSectionsSet()) {
            result = result + section.print(i + 1);
        }
        for (VirtualEditionInter inter : getVirtualEditionInterSet()) {
            result = result + StringUtils.repeat("\t", i + 1) + inter.getNumber() + ":" + inter.getTitle() + "\n";
        }
        return result;
    }

    public List<Section> getSortedSubSections() {
        List<Section> sortedList = new ArrayList<>(getSubSectionsSet());
        Collections.sort(sortedList);
        return sortedList;
    }

    public List<VirtualEditionInter> getSortedInters() {
        List<VirtualEditionInter> sortedList = new ArrayList<>(getVirtualEditionInterSet());
        Collections.sort(sortedList);
        return sortedList;
    }

    @Override
    public VirtualEdition getVirtualEdition() {
        if (isRootSection()) {
            return super.getVirtualEdition();
        } else {
            return getRootSection().getVirtualEdition();
        }
    }

    public void clearEmptySections() {
        for (Section section : getSubSectionsSet()) {
            section.clearEmptySections();
        }

        for (Section section : getSubSectionsSet()) {
            if (section.getAllDepthVirtualEditionInterSet().size() == 0) {
                section.remove();
            }
        }
    }

}

import pt.ist.socialsoftware.edition.virtual.domain.Range_Base;

public class Range extends Range_Base {

	public Range(Annotation annotation, String start, int startOffset,
			String end, int endOffset) {
		setAnnotation(annotation);
		setStart(start);
		setStartOffset(startOffset);
		setEnd(end);
		setEndOffset(endOffset);
	}

	public void remove() {
		setAnnotation(null);
		deleteDomainObject();
	}

}



import pt.ist.socialsoftware.edition.notification.utils.LdoDException;

public abstract class SocialMediaCriteria extends SocialMediaCriteria_Base {

//    protected void init(VirtualEdition edition, Class<?> clazz) {
//        checkUniqueCriteriaType(edition, clazz);
//        setVirtualEdition(edition);
//    }
//
//    protected void checkUniqueCriteriaType(VirtualEdition edition, Class<?> clazz) {
//        if (edition.getCriteriaSet().stream().filter(clazz::isInstance).findFirst().isPresent()) {
//            throw new LdoDException("THIS CRITERION ALREADY EXISTS!!");
//        }
//    }
//
//    public void remove() {
//        setVirtualEdition(null);
//
//        deleteDomainObject();
//    }

    public void init(VirtualEdition edition, Class<?> clazz) {
        checkUniqueCriteriaType(edition, clazz);
        setVirtualEdition(edition);
    }

    public void checkUniqueCriteriaType(VirtualEdition edition, Class<?> clazz) {
        if (edition.getCriteriaSet().stream().filter(clazz::isInstance).findFirst().isPresent()) {
            throw new LdoDException("THIS CRITERION ALREADY EXISTS!!");
        }
    }

    public void remove() {
        setVirtualEdition(null);

        deleteDomainObject();
    }

}



import pt.ist.socialsoftware.edition.notification.event.EventInterface;
import pt.ist.socialsoftware.edition.notification.event.EventTagRemove;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.virtual.api.VirtualEventPublisher;
import pt.ist.socialsoftware.edition.virtual.config.BeanUtil;


public class Tag extends Tag_Base implements Comparable<Tag> {

    public Tag init(VirtualEdition virtualEdition, VirtualEditionInter inter, String categoryName,
                    HumanAnnotation annotation, String user) {
        setInter(inter);
        Taxonomy taxonomy = virtualEdition.getTaxonomy();
        Category category = taxonomy.getCategory(Category.purgeName(categoryName));
        if (category == null) {
            if (taxonomy.getOpenVocabulary()) {
                category = taxonomy.createCategory(categoryName);
            } else {
                throw new LdoDException("Cannot create Category using Closed Vocabulary");
            }
        }
        setCategory(category);
        setAnnotation(annotation);
        setContributor(user);

        return this;
    }

    public Tag init(VirtualEditionInter inter, Category category, String user) {
        setInter(inter);
        setCategory(category);
        setAnnotation(null);
        setContributor(user);

        return this;
    }

    public void remove() {
        String InterXmlId = getInter().getXmlId();
        String categoryXmlId = getCategory().getUrlId();

        setInter(null);

        if (getCategory() != null && getCategory().getTaxonomy().getOpenAnnotation()
                && getCategory().getTagSet().size() == 1) {
            Category category = getCategory();
            setCategory(null);
            category.remove();
        }

        setCategory(null);

        setAnnotation(null);

//        EventInterface.getInstance().publish(new EventTagRemove(InterXmlId, categoryXmlId));
        VirtualEventPublisher virtualEventPublisher = BeanUtil.getBean(VirtualEventPublisher.class);
        virtualEventPublisher.publishEvent(new EventTagRemove(InterXmlId, categoryXmlId));


        deleteDomainObject();
    }

    @Override
    public int compareTo(Tag other) {
        return this.getCategory().getName().compareTo(other.getCategory().getName());
    }

}


import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.StringEscapeUtils;
import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;

import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.user.UserDto;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.notification.event.EventVirtualEditionUpdate;


import pt.ist.socialsoftware.edition.notification.utils.LdoDDuplicateAcronymException;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.api.VirtualEventPublisher;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.config.BeanUtil;


import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

public class VirtualEdition extends VirtualEdition_Base {
    private static final Logger logger = LoggerFactory.getLogger(VirtualEdition.class);

    public static final String ARCHIVE_EDITION_ACRONYM = "LdoD-Arquivo";
    public static final String ARCHIVE_EDITION_NAME = "Arquivo LdoD";
    public static String ACRONYM_PREFIX = "LdoD-";

    @Override
    public String getTitle() {
        return StringEscapeUtils.escapeHtml(super.getTitle());
    }

    @Override
    public String getSynopsis() {
        return StringEscapeUtils.escapeHtml(super.getSynopsis());
    }

    @Override
    public void setAcronym(String acronym) {

        if (getAcronym() != null && !getAcronym().toUpperCase().equals(acronym.toUpperCase()) || getAcronym() == null) {

            if (!acronym.matches("^[A-Za-z0-9\\-]+$")) {
                throw new LdoDException("acronym");
            }

            // cannot change acronym of the archive edition
            if (getAcronym() == null || !getAcronym().equals(VirtualEdition.ARCHIVE_EDITION_ACRONYM)) {

           //     TextProvidesInterface textProvidesInterface = new TextProvidesInterface();

                if (VirtualRequiresInterface.getInstance().acronymExists(acronym)) {
                    throw new LdoDDuplicateAcronymException();
                }

                for (VirtualEdition edition : VirtualModule.getInstance().getVirtualEditionsSet()) {
                    if (edition.getAcronym() != null && acronym.toUpperCase().equals(edition.getAcronym().toUpperCase())) {
                        throw new LdoDDuplicateAcronymException();
                    }
                }

//                EventInterface.getInstance().publish(new EventVirtualEditionUpdate(this.getAcronym(), acronym));
                VirtualEventPublisher virtualEventPublisher = BeanUtil.getBean(VirtualEventPublisher.class);
                virtualEventPublisher.publishEvent(new EventVirtualEditionUpdate(this.getAcronym(), acronym));

                super.setAcronym(acronym);
            }
        }
    }

    @Override
    public String getXmlId() {
        return "ED.VIRT." + getAcronym();
    }

    public VirtualEdition(VirtualModule virtualModule, String participant, String acronym, String title, LocalDate date, Boolean pub,
                          String acronymOfUsed) {
        setVirtualModule4Virtual(virtualModule);
        new Member(this, participant, Member.MemberRole.ADMIN, true);
        setXmlId("ED.VIRT." + acronym);
        setAcronym(acronym);
        setTitle(title);
        setDate(date);
        setPub(pub);
        setTaxonomy(new Taxonomy());
        createSection(Section.DEFAULT, 0);
        if (acronymOfUsed != null && !acronymOfUsed.equals("")) {
            VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEdition(acronymOfUsed);
            if (virtualEdition != null) {
                for (VirtualEditionInter inter : virtualEdition.getIntersSet()) {
                    createVirtualEditionInter(inter, inter.getNumber());
                }
            } else {
               // TextProvidesInterface textProvidesInterface = new TextProvidesInterface();
                List<ScholarInterDto> scholarInterDtos = VirtualRequiresInterface.getInstance().getExpertEditionScholarInterDtoList(acronymOfUsed);
                for (ScholarInterDto scholarInterDto : scholarInterDtos) {
                    createVirtualEditionInter(scholarInterDto, scholarInterDto.getNumber());
                }
            }
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        String acronym = this.getAcronym();

        // delete directory and all its files if it exists
        String path = PropertiesManager.getProperties().getProperty("corpus.dir");
        File directory = new File(path + getExternalId());
        if (directory.exists()) {
            try {
                FileUtils.deleteDirectory(directory);
            } catch (IOException e) {
                // Unable to delete directory
                e.printStackTrace();
            }
        }

        setVirtualModule4Virtual(null);

        getTaxonomy().remove();

        getMemberSet().stream().forEach(m -> m.remove());

        getCriteriaSet().stream().forEach(c -> c.remove());

        for (SelectedBy selectedBy : getSelectedBySet()) {
            selectedBy.remove();
        }

        for (Section section : getSectionsSet()) {
            section.remove();
        }

        for (VirtualEditionInter inter : getAllDepthVirtualEditionInters()) {
            inter.remove();
        }

        deleteDomainObject();
//        EventInterface.getInstance().publish(new Event(Event.EventType.VIRTUAL_EDITION_REMOVE, acronym));
        VirtualEventPublisher virtualEventPublisher = BeanUtil.getBean(VirtualEventPublisher.class);
        virtualEventPublisher.publishEvent(new Event(Event.EventType.VIRTUAL_EDITION_REMOVE, acronym));
    }

    @Override
    public void setPub(Boolean pub) {
        if (!pub) {
            Set<String> participants = getParticipantSet();
            for (SelectedBy user : getSelectedBySet()) {
                if (!participants.contains(user.getUser())) {
                    this.removeSelectedBy(user);
                }
            }
        }
        super.setPub(pub);
    }

    public boolean isVirtualEdition() {
        return true;
    }


//    public List<VirtualEditionInter> getSortedInter4Frag(Fragment fragment) {
//        return getAllDepthVirtualEditionInters().stream().filter(i -> i.getFragmentXmlId().equals(fragment.getXmlId())).sorted().collect(Collectors.toList());
//    }

    public boolean canAddFragInter(VirtualEditionInter virtualEditionInter) {
        return canAddFragInter(virtualEditionInter.getLastUsed());
    }

    public boolean canAddFragInter(String xmlId) {
        VirtualEditionInter virtualEditionInter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(xmlId);
        if (virtualEditionInter != null) {
            return canAddFragInter(virtualEditionInter);
        }
        return canAddFragInter(VirtualRequiresInterface.getInstance().getScholarInterByXmlId(xmlId));
    }

    // determines if the fragment can have more interpretations for this virtual
    // edition, deals with the the case of a fragment having two interpretations
    // for the same expert edition
    public boolean canAddFragInter(ScholarInterDto addInter) {
        String fragmentXmlId = addInter.getFragmentXmlId();

        for (VirtualEditionInter inter : getVirtualEditionInterSetForFragment(fragmentXmlId)) {
            ScholarInterDto usedInter = inter.getLastUsed();
            if (isSameInterpretation(addInter, usedInter)) {
                return false;
            }

            if (atLeastOneIsSourceInterpretation(addInter, usedInter)) {
                return false;
            }

            if (belongToDifferentExpertEditions(addInter, usedInter)) {
                return false;
            }
        }
        return true;
    }

    private boolean belongToDifferentExpertEditions(ScholarInterDto usedAddInter, ScholarInterDto usedInter) {

        return !usedAddInter.getExpertEditionAcronym().
                equals(usedInter.getExpertEditionAcronym());
    }

    private boolean atLeastOneIsSourceInterpretation(ScholarInterDto usedAddInter, ScholarInterDto usedInter) {
        return usedInter.isSourceInter() || usedAddInter.isSourceInter();
    }

    private boolean isSameInterpretation(ScholarInterDto usedAddInter, ScholarInterDto usedInter) {
        return usedAddInter.getXmlId().equals(usedInter.getXmlId());
    }

    public int getMaxFragNumber() {
        int max = 0;
        for (VirtualEditionInter inter : getAllDepthVirtualEditionInters()) {

            max = inter.getNumber() > max ? inter.getNumber() : max;
        }

        return max;
    }

    public Set<VirtualEditionInter> getIntersSet() {
        return new HashSet<>(getAllDepthVirtualEditionInters());
    }

    public Set<VirtualEditionInter> getVirtualEditionInterSetForFragment(String fragmentXmlId) {
        return getAllDepthVirtualEditionInters().stream().filter(virtualEditionInter -> virtualEditionInter.getFragmentXmlId().equals(fragmentXmlId))
                .collect(Collectors.toSet());
    }

    public List<VirtualEditionInter> getSortedInterps() {
        return getIntersSet().stream().map(VirtualEditionInter.class::cast).sorted().collect(Collectors.toList());
    }

    public VirtualEditionInter getFragInterByUrlId(String urlId) {
        return getIntersSet().stream().filter(i -> i.getUrlId().equals(urlId)).findFirst().orElse(null);
    }

    public VirtualEditionInter getFragInterByXmlId(String xmlId) {
        return getIntersSet().stream().filter(i -> i.getXmlId().equals(xmlId)).findFirst().orElse(null);
    }

    public String getReference() {
        return getAcronym();
    }

    public String getShortAcronym() {
        return getAcronym().substring(ACRONYM_PREFIX.length());
    }

    // TODO corrigir o caso dos parâmetros vazios e também o new e o remove
    @Atomic(mode = TxMode.WRITE)
    public void edit(String acronym, String title, String synopsis, boolean pub, boolean openManagement,
                     boolean openVocabulary, boolean openAnnotation, String mediaSource, String beginDate, String endDate,
                     String geoLocation, String frequency) {
        setPub(pub);
        setTitle(title);
        if (synopsis.length() > 1500) {
            setSynopsis(synopsis.substring(0, 1499));
        } else {
            setSynopsis(synopsis);
        }
        setAcronym(acronym);
        getTaxonomy().edit(openManagement, openVocabulary, openAnnotation);

        MediaSource medSource = this.getMediaSource();
        // creates
        if (medSource == null) {
            if (mediaSource.equals("noMediaSource")) {
                // do nothing
            } else if (mediaSource.equals("Twitter")) {
                new MediaSource(this, mediaSource);
            }
        }
        // removes or edits
        else {
            if (mediaSource.equals("noMediaSource")) {
                medSource.remove();
            } else if (mediaSource.equals("Twitter")) {
                medSource.edit(mediaSource);
            }
        }

        TimeWindow timeWindow = this.getTimeWindow();
        LocalDate bDate = null;
        LocalDate eDate = null;
        // creates
        if (timeWindow == null) {
            if (!beginDate.equals("") || !endDate.equals("")) {
                if (!beginDate.equals("")) {
                    bDate = new LocalDate(beginDate);
                }
                if (!endDate.equals("")) {
                    eDate = new LocalDate(endDate);
                }
                new TimeWindow(this, bDate, eDate);
            }
        }
        // removes or edits
        else {
            if (beginDate.equals("") && endDate.equals("")) {
                timeWindow.remove();
            } else {
                if (!beginDate.equals("")) {
                    bDate = new LocalDate(beginDate);
                }
                if (!endDate.equals("")) {
                    eDate = new LocalDate(endDate);
                }
                timeWindow.edit(bDate, eDate);
            }
        }

        // remover o noCountry!! fazer a comparaçao com a String vazia
        GeographicLocation geographicLocation = this.getGeographicLocation();
        // creates
        if (geographicLocation == null) {
            if (geoLocation.equals("")) {
                // do nothing
            } else {
                new GeographicLocation(this, geoLocation);
            }
        }
        // removes or edits
        else {
            if (geoLocation.equals("")) {
                geographicLocation.remove();
            } else {
                geographicLocation.edit(geoLocation);
            }
        }

        Frequency freq = this.getFrequency();
        // creates
        if (freq == null) {
            if (frequency.equals("") || frequency.equals("0")) {
                // do nothing
            } else {
                new Frequency(this, Integer.parseInt(frequency));
            }
        }
        // removes or edits
        else {
            if (frequency.equals("") || frequency.equals("0")) {
                freq.remove();
            } else {
                freq.edit(Integer.parseInt(frequency));
            }
        }

        geographicLocation = this.getGeographicLocation();
        if (geographicLocation != null) {
            logger.debug(geographicLocation.getCountry());
            String[] split = geographicLocation.getCountry().split(",");
            logger.debug("size: " + split.length);
            for (String s : split) {
                logger.debug(s);
            }
        }

    }

    @Atomic(mode = TxMode.WRITE)
    public void updateVirtualEditionInters(List<String> fragIntersXmlIds) {
        // create list of current used xmlIds
        List<String> currentUsedXmlIds = new ArrayList<>();
        for (VirtualEditionInter inter : getAllDepthVirtualEditionInters()) {
            currentUsedXmlIds.add(inter.getUsesXmlId());
        }

        // remove fragments that are not in the list
        for (VirtualEditionInter inter : getAllDepthVirtualEditionInters()) {
            if (!fragIntersXmlIds.contains(inter.getUsesXmlId())) {
                inter.remove();
            }
        }

        // add new virtual edition interpretations
        int number = 0;
        for (String interXmlId : fragIntersXmlIds) {
            if (!currentUsedXmlIds.contains(interXmlId)) {
                ScholarInterDto scholarInterDto = VirtualRequiresInterface.getInstance().getScholarInterByXmlId(interXmlId);
                if (scholarInterDto != null) {
                    createVirtualEditionInter(scholarInterDto, number + 1);
                } else {
                    VirtualEditionInter virtualEditionInter = VirtualModule.getInstance().getVirtualEditionInterByXmlId(interXmlId);
                    if (virtualEditionInter != null) {
                        createVirtualEditionInter(virtualEditionInter, number + 1);
                    } else {
                        throw new LdoDException("the xmlId does not have an associated interpretation in manual virtual edition reordering for xmlId " + interXmlId);
                    }
                }
            }
            number++;
        }

        // redefine the global order
        for (VirtualEditionInter inter : getAllDepthVirtualEditionInters()) {
            String usedXmlId = inter.getUsesXmlId();
            if (fragIntersXmlIds.contains(usedXmlId)) {
                number = fragIntersXmlIds.indexOf(usedXmlId) + 1;
                inter.setNumber(number);
            } else {
                throw new LdoDException("error in manual virtual edition reordering for xmlId " + usedXmlId);
            }

        }
    }

    // Default section
    @Atomic(mode = TxMode.WRITE)
    public VirtualEditionInter createVirtualEditionInter(VirtualEditionInter inter, int number) {
        // logger.debug("createVirtualEditionInter inter:{}, number:{}", inter, number);
        VirtualEditionInter virtualInter = null;

        if (canAddFragInter(inter.getLastUsed())) {
            if (getSectionsSet().isEmpty()) {
                Section section = new Section(this, Section.DEFAULT, 0);
                virtualInter = new VirtualEditionInter(section, inter, number);
                section.addVirtualEditionInter(virtualInter);
                addSections(section);
            } else {
                Section section = getSectionsSet().iterator().next();
                virtualInter = new VirtualEditionInter(section, inter, number);
            }
        }

        return virtualInter;
    }

    // Default section
    @Atomic(mode = TxMode.WRITE)
    public VirtualEditionInter createVirtualEditionInter(ScholarInterDto scholarInterDto, int number) {
        // logger.debug("createVirtualEditionInter inter:{}, number:{}", inter, number);
        VirtualEditionInter virtualInter = null;

        if (canAddFragInter(scholarInterDto)) {
            if (getSectionsSet().isEmpty()) {
                Section section = new Section(this, Section.DEFAULT, 0);
                virtualInter = new VirtualEditionInter(section, scholarInterDto, number);
                section.addVirtualEditionInter(virtualInter);
                addSections(section);
            } else {
                Section section = getSectionsSet().iterator().next();
                virtualInter = new VirtualEditionInter(section, scholarInterDto, number);
            }
        }
        return virtualInter;
    }

    public boolean isPublicOrIsParticipant(String username) {
        return getPub() || getParticipantSet().contains(username);
    }

    public List<VirtualEditionInter> getAllDepthVirtualEditionInters() {
        List<VirtualEditionInter> inters = new ArrayList<>();
        for (Section section : getSectionsSet()) {
            inters.addAll(section.getAllDepthVirtualEditionInterSet());
        }
        Collections.sort(inters);
        return inters;
    }

    @Atomic(mode = TxMode.WRITE)
    public Section createSection(String title, int number) {
        Section section = new Section(this, title, number);
        return section;
    }

    public boolean hasMultipleSections() {
        return getSectionsSet().size() > 1;
    }

    public Section getSection(String title) {
        for (Section section : getSectionsSet()) {
            if (section.getTitle().equals(title)) {
                return section;
            }
        }
        return null;
    }

    public Section createSection(String title) {
        int number = getSectionsSet().size();
        return createSection(title, number);
    }

    public int getSectionDepth() {
        int max = 0;
        for (Section section : getSectionsSet()) {
            int depth = section.getDepth();
            if (max < depth) {
                max = depth;
            }
        }
        return max;
    }

    public List<Section> getSortedSections() {
        List<Section> sortedList = new ArrayList<>(getSectionsSet());
        Collections.sort(sortedList);
        return sortedList;
    }

    @Atomic(mode = TxMode.WRITE)
    public void clearEmptySections() {
        for (Section section : getSectionsSet()) {
            section.clearEmptySections();
        }

        for (Section section : getSectionsSet()) {
            if (section.getAllDepthVirtualEditionInterSet().size() == 0) {
                section.remove();
            }
        }
    }

    public boolean isSelectedBy(String user) {
        return getSelectedBySet().stream().anyMatch(selectedBy -> selectedBy.getUser().equals(user));
    }

    @Atomic(mode = TxMode.WRITE)
    public void addSelectedByUser(String user) {
        if (!isSelectedBy(user)) {
            new SelectedBy(this, user);
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void removeSelectedByUser(String user) {
        getSelectedBySet().stream().filter(selectedBy -> selectedBy.equals(user)).forEach(selectedBy -> selectedBy.remove());
    }

    @Atomic(mode = TxMode.WRITE)
    public void removeMember(String user) {
        getMemberSet().stream().filter(m -> m.getUser().equals(user)).forEach(m -> m.remove());
        removeSelectedByUser(user);
    }

    public Member getMember(String user) {
        return getMemberSet().stream().filter(m -> m.getUser().equals(user)).findFirst().orElse(null);
    }

    @Atomic(mode = TxMode.WRITE)
    public void addMember(String user, Member.MemberRole role, boolean active) {
        if (!getMemberSet().stream().filter(m -> m.getUser().equals(user)).findAny().isPresent()) {
            new Member(this, user, role, active);
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void cancelParticipationSubmission(String user) {
        Member member = getMemberSet().stream().filter(m -> !m.getActive() && m.getUser().equals(user)).findAny()
                .orElse(null);
        if (member != null) {
            member.remove();
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void addApprove(String user) {
        Member member = getMemberSet().stream().filter(m -> !m.getActive() && m.getUser().equals(user)).findAny()
                .orElse(null);
        if (member != null) {
            member.setActive(true);
        }
    }

    @Atomic(mode = TxMode.WRITE)
    public void switchRole(String user) {
        Member member = getMemberSet().stream().filter(m -> m.getUser().equals(user)).findFirst().orElse(null);
        if (member != null) {
            if (member.getRole().equals(Member.MemberRole.ADMIN)) {
                member.setRole(Member.MemberRole.MEMBER);
            } else {
                member.setRole(Member.MemberRole.ADMIN);
            }
        }
    }

    public Set<String> getParticipantSet() {
        return getMemberSet().stream().filter(m -> m.getActive()).map(m -> m.getUser()).collect(Collectors.toSet());
    }

    public List<UserDto> getParticipantList() {
        return getParticipantSet().stream().map(participant -> new UserDto(participant)).sorted(Comparator.comparing(UserDto::getFirstName))
                .collect(Collectors.toList());
    }

    public Set<Member> getActiveMemberSet() {
        return getMemberSet().stream().filter(m -> m.getActive()).collect(Collectors.toSet());
    }

    public Set<String> getAdminSet() {
        return getMemberSet().stream()
                .filter(member -> member.getRole().equals(Member.MemberRole.ADMIN) && member.getActive())
                .map(member -> member.getUser())
                .collect(Collectors.toSet());
    }

    public Set<Member> getAdminMemberSet() {
        return getMemberSet().stream().filter(m -> m.getRole().equals(Member.MemberRole.ADMIN) && m.getActive())
                .collect(Collectors.toSet());
    }

    public Set<UserDto> getPendingSet() {
        return getMemberSet().stream().filter(m -> !m.getActive()).map(m -> new UserDto(m.getUser())).collect(Collectors.toSet());
    }

    public Set<Member> getPendingMemberSet() {
        return getMemberSet().stream().filter(m -> !m.getActive()).collect(Collectors.toSet());
    }

    public boolean canRemoveMember(String actor, String user) {
        Member.MemberRole roleActor = getMemberSet().stream().filter(m -> m.getUser().equals(actor)).map(m -> m.getRole())
                .findFirst().get();

        if (roleActor.equals(Member.MemberRole.ADMIN) && getAdminMemberSet().size() > 1) {
            return true;
        }

        if (roleActor.equals(Member.MemberRole.ADMIN) && getAdminMemberSet().size() == 1 && !actor.equals(user)) {
            return true;
        }

        if (roleActor.equals(Member.MemberRole.MEMBER) && actor.equals(user)) {
            return true;
        }

        return false;
    }

    public boolean canSwitchRole(String actor, String user) {
        Member.MemberRole roleActor = getMemberSet().stream().filter(m -> m.getUser().equals(actor)).map(m -> m.getRole())
                .findAny().get();

        if (roleActor.equals(Member.MemberRole.ADMIN) && getAdminMemberSet().size() > 1) {
            return true;
        }

        if (roleActor.equals(Member.MemberRole.ADMIN) && getAdminMemberSet().size() == 1 && !actor.equals(user)) {
            return true;
        }

        return false;
    }

    public Set<Category> getAllDepthCategories() {
        Set<Category> result = new HashSet<>(getTaxonomy().getCategoriesSet());

        VirtualEdition usedEdition = getUses();
        while (usedEdition != null) {
            result.addAll(usedEdition.getTaxonomy().getCategoriesSet());
            usedEdition = usedEdition.getUses();
        }

        return result;
    }

    public List<Category> getAllDepthSortedCategories() {
        return getAllDepthCategories().stream().sorted(Comparator.comparing(Category::getName))
                .collect(Collectors.toList());
    }

    // Foi alterado por causa das human annotations
    public List<HumanAnnotation> getAnnotationList() {
        return getAllDepthVirtualEditionInters().stream().flatMap(i -> i.getAnnotationSet().stream())
                .filter(HumanAnnotation.class::isInstance).map(HumanAnnotation.class::cast)
                .collect(Collectors.toList());
    }

    public List<String> getAnnotationTextList() {
        return getAnnotationList().stream().filter(a -> a.getText() != null && !a.getText().isEmpty())
                .map(a -> a.getText()).sorted().collect(Collectors.toList());
    }

    public boolean isSAVE() {
        // old version
        // if (!this.getCriteriaSet().isEmpty()) {
        // return true;
        // }
        // return false;

        // new version
        if (this.getMediaSource() != null && !this.getMediaSource().getName().equals("noMediaSource")) {
            return true;
        }
        return false;
    }

    public MediaSource getMediaSource() {
        for (SocialMediaCriteria criteria : this.getCriteriaSet()) {
            if (criteria instanceof MediaSource) {
                return (MediaSource) criteria;
            }
        }
        return null;
    }

    public TimeWindow getTimeWindow() {
        for (SocialMediaCriteria criteria : this.getCriteriaSet()) {
            if (criteria instanceof TimeWindow) {
                return (TimeWindow) criteria;
            }
        }
        return null;
    }

    public GeographicLocation getGeographicLocation() {
        for (SocialMediaCriteria criteria : this.getCriteriaSet()) {
            if (criteria instanceof GeographicLocation) {
                return (GeographicLocation) criteria;
            }
        }
        return null;
    }

    public Frequency getFrequency() {
        for (SocialMediaCriteria criteria : this.getCriteriaSet()) {
            if (criteria instanceof Frequency) {
                return (Frequency) criteria;
            }
        }
        return null;
    }

    public boolean isLdoDEdition() {
        return getAcronym().equals(VirtualEdition.ARCHIVE_EDITION_ACRONYM);
    }


    @Atomic(mode = TxMode.WRITE)
    public void save(List<VirtualEditionInter> virtualEditionInters) {
        Section section = createSection(Section.DEFAULT);
        int i = 0;
        for (VirtualEditionInter virtualEditionInter : virtualEditionInters) {
            section.addVirtualEditionInter(virtualEditionInter, ++i);
        }
        clearEmptySections();
    }
}

import org.apache.commons.lang.StringEscapeUtils;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.dtos.text.SimpleTextDto;


import java.util.List;
import java.util.stream.Collectors;

public class HumanAnnotation extends HumanAnnotation_Base {

    @Override
    public void setText(String text) {
        String escapedText = null;
        if (text == null || text.trim().equals("")) {
            escapedText = null;
        } else {
            escapedText = StringEscapeUtils.escapeHtml(text);
        }
        super.setText(escapedText);
    }

    public HumanAnnotation(VirtualEditionInter inter, SimpleTextDto startText, SimpleTextDto endText, String quote,
                           String text, String user) {
        super.init(inter, quote, text);
        setStartTextId("");
        setEndTextId("");
        if (startText != null && endText != null) {
            setStartTextId(startText.getExternalId());
            setEndTextId(endText.getExternalId());
        }

        setUser(user);
    }

    @Override
    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        setStartTextId(null);
        setEndTextId(null);
        for (Tag tag : getTagSet()) {
            tag.remove();
        }
        super.remove();
    }

    @Atomic(mode = TxMode.WRITE)
    public void update(String text, List<String> tags) {
        setText(text);
        getVirtualEditionInter().updateTags(this, tags);
    }

    public List<Category> getCategories() {
        return getTagSet().stream().map(t -> t.getCategory()).sorted((c1, c2) -> c1.getName().compareTo(c2.getName()))
                .collect(Collectors.toList());
    }

    public static boolean canCreate(VirtualEdition virtualEdition, String user) {
        return virtualEdition.getTaxonomy().canManipulateAnnotation(user);
    }

    public boolean canUpdate(String user) {
        return getVirtualEditionInter().getVirtualEdition().getParticipantSet().contains(user) && getUser().equals(user);
    }

    public boolean canDelete(String user) {
        return getUser().equals(user);
    }


    public boolean existsTag(String tag, VirtualEdition virtualEdition) {
        return getTagSet().stream().anyMatch(t -> t.getCategory().getName().equals(tag)
                && t.getCategory().getTaxonomy().getEdition() == virtualEdition);
    }

    @Override
    public boolean isAwareAnnotation() {
        return false;
    }

    @Override
    public boolean isHumanAnnotation() {
        return true;
    }

}


import cc.mallet.pipe.*;
import cc.mallet.pipe.iterator.FileIterator;
import cc.mallet.topics.ParallelTopicModel;
import cc.mallet.types.Alphabet;
import cc.mallet.types.IDSorter;
import cc.mallet.types.InstanceList;
import org.apache.tomcat.util.http.fileupload.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicDTO;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicInterPercentageDTO;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.TopicListDTO;
import pt.ist.socialsoftware.edition.notification.utils.LdoDException;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.domain.Taxonomy;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEditionInter;


import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class TopicModeler {
    private static final Logger logger = LoggerFactory.getLogger(TopicModeler.class);

    private Pipe pipe;
    private final String corpusPath = PropertiesManager.getProperties().getProperty("corpus.dir");
    private final String corpusFilesPath = PropertiesManager.getProperties().getProperty("corpus.files.dir");
    private final String stopListPath = PropertiesManager.getProperties().getProperty("corpus.stoplist");

    public TopicListDTO generate(String user, VirtualEdition edition, int numTopics, int numWords,
                                 int thresholdCategories, int numIterations) throws IOException {
        // if a corpus is absent
        File directory = new File(this.corpusFilesPath);
        if (!directory.exists()) {
            throw new LdoDException("TopicModeler.generate corpus is empty");
        }

        this.pipe = buildPipe();

        InstanceList instances = readDirectory(edition, new File(this.corpusFilesPath));

        int numInstances = instances.size();

        // there are no fragments
        if (numInstances == 0) {
            throw new LdoDException("TopicModeler.generate corpus is empty");
        }

        // logger.debug(
        // "TopicModeler.generate number of files in corpus {} <> {} number of
        // interpretations in virtual edition",
        // numInstances, edition.getIntersSet().size());
        // if (numInstances != edition.getVirtualEditionInters().size()) {
        // throw new LdoDException("TopicModeler.generate number of files in
        // corpus " + numInstances + " <> "
        // + edition.getIntersSet().size() + " number of interpretations in
        // virtual edition");
        // }

        // Create a model with 100 topics, alpha_t = 0.01, beta_w = 0.01
        // Note that the first parameter is passed as the sum over topics, while
        // the second is the parameter for a single dimension of the Dirichlet
        // prior.
        ParallelTopicModel model = new ParallelTopicModel(numTopics, 1.0, 0.01);

        model.addInstances(instances);

        // Use two parallel samplers, which each look at one half the corpus and
        // combine
        // statistics after every iteration.
        model.setNumThreads(2);

        // For real applications, use 1000 to 2000 iterations)
        model.setNumIterations(numIterations);
        model.estimate();

        // Show the words and topics in the first instance

        // The data alphabet maps word IDs to strings
        Alphabet dataAlphabet = instances.getDataAlphabet();

        return createTopicListDTO(user, edition, model, numTopics, numWords, thresholdCategories, numIterations,
                dataAlphabet, numInstances);

    }

    public Pipe buildPipe() {
        ArrayList<Pipe> pipeList = new ArrayList<>();

        pipeList.add(new Input2CharSequence("UTF-8"));
        pipeList.add(new CharSequence2TokenSequence(Pattern.compile("\\p{L}[\\p{L}\\p{P}]+\\p{L}")));
        pipeList.add(new TokenSequenceLowercase());
        pipeList.add(new TokenSequenceRemoveStopwords(new File(this.stopListPath), "UTF-8", false, false, false));
        // pipeList.add(new TokenSequenceRemoveStopwords(false, false));
        pipeList.add(new TokenSequence2FeatureSequence());

        return new SerialPipes(pipeList);
    }

    public InstanceList readDirectory(VirtualEdition edition, File directory) {
        return readDirectories(edition, new File[]{directory});
    }

    public InstanceList readDirectories(VirtualEdition edition, File[] directories) {
        // Construct a file iterator, starting with the
        // specified directories, and recursing through subdirectories.
        // The second argument specifies a FileFilter to use to select
        // files within a directory.
        // The third argument is a Pattern that is applied to the
        // filename to produce a class label. In this case, I've
        // asked it to use the last directory name in the path.

        FileIterator iterator = new FileIterator(directories, new EditionFilter(edition), FileIterator.LAST_DIRECTORY);

        // Construct a new instance list, passing it the pipe
        // we want to use to process instances.
        InstanceList instances = new InstanceList(this.pipe);

        // Now process each instance provided by the iterator.
        instances.addThruPipe(iterator);

        return instances;
    }

    private TopicListDTO createTopicListDTO(String user, VirtualEdition edition, ParallelTopicModel model,
                                            int numTopics, int numWords, int thresholdCategories, int numIterations, Alphabet dataAlphabet,
                                            int numInstances) {

        TopicListDTO topics = new TopicListDTO();
        topics.setUsername(user);

        Taxonomy taxonomy = edition.getTaxonomy();

        topics.setTaxonomyExternalId(taxonomy.getExternalId());

        // Get an array of sorted sets of word ID/count pairs
        ArrayList<TreeSet<IDSorter>> topicSortedWords = model.getSortedWords();

        topics.setTopics(new ArrayList<>());

        // create a category for each topic
        for (int position = 0; position < numTopics; position++) {
            Iterator<IDSorter> iterator = topicSortedWords.get(position).iterator();

            TopicDTO topic = new TopicDTO();
            topic.setInters(new ArrayList<>());

            // associate the words for each category
            int rank = 0;
            String wordName = "";
            while (iterator.hasNext() && rank < numWords) {
                IDSorter idCountPair = iterator.next();
                String word = (String) dataAlphabet.lookupObject(idCountPair.getID());
                wordName = wordName.equals("") ? word : wordName + " " + word;

                rank++;
            }

            while ((taxonomy.getCategory(wordName) != null) || existTopic(topics.getTopics(), wordName)) {
                wordName = wordName + "_DUP";
            }

            topic.setName(wordName);
            topics.getTopics().add(topic);

            assert (topics.getTopics().get(position) == topic);
        }

        // associate categories with fragment interpretations

        for (int instance = 0; instance < numInstances; instance++) {

            String fileName = model.getData().get(instance).instance.getName().toString();
            String[] subs = fileName.split("[/\\.]");
            String externalId = subs[subs.length - 2];
            VirtualEditionInter fragInter = null;
            for (VirtualEditionInter virtualEditionInter : edition.getAllDepthVirtualEditionInters()) {
                if (VirtualRequiresInterface.getInstance().getRepresentativeSourceInterExternalId(virtualEditionInter.getFragmentXmlId()).equals(externalId)) {
                    fragInter = virtualEditionInter;
                    break;
                }
            }

            // Estimate the topic distribution for each instance,
            // given the current Gibbs state.
            double[] topicDistribution = model.getTopicProbabilities(instance);

            for (int position = 0; position < numTopics; position++) {
                BigDecimal bd = new BigDecimal(topicDistribution[position]);
                bd = bd.setScale(2, RoundingMode.HALF_UP);
                int percentage = (int) (bd.doubleValue() * 100);
                if (percentage >= thresholdCategories) {
                    TopicInterPercentageDTO interToTopic = new TopicInterPercentageDTO();
                    interToTopic.setExternalId(fragInter.getExternalId());
                    interToTopic.setTitle(fragInter.getTitle());
                    interToTopic.setPercentage(percentage);

                    TopicDTO topic = topics.getTopics().get(position);
                    topic.getInters().add(interToTopic);
                }
            }
        }

        // remove empty topics and topics without interpretations
        topics.getTopics().removeAll(topics.getTopics().stream().filter(
                t -> t.getName() == null || t.getName().equals("") || t.getInters() == null || t.getInters().isEmpty())
                .collect(Collectors.toList()));

        // sort topics
        List<TopicDTO> sortedList = topics.getTopics().stream().sorted((t1, t2) -> t1.getName().compareTo(t2.getName()))
                .collect(Collectors.toList());
        topics.setTopics(sortedList);

        // sort interpretations
        for (TopicDTO topic : sortedList) {
            List<TopicInterPercentageDTO> sortedFrags = topic.getInters().stream()
                    .sorted((i1, i2) -> i2.getPercentage() - i1.getPercentage()).collect(Collectors.toList());
            topic.setInters(sortedFrags);
        }

        return topics;
    }

    private boolean existTopic(List<TopicDTO> topics, String wordName) {
        return topics.stream().filter(t -> t.getName().equals(wordName)).findAny().isPresent();
    }

    public void deleteFile(String externalId) {
        if (Files.exists(Paths.get(this.corpusFilesPath + externalId + ".txt"))) {
            try {
                Files.delete(Paths.get(this.corpusFilesPath + externalId + ".txt"));
            } catch (IOException e) {
                throw new LdoDException(
                        "TopicModeler.deleteFile cannot delete file " + this.corpusFilesPath + externalId + ".txt");
            }
        }
    }

    public void cleanDirectory() {
        try {
            FileUtils.cleanDirectory(new File(this.corpusFilesPath));
        } catch (IOException e) {
            throw new LdoDException("TopicModeler.cleanDirectory cannot delete directory " + this.corpusFilesPath);
        }
    }

    /**
     * This class illustrates how to build a simple file filter
     */
    class EditionFilter implements FileFilter {
        private final Set<String> filenames = new HashSet<>();



        public EditionFilter(VirtualEdition edition) {
            for (VirtualEditionInter virtualEditionInter : edition.getAllDepthVirtualEditionInters()) {
                this.filenames.add(VirtualRequiresInterface.getInstance().getRepresentativeSourceInterExternalId(virtualEditionInter.getFragmentXmlId()) + ".txt");
            }
        }

        /**
         * Note that {@ref FileIterator} will only call this filter if the file
         * is not a directory, so we do not need to test that it is a file.
         */
        @Override
        public boolean accept(File file) {
            return this.filenames.contains(file.getName());
        }
    }

}



import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;


import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class CorpusGenerator {



    public void generate(FragmentDto fragment) throws FileNotFoundException, IOException {
        generateCorpus(fragment);
        generateInters(fragment);
    }


    public void generateCorpus(FragmentDto fragment) throws FileNotFoundException, IOException {
        String corpusFilesPath = PropertiesManager.getProperties().getProperty("corpus.files.dir");
        File corpusDirectory = new File(corpusFilesPath);

        // use the representative interpretation for corpus
        ScholarInterDto sourceInter = fragment.getSortedSourceInter().get(fragment.getSortedSourceInter().size() - 1);

        File file = new File(corpusDirectory, sourceInter.getExternalId() + ".txt");

        // delete file if it already exists, for a clean generation
        if (file.exists()) {
            file.delete();
        }

        String transcription = VirtualRequiresInterface.getInstance().getWriteFromPlainTextFragmentWriter(sourceInter.getXmlId());

        file = new File(corpusDirectory, sourceInter.getExternalId() + ".txt");
        try (FileOutputStream out = new FileOutputStream(file)) {
            out.write(transcription.getBytes());
        }
    }


    public void generateInters(FragmentDto fragment) throws FileNotFoundException, IOException {
        String intersFilesPath = PropertiesManager.getProperties().getProperty("inters.dir");
        File intersDirectory = new File(intersFilesPath);

        for (ScholarInterDto interDto : fragment.getEmbeddedScholarInterDtos()) {
            File file = new File(intersDirectory, interDto.getExternalId() + ".txt");

            // delete file if it already exists, for a clean generation
            if (file.exists()) {
                file.delete();
            }

            String transcription = VirtualRequiresInterface.getInstance().getWriteFromPlainTextFragmentWriter(interDto.getXmlId());

            file = new File(intersDirectory, interDto.getExternalId() + ".txt");
            try (FileOutputStream out = new FileOutputStream(file)) {
                out.write(transcription.getBytes());
            }
        }

    }
}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filters;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.domain.*;
import pt.ist.socialsoftware.edition.virtual.utils.RangeJson;


import java.io.ByteArrayInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

public class VirtualEditionFragmentsTEIImport {
    private static final Logger logger = LoggerFactory.getLogger(VirtualEditionFragmentsTEIImport.class);

    private static Map<String, ScholarInterDto> scholarInterMap = new HashMap<>();

//    private final TextProvidesInterface textProvidesInterface = new TextProvidesInterface();

    public static final String SOURCE = "source";

    private VirtualModule virtualModule = null;
    private Namespace namespace = null;

    public String importFragmentFromTEI(InputStream inputStream) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        Document doc;
        try {
            doc = builder.build(inputStream);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        return processImport(doc);
    }

    public void importFragmentFromTEI(String fragmentTEI) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        InputStream stream = new ByteArrayInputStream(fragmentTEI.getBytes());

        importFragmentFromTEI(stream);
    }

    @Atomic(mode = TxMode.WRITE)
    private String processImport(Document doc) {

        this.virtualModule = VirtualModule.getInstance();
        this.namespace = doc.getRootElement().getNamespace();


        FragmentDto fragment = getFragment(doc);

       logger.debug("IMPORT FRAGMENT {}", fragment.getXmlId());

        // IMPORT THEM FROM THE FILES IN DISK
        //importFragmentCitations(doc, fragment);

        Map<String, VirtualEditionInter> virtualEditionInterMap = importWitnesses(doc, fragment);

        importTextClasses(doc, virtualEditionInterMap);

        return fragment.getXmlId();
    }

    private Map<String, VirtualEditionInter> importWitnesses(Document doc, FragmentDto fragment) {
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:witness", Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));
        List<Element> wits = new ArrayList<>(xp.evaluate(doc));

        Map<String, VirtualEditionInter> createdInters = new HashMap<>();

        while (!wits.isEmpty()) {
            Element wit = wits.remove(0);

            String sourceXmlId = wit.getAttributeValue(SOURCE).substring(1);
            System.out.println(sourceXmlId);

            String interXmlId = wit.getAttributeValue("id", Namespace.XML_NAMESPACE);
            String editionAcronym = interXmlId.substring(interXmlId.lastIndexOf("VIRT.") + "VIRT.".length(),
                    interXmlId.lastIndexOf('.'));
            VirtualEdition virtualEdition = this.virtualModule.getVirtualEdition(editionAcronym);

//            ScholarInterDto scholarInter = fragment.getScholarInterByXmlId(sourceXmlId);
            ScholarInterDto scholarInter = VirtualRequiresInterface.getInstance().getScholarInterByXmlId(sourceXmlId);

            VirtualEditionInter virtualEditionInter = createdInters.get(sourceXmlId);

            if (scholarInter == null && virtualEditionInter == null) {
                logger.debug("source xmlId was not created yet: {}", sourceXmlId);
                wits.add(wit);
            }

            if (scholarInter != null) {
//                VirtualEditionInter created = virtualEdition.createVirtualEditionInter(new ScholarInterDto(sourceXmlId),
//                        Integer.parseInt(wit.getChild("num", this.namespace).getAttributeValue("value")));
                VirtualEditionInter created = virtualEdition.createVirtualEditionInter(scholarInter,
                        Integer.parseInt(wit.getChild("num", this.namespace).getAttributeValue("value")));
                if (created == null) {
                    created = virtualEdition.getAllDepthVirtualEditionInters().stream()
                            .filter(virtualEditionInter1 -> virtualEditionInter1.getFragmentXmlId().equals(fragment.getXmlId()))
                            .findAny()
                            .orElse(null);
                }
                createdInters.put(interXmlId, created);
                logger.debug("scholarInter != null id: {}, source: {}, created: {}", interXmlId, sourceXmlId, created);
                logger.debug("virtual edition inter source : {}", created.getXmlId());
            }

            if (virtualEditionInter != null) {
                VirtualEditionInter created = virtualEdition.createVirtualEditionInter(virtualEditionInter,
                        Integer.parseInt(wit.getChild("num", this.namespace).getAttributeValue("value")));
                createdInters.put(interXmlId, created);
                logger.debug("scholarInter == null id: {}, source: {}, created: {}", interXmlId, sourceXmlId, created);

                if (created != null) logger.debug("virtual edition inter source : {}", created.getXmlId());
            }

        }

        return createdInters;
    }

    private void importTextClasses(Document doc, Map<String, VirtualEditionInter> virtualEditionInterMap) {
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:textClass", Filters.element(), null,
                Namespace.getNamespace("def", this.namespace.getURI()));

        for (Element textClass : xp.evaluate(doc)) {
            VirtualEditionInter inter = virtualEditionInterMap.get(textClass.getAttributeValue(SOURCE).substring(1));

            for (Element catRef : textClass.getChildren("catRef", this.namespace)) {
                    importTag(catRef, inter);
            }

            for (Element note : textClass.getChildren("note", this.namespace)) {
                    importAnnotation(note, inter);
            }

            //TODO Address game import from texts
            //importClassificationGames(textClass, inter);
        }
    }


//    private void importFragmentCitations(Document doc, Fragment fragment) {
//        XPathFactory xpfac = XPathFactory.instance();
//        XPathExpression<Element> xp = xpfac.compile("//def:citation", Filters.element(), null,
//                Namespace.getNamespace("def", this.namespace.getURI()));
//        for (Element citation : xp.evaluate(doc)) {
//            if (citation.getAttributeValue("type").equals("twitter")) {
//                String sourceLink = citation.getAttributeValue("sourceLink");
//                String date = citation.getAttributeValue("date");
//
//                Element fragTextElement = citation.getChild("fragText", this.namespace);
//                String fragText = fragTextElement.getTextModule(); // trim() ?
//
//                Element tweetTextElement = citation.getChild("tweetText", this.namespace);
//                String tweetText = tweetTextElement.getTextModule(); // trim() ?
//
//                long tweetID = Long.parseLong(citation.getAttributeValue("tweetId"));
//                String location = citation.getAttributeValue("location");
//                String country = citation.getAttributeValue("country");
//                String username = citation.getAttributeValue("username");
//                String userProfileURL = citation.getAttributeValue("userProfileURL");
//                String userImageURL = citation.getAttributeValue("userImageURL");
//
//                TwitterCitation twitterCitation = new TwitterCitation(fragment, sourceLink, date, fragText, tweetText,
//                        tweetID, location, country, username, userProfileURL, userImageURL);
//
//                // TODO: ciclo for que percorre todos os tweets da nova tag criada na citation e
//                // faz tweet.setTwitterCitation()
//                setTwitterCitation(citation, twitterCitation);
//
//                // TODO suggestion: fazer aqui o import dos info ranges visto que são elementos
//                // criados dentro de cada citation element
//                importInfoRanges(fragment, citation, twitterCitation);
//            }
//
//        }
//
//    }

//    private void importInfoRanges(Fragment fragment, Element citation, TwitterCitation twitterCitation) {
//        for (Element infoRangeElement : citation.getChild("infoRangesList", this.namespace).getChildren()) {
//            String start = infoRangeElement.getAttributeValue("start");
//            int startOffset = Integer.parseInt(infoRangeElement.getAttributeValue("startOffset"));
//            String end = infoRangeElement.getAttributeValue("end");
//            int endOffset = Integer.parseInt(infoRangeElement.getAttributeValue("endOffset"));
//
//            Element quoteElement = infoRangeElement.getChild("quote", this.namespace);
//            String quote = quoteElement.getTextModule(); // trim() ?
//
//            Element textElement = infoRangeElement.getChild("text", this.namespace);
//            String text = textElement.getTextModule(); // trim() ?
//
//            FragInter fragInter = fragment.getFragInterByXmlId(infoRangeElement.getAttributeValue("fragInterXmlId"));
//
//            new InfoRange(twitterCitation, fragInter, start, startOffset, end, endOffset, quote, text);
//        }
//    }

//    private void setTwitterCitation(Element citation, TwitterCitation twitterCitation) {
//        for (Element tweetElement : citation.getChild("tweets", this.namespace).getChildren()) {
//            Tweet tweet = VirtualModule.getInstance()
//                    .getTweetByTweetID(Long.parseLong(tweetElement.getAttributeValue("tweetId")));
//            tweet.setCitation(twitterCitation);
//        }
//    }

    private void importTag(Element catRef, VirtualEditionInter inter) {
        String username = catRef.getAttributeValue("resp").substring(1);
        String tag = catRef.getAttributeValue("target").substring(1);

        inter.getVirtualEdition().getTaxonomy().createTag(inter, tag, null, username);
    }

    // TODO: else if aware - done
    // novo import annotation
    private void importAnnotation(Element note, VirtualEditionInter virtualEditionInter) {
        String text = note.getText().trim();
        Element quoteElement = note.getChild("quote", this.namespace);
        String from = quoteElement.getAttributeValue("from");
        String to = quoteElement.getAttributeValue("to");
        String fromOffset = quoteElement.getAttributeValue("fromOffset");
        String toOffset = quoteElement.getAttributeValue("toOffset");
        String quote = quoteElement.getText().trim();

        RangeJson range = new RangeJson();
        range.setStart(from);
        range.setStartOffset(Integer.parseInt(fromOffset));
        range.setEnd(to);
        range.setEndOffset(Integer.parseInt(toOffset));
        List<RangeJson> rangeList = new ArrayList<>();
        rangeList.add(range);

        if (note.getAttribute("type") != null && note.getAttributeValue("type").equals("human")) {
            logger.debug("resp {}", note.getAttributeValue("resp"));
            String username = note.getAttributeValue("resp").substring(1);
            List<String> tagList = new ArrayList<>();
            for (Element catRef : note.getChildren("catRef", this.namespace)) {
                String tag = catRef.getAttributeValue("target").substring(1);
                tagList.add(tag);
            }
            virtualEditionInter.createHumanAnnotation(quote, text, username, rangeList, tagList);
        }
        //else if (note.getAttributeValue("type").equals("aware")) {
        // do nothing
//            long tweetID = Long.parseLong(note.getAttributeValue("citationId"));
//            Citation citation = inter.getFragment().getCitationById(tweetID);
//            inter.createAwareAnnotation(quote, text, citation, rangeList);
//        }
    }

    // original code
    // private void importAnnotation(Element note, VirtualEditionInter inter) {
    // String username = note.getAttributeValue("resp").substring(1);
    // String text = StringEscapeUtils.escapeHtml(note.getTextModule().trim());
    // Element quoteElement = note.getChild("quote", this.namespace);
    // String from = quoteElement.getAttributeValue("from");
    // String to = quoteElement.getAttributeValue("to");
    // String fromOffset = quoteElement.getAttributeValue("fromOffset");
    // String toOffset = quoteElement.getAttributeValue("toOffset");
    // String quote = quoteElement.getTextModule().trim();
    //
    // RangeJson range = new RangeJson();
    // range.setStart(from);
    // range.setStartOffset(Integer.parseInt(fromOffset));
    // range.setEnd(to);
    // range.setEndOffset(Integer.parseInt(toOffset));
    //
    // List<String> tagList = new ArrayList<>();
    // for (Element catRef : note.getChildren("catRef", this.namespace)) {
    // String tag = catRef.getAttributeValue("target").substring(1);
    // tagList.add(tag);
    // }
    // List<RangeJson> rangeList = new ArrayList<>();
    // rangeList.add(range);
    // inter.createAnnotation(quote, text, this.virtualModule.getUser(username), rangeList,
    // tagList);
    // }

    private FragmentDto getFragment(Document doc) {
        Namespace namespace = doc.getRootElement().getNamespace();
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:TEI", Filters.element(), null,
                Namespace.getNamespace("def", namespace.getURI()));
        String xmlId = xp.evaluate(doc).get(0).getAttributeValue("id", Namespace.XML_NAMESPACE);

        return VirtualRequiresInterface.getInstance().getFragmentByXmlId(xmlId);

        //return TextModule.getInstance().getFragmentByXmlId(xmlId);
    }




////    //TODO : these class game related functions should be moved to their own importer in the game module
//    private void importClassificationGames(Element textClass, VirtualEditionInter inter) {
//        if (textClass.getChild("classificationGameList", this.namespace) == null) {
//            return;
//        }
//
//        for (Element gameElement : textClass.getChild("classificationGameList", this.namespace).getChildren()) {
//            ClassificationGame.ClassificationGameState state = ClassificationGame.ClassificationGameState
//                    .valueOf(gameElement.getAttributeValue("state"));
//            String description = gameElement.getAttributeValue("description");
//            DateTime dateTime = new DateTime(DateTime.parse(gameElement.getAttributeValue("dateTime")));
//            boolean sync = Boolean.parseBoolean(gameElement.getAttributeValue("sync"));
//            String responsible = gameElement.getAttributeValue("responsible");
//            String winner = gameElement.getAttributeValue("winningUser");
//
//            ClassificationGame game = new ClassificationGame(new VirtualEditionDto(inter.getVirtualEdition()), description, dateTime,
//                    new VirtualEditionInterDto(inter), responsible);
//
//            game.setState(state);
//            game.setSync(sync);
//
//            if (winner != null && winner.trim().length() != 0) {
//                logger.debug("winner: {}, tag: {}", winner, gameElement.getAttributeValue("tag"));
//                Tag tag = inter.getTagSet().stream()
//                        .filter(t -> t.getCategory().getName().equals(gameElement.getAttributeValue("tag"))
//                                && t.getContributor().equals(winner))
//                        .findFirst().orElse(null);
//                game.setTagId(tag != null ? tag.getExternalId() : null);
//            }
//            importClassificationGameParticipants(gameElement, game);
//            importClassificationGameRounds(gameElement, game);
//        }
//    }
//
//    private void importClassificationGameRounds(Element gameElement, ClassificationGame game) {
//        for (Element roundElement : gameElement.getChild("classificationGameRoundList", this.namespace).getChildren()) {
//            String username = roundElement.getAttributeValue("username");
//
//            int paragraphNumber = Integer.parseInt(roundElement.getAttributeValue("paragraphNumber"));
//            int roundNumber = Integer.parseInt(roundElement.getAttributeValue("roundNumber"));
//            String tag = roundElement.getAttributeValue("tag");
//            double vote = Double.parseDouble(roundElement.getAttributeValue("vote"));
//            DateTime dateTime = new DateTime(DateTime.parse(roundElement.getAttributeValue("dateTime")));
//
//            ClassificationGameRound gameRound = new ClassificationGameRound();
//            gameRound.setNumber(paragraphNumber);
//            gameRound.setRound(roundNumber);
//            gameRound.setTag(tag);
//            gameRound.setVote(vote);
//            gameRound.setTime(dateTime);
//
//            ClassificationGameParticipant participant = game.getClassificationGameParticipantSet().stream()
//                    .filter(p -> p.getPlayer().getUser().equals(username)).findFirst().get();
//            gameRound.setClassificationGameParticipant(participant);
//        }
//
//    }

//    private void importClassificationGameParticipants(Element element, ClassificationGame game) {
//        for (Element participantElement : element.getChild("classificationGameParticipantList", this.namespace)
//                .getChildren()) {
//            String username = participantElement.getAttributeValue("username");
//            boolean winner = Boolean.parseBoolean(participantElement.getAttributeValue("winner"));
//            double score = Double.parseDouble(participantElement.getAttributeValue("score"));
//
//            ClassificationGameParticipant participant = new ClassificationGameParticipant(game, username);
//            participant.setWinner(winner);
//            participant.setScore(score);
//        }
//    }


//    public void LoadFragmentsCorpus() {
//        this.virtualModule = VirtualModule.getInstance();
//        TextProvidesInterface textProvidesInterface = new TextProvidesInterface();
//
//        for (FragmentDto fragmentDto: textProvidesInterface.getFragmentDtoSet()) {
//            Fragment fragment = TextModule.getInstance().getFragmentByXmlId(fragmentDto.getXmlId());
//            // generate corpus in corpus.dir
//            CorpusGenerator generator = new CorpusGenerator();
//            try {
//                generator.generate(fragment);
//            } catch (FileNotFoundException e1) {
//                throw new LdoDLoadException(
//                        "LoadTEIFragments.loadFragment erro FileNotFoundException a gerar corpus do fragmento "
//                                + fragment.getXmlId() + e1.getMessage());
//            } catch (IOException e1) {
//                throw new LdoDLoadException("LoadTEIFragments.loadFragment erro IOException a gerar corpus do fragmento "
//                        + fragment.getXmlId());
//            }
//
//            // generate index in indexer.dir
//            for (ScholarInter inter : fragment.getScholarInterSet().stream().map(ScholarInter.class::cast).collect(Collectors.toSet())) {
//                try {
//                    Indexer indexer = Indexer.getIndexer();
//                    indexer.addDocument(inter);
//
//                } catch (FileNotFoundException e) {
//                    throw new LdoDLoadException(
//                            "LoadTEIFragments.loadFragment erro FileNotFoundException a gerar index da interpretação "
//                                    + inter.getXmlId());
//                } catch (IOException e) {
//                    throw new LdoDLoadException(
//                            "LoadTEIFragments.loadFragment erro IOException a gerar index da interpretação "
//                                    + inter.getXmlId());
//                }
//            }
//
//            VirtualEdition archiveEdition = this.virtualModule.getArchiveEdition();
//            // if the representative fragment interpretation is not in
//            // the archive edition we have to add it
//            if (archiveEdition != null
//                    && !archiveEdition.getIntersSet().contains(fragment.getRepresentativeSourceInter())) {
//                logger.debug("loadFragment ldod-edition-size:{}", archiveEdition.getAllDepthVirtualEditionInters().size());
//                archiveEdition.createVirtualEditionInter(new ScholarInterDto(fragment.getRepresentativeSourceInter().getXmlId()),
//                        archiveEdition.getMaxFragNumber() + 1);
//            }
//        }
//    }

}


import org.apache.commons.lang.StringEscapeUtils;
import org.jdom2.Attribute;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.domain.*;


public class VirtualEditionFragmentsTEIExport {
    Namespace xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");

    Document jdomDoc = null;

    @Atomic
    public void export() {



        for (FragmentDto fragmentDto : VirtualRequiresInterface.getInstance().getFragmentDtoSet()) {
            exportFragment(fragmentDto.getXmlId());
        }
    }

    @Atomic
    public String exportFragment(String fragmentXmlId) {
        this.jdomDoc = new Document();
        Element rootElement = new Element("teiCorpus");
        rootElement.setNamespace(this.xmlns);
        this.jdomDoc.setRootElement(rootElement);
        Element tei = new Element("TEI", this.xmlns);
        Attribute id = new Attribute("id", fragmentXmlId, Namespace.XML_NAMESPACE);
        tei.setAttribute(id);
        rootElement.addContent(tei);
        Element teiHeader = new Element("teiHeader", this.xmlns);
        teiHeader.setAttribute("type", "text");
        tei.addContent(teiHeader);
        Element fileDesc = new Element("fileDesc", this.xmlns);
        teiHeader.addContent(fileDesc);
        Element sourceDesc = new Element("sourceDesc", this.xmlns);
        fileDesc.addContent(sourceDesc);

        Element witnesses = new Element("listWit", this.xmlns);
        id = new Attribute("id", fragmentXmlId + ".WIT.ED.VIRT", Namespace.XML_NAMESPACE);
        witnesses.setAttribute(id);
        sourceDesc.addContent(witnesses);
        for (VirtualEditionInter virtualEditionInter : VirtualModule.getInstance().getVirtualEditionInterSet(fragmentXmlId)) {
            exportVirtualEditionInterWitness(witnesses, virtualEditionInter);
        }

        Element profileDesc = new Element("profileDesc", this.xmlns);
        teiHeader.addContent(profileDesc);
        for (VirtualEditionInter virtualEditionInter : VirtualModule.getInstance().getVirtualEditionInterSet(fragmentXmlId)) {
            Element textClass = new Element("textClass", this.xmlns);
            textClass.setAttribute("source", "#" + virtualEditionInter.getXmlId());
            profileDesc.addContent(textClass);

            exportVirtualEditionInterTags(textClass, virtualEditionInter);
            exportVirtualEditionInterAnnotations(textClass, virtualEditionInter);
            //exportClassificationGames(textClass, virtualEditionInter);
        }

        // NOT NECESSARY THEY CAN BE LOADED FROM THE FILES
        //exportFragmentCitations(teiHeader, fragment);

        XMLOutputter xml = new XMLOutputter();
        xml.setFormat(Format.getPrettyFormat());
        // System.out.println(xml.outputString(rootElement));

        return xml.outputString(rootElement);
    }

    private void exportVirtualEditionInterWitness(Element witnesses, VirtualEditionInter virtualEditionInter) {
        Element witness = new Element("witness", this.xmlns);
        Attribute id = new Attribute("id", virtualEditionInter.getXmlId(), Namespace.XML_NAMESPACE);
        witness.setAttribute(id);
        witness.setAttribute("source", "#" + (virtualEditionInter.getUses() != null ? virtualEditionInter.getUses().getXmlId() : virtualEditionInter.getUsesScholarInterId()));
        witnesses.addContent(witness);

        Element number = new Element("num", this.xmlns);
        number.setAttribute("value", Integer.toString(virtualEditionInter.getNumber()));
        witness.addContent(number);
    }

    private void exportVirtualEditionInterTags(Element textClass, VirtualEditionInter virtualEditionInter) {
        for (Tag tag : virtualEditionInter.getTagSet()) {
            if (tag.getAnnotation() == null) {
                Element catRef = new Element("catRef", this.xmlns);
                catRef.setAttribute("scheme", "#" + virtualEditionInter.getEdition().getXmlId());
                catRef.setAttribute("target", "#" + tag.getCategory().getName());
                catRef.setAttribute("resp", "#" + tag.getContributor());
                textClass.addContent(catRef);
            }
        }
    }

//	private void exportFragmentCitations(Element teiHeader, Fragment fragment) {
//		Element citationList = new Element("citationList", this.xmlns);
//		teiHeader.addContent(citationList);
//		for (Citation citation : fragment.getCitationSet()) {
//			Element citationElement = new Element("citation", this.xmlns);
//			citationList.addContent(citationElement);
//
//			exportCitation(citationElement, citation);
//			if (citation instanceof TwitterCitation) {
//				exportTwitterCitation(citationElement, (TwitterCitation) citation);
//			}
//			exportInfoRanges(citationElement, citation);
//		}
//	}

//	private void exportInfoRanges(Element citationElement, Citation citation) {
//		Element infoRangesList = new Element("infoRangesList", this.xmlns);
//		citationElement.addContent(infoRangesList);
//
//		for (InfoRange infoRange : citation.getInfoRangeSet()) {
//			Element infoRangeElement = new Element("infoRange", this.xmlns);
//			infoRangesList.addContent(infoRangeElement);
//
//			infoRangeElement.setAttribute("start", infoRange.getStart());
//			infoRangeElement.setAttribute("startOffset", Integer.toString(infoRange.getStartOffset()));
//			infoRangeElement.setAttribute("end", infoRange.getEnd());
//			infoRangeElement.setAttribute("endOffset", Integer.toString(infoRange.getEndOffset()));
//
//			Element quoteElement = new Element("quote", this.xmlns);
//			quoteElement.addContent(infoRange.getQuote());
//			infoRangeElement.addContent(quoteElement);
//
//			Element textElement = new Element("text", this.xmlns);
//			textElement.addContent(infoRange.getTextModule());
//			infoRangeElement.addContent(textElement);
//
//			// discutir também utilidade destes atributos
//			// fragInterXmlId seria necessário para descobrir o fragInter ao importar
//			infoRangeElement.setAttribute("fragInterXmlId", infoRange.getFragInterDto().getXmlId());
//			infoRangeElement.setAttribute("citationId", Long.toString(infoRange.getCitation().getId()));
//		}
//	}

//	protected void exportCitation(Element citationElement, Citation citation) {
//		citationElement.setAttribute("sourceLink", citation.getSourceLink());
//		citationElement.setAttribute("date", citation.getDate());
//		// citationElement.setAttribute("fragText", citation.getFragText());
//
//		Element fragText = new Element("fragText", this.xmlns);
//		fragText.addContent(citation.getFragText());
//		citationElement.addContent(fragText);
//
//		// old code
//		// Element citationElement = new Element("citation", this.xmlns);
//		// citationList.addContent(citationElement);
//	}
//
//	protected void exportTwitterCitation(Element citationElement, TwitterCitation citation) {
//		citationElement.setAttribute("type", "twitter");
//
//		Element tweetText = new Element("tweetText", this.xmlns);
//		tweetText.addContent(new CDATA(citation.getTweetText()));
//		citationElement.addContent(tweetText);
//
//		citationElement.setAttribute("tweetId", Long.toString(citation.getTweetID()));
//		citationElement.setAttribute("location", citation.getLocation());
//		citationElement.setAttribute("country", citation.getCountry());
//		citationElement.setAttribute("username", citation.getUsername());
//		citationElement.setAttribute("userProfileURL", citation.getUserProfileURL());
//		citationElement.setAttribute("userImageURL", citation.getUserProfileURL());
//
//		Element tweets = new Element("tweets", this.xmlns);
//		citationElement.addContent(tweets);
//
//		for (Tweet tweet : citation.getTweetSet()) {
//			Element tweetElement = new Element("tweet", this.xmlns);
//			tweets.addContent(tweetElement);
//
//			// acho q o set é este em vez do q fiz inicialmente com o if e else
//			tweetElement.setAttribute("tweetId", Long.toString(tweet.getTweetID()));
//
//			// if (tweet.getIsRetweet()) {
//			// tweetElement.setAttribute("tweetId",
//			// Long.toString(tweet.getOriginalTweetID()));
//			// } else {
//			// tweetElement.setAttribute("tweetId", Long.toString(tweet.getTweetID()));
//			// }
//		}
//	}

    private void exportVirtualEditionInterAnnotations(Element textClass, VirtualEditionInter virtualEditionInter) {
        for (Annotation annotation : virtualEditionInter.getAnnotationSet()) {
            if (annotation instanceof HumanAnnotation) {
                Element note = new Element("note", this.xmlns);

                note.setText(StringEscapeUtils.unescapeHtml(annotation.getText()));
                textClass.addContent(note);

                exportAnnotationRanges(annotation, note);

                note.setAttribute("resp", "#" + annotation.getUser());
                note.setAttribute("type", "human");
                exportAnnotationCategories(virtualEditionInter, (HumanAnnotation) annotation, note);
            } else if (annotation instanceof AwareAnnotation) {
//                note.setAttribute("type", "aware");
//                note.setAttribute("citationId", Long.toString(((AwareAnnotation) annotation).getCitation().getId()));
            }
        }
    }

    private void exportAnnotationCategories(VirtualEditionInter virtualEditionInter, HumanAnnotation annotation,
                                            Element note) {
        for (Category category : annotation.getCategories()) {
            Element catRef = new Element("catRef", this.xmlns);
            catRef.setAttribute("scheme", "#" + virtualEditionInter.getEdition().getXmlId());
            catRef.setAttribute("target", "#" + category.getName());
            note.addContent(catRef);
        }
    }

    private void exportAnnotationRanges(Annotation annotation, Element note) {
        for (Range range : annotation.getRangeSet()) {
            Element quote = new Element("quote", this.xmlns);
            quote.setAttribute("from", range.getStart());
            quote.setAttribute("to", range.getEnd());
            quote.setAttribute("fromOffset", Integer.toString(range.getStartOffset()));
            quote.setAttribute("toOffset", Integer.toString(range.getEndOffset()));
            quote.setText(annotation.getQuote());
            note.addContent(quote);
        }
    }


    //TODO : these class game related functions should be moved to their own exporter in the game module
   /* private void exportClassificationGames(Element textClass, VirtualEditionInter virtualEditionInter) {
        Element classificationGameList = new Element("classificationGameList", this.xmlns);
        textClass.addContent(classificationGameList);

        for (ClassificationGame game : ClassificationModule.getInstance().getClassificationGamesForInter(virtualEditionInter.getXmlId())) {
            Element gameElement = new Element("classificationGame", this.xmlns);
            gameElement.setAttribute("state", game.getState().toString());
            gameElement.setAttribute("description", game.getDescription());
            gameElement.setAttribute("dateTime", String.valueOf(game.getDateTime()));
            gameElement.setAttribute("sync", Boolean.toString(game.getSync()));
            gameElement.setAttribute("responsible", game.getResponsible());
            if (game.getTagId() != null) {
                gameElement.setAttribute("tag", virtualEditionInter.getTagSet()
                        .stream().filter(tag -> tag.getCategory().getUrlId().equals(game.getTagId())).findAny().orElseThrow(LdoDException::new).getCategory().getName());
            }
            ClassificationGameParticipant participant = game.getClassificationGameParticipantSet().stream()
                    .filter(ClassificationGameParticipant::getWinner).findFirst().orElse(null);
            gameElement.setAttribute("winningUser",
                    participant != null ? participant.getPlayer().getUser() : " ");

            exportClassificationGameRounds(gameElement, game);
            exportClassificationGameParticipants(gameElement, game);
            classificationGameList.addContent(gameElement);
        }

    }

    private void exportClassificationGameRounds(Element gameElement, ClassificationGame game) {
        Element classificationRoundList = new Element("classificationGameRoundList", this.xmlns);

        game.getAllRounds().forEach(round -> {
            Element roundElement = new Element("classificationGameRound", this.xmlns);
            roundElement.setAttribute("paragraphNumber", Integer.toString(round.getNumber()));
            roundElement.setAttribute("roundNumber", Integer.toString(round.getRound()));
            roundElement.setAttribute("tag", round.getTag());
            roundElement.setAttribute("vote", Double.toString(round.getVote()));
            roundElement.setAttribute("dateTime", String.valueOf(round.getTime()));
            roundElement.setAttribute("username",
                    round.getClassificationGameParticipant().getPlayer().getUser());
            classificationRoundList.addContent(roundElement);
        });
        gameElement.addContent(classificationRoundList);
    }

    private void exportClassificationGameParticipants(Element element, ClassificationGame game) {
        Element classificationParticipantList = new Element("classificationGameParticipantList", this.xmlns);

        for (ClassificationGameParticipant participant : game.getClassificationGameParticipantSet()) {
            Element participantElement = new Element("classificationGameParticipant", this.xmlns);
            participantElement.setAttribute("username", participant.getPlayer().getUser());
            participantElement.setAttribute("winner", Boolean.toString(participant.getWinner()));
            participantElement.setAttribute("score", Double.toString(participant.getScore()));
            classificationParticipantList.addContent(participantElement);
        }

        element.addContent(classificationParticipantList);
    }*/
}


import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filters;
import org.jdom2.input.SAXBuilder;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.joda.time.LocalDate;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.virtual.domain.*;


import java.io.*;
import java.nio.charset.Charset;

public class VirtualEditionsTEICorpusImport {

    private Element ldoDTEI = null;
    private Namespace namespace = null;
    private VirtualModule virtualModule = null;
    private Document doc = null;

    public void importVirtualEditionsCorpus(InputStream inputStream) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        Document doc;
        try {
            Reader reader = new InputStreamReader(inputStream, Charset.defaultCharset());
            doc = builder.build(reader);
            //doc = builder.build(inputStream);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        processImport(doc);
    }

    public void importVirtualEditionsCorpus(String corpusTEI) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);

        InputStream stream = new ByteArrayInputStream(corpusTEI.getBytes());

        importVirtualEditionsCorpus(stream);
    }

    @Atomic(mode = TxMode.WRITE)
    private void processImport(Document doc) {
        VirtualModule virtualModule = VirtualModule.getInstance();

        importVirtualEditions(doc, virtualModule);

        importTaxonomies(doc, virtualModule);

        importSocialMediaCriteria(doc, virtualModule);

        // IMPORT THEM FROM THE FILES IN DISK
        //	importTweets(doc, virtualModule);
    }

    // TODO: o construtor recebe a TwitterCitation a null pq ainda não sabe qual é
    // só no import Twitter Citation da outra classe é q é feita esta ligação
//    private void importTweets(Document doc, VirtualModule ldoD) {
//        Namespace namespace = doc.getRootElement().getNamespace();
//        XPathFactory xpfac = XPathFactory.instance();
//        XPathExpression<Element> xp = xpfac.compile("//def:tweet", Filters.element(), null,
//                Namespace.getNamespace("def", namespace.getURI()));
//        for (Element tweet : xp.evaluate(doc)) {
//            String sourceLink = tweet.getAttributeValue("sourceLink");
//            String date = tweet.getAttributeValue("date");
//
//            Element tweetTextElement = tweet.getChild("tweetText", namespace);
//            String tweetText = tweetTextElement.getTextModule(); // trim() ?
//
//            long tweetID = Long.parseLong(tweet.getAttributeValue("tweetId"));
//            String location = tweet.getAttributeValue("location");
//            String country = tweet.getAttributeValue("country");
//            String username = tweet.getAttributeValue("username");
//            String userProfileURL = tweet.getAttributeValue("userProfileURL");
//            String userImageURL = tweet.getAttributeValue("userImageURL");
//
//            long originalTweetID = Long.parseLong(tweet.getAttributeValue("originalTweetId"));
//            boolean isRetweet = Boolean.valueOf(tweet.getAttributeValue("isRetweet"));
//
//            new Tweet(ldoD, sourceLink, date, tweetText, tweetID, location, country, username, userProfileURL,
//                    userImageURL, originalTweetID, isRetweet, null);
//        }
//    }


    private void importVirtualEditions(Document doc, VirtualModule virtualModule) {
        Namespace namespace = doc.getRootElement().getNamespace();
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:bibl", Filters.element(), null,
                Namespace.getNamespace("def", namespace.getURI()));
        for (Element bibl : xp.evaluate(doc)) {
            VirtualEdition virtualEdition = null;

            boolean pub = bibl.getAttributeValue("status").equals("PUBLIC") ? true : false;
            String acronym = bibl.getAttributeValue("id", Namespace.XML_NAMESPACE);
            String title = bibl.getChildText("title", namespace);
            String synopsis = bibl.getChildText("synopsis", namespace);
            LocalDate date = LocalDate.parse(bibl.getChild("date", namespace).getAttributeValue("when"));

            String owner = null;

            for (Element editor : bibl.getChildren("editor", namespace)) {
                if (editor.getAttributeValue("role").equals("ADMIN")) {
                    owner = editor.getAttributeValue("nymRef");
                    // if a virtual edition exists with the same name, it is
                    // deleted
                    virtualEdition = virtualModule.getVirtualEdition(acronym);
                    if (virtualEdition != null) {
                        virtualEdition.remove();
                    }
                    virtualEdition = virtualModule.createVirtualEdition(owner, acronym, title, date, pub, null);
                    virtualEdition.setSynopsis(synopsis);
                    break;
                }
            }

            for (Element editor : bibl.getChildren("editor", namespace)) {
                String user = editor.getAttributeValue("nymRef");
                Member.MemberRole role = Member.MemberRole.valueOf(editor.getAttributeValue("role"));
                boolean active = editor.getAttributeValue("active").equals("true") ? true : false;

                Member member = null;
                if (user.equals(owner)) {
                    member = virtualEdition.getMember(user);
                } else {
                    member = new Member(virtualEdition, user, role, active);
                }

                date = LocalDate.parse(editor.getChild("date", namespace).getAttributeValue("when"));
                member.setDate(date);
            }

        }
    }

    private void importTaxonomies(Document doc, VirtualModule virtualModule) {
        Namespace namespace = doc.getRootElement().getNamespace();
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:taxonomy", Filters.element(), null,
                Namespace.getNamespace("def", namespace.getURI()));
        for (Element tax : xp.evaluate(doc)) {
            String xmlId = tax.getAttributeValue("source").substring(1);
            System.out.println(xmlId);
            System.out.println(VirtualModule.getInstance().getVirtualEditionByXmlId(xmlId));
            Taxonomy taxonomy = VirtualModule.getInstance().getVirtualEditionByXmlId(xmlId).getTaxonomy();

            for (Element item : tax.getChild("desc", namespace).getChild("list", namespace).getChildren("item",
                    namespace)) {
                switch (item.getText()) {
                    case "OPEN_MANAGEMENT":
                        taxonomy.setOpenManagement(true);
                        break;
                    case "OPEN_ANNOTATION":
                        taxonomy.setOpenAnnotation(true);
                        break;
                    case "CLOSED_VOCABULARY":
                        taxonomy.setOpenVocabulary(false);
                        break;
                    default:
                        break;
                }
            }

            for (Element cat : tax.getChildren("category", namespace)) {
                new Category().init(taxonomy, cat.getChildText("catDesc", namespace));
            }
        }
    }

    private void importSocialMediaCriteria(Document doc, VirtualModule virtualModule) {
        Namespace namespace = doc.getRootElement().getNamespace();
        XPathFactory xpfac = XPathFactory.instance();
        XPathExpression<Element> xp = xpfac.compile("//def:editionCriteria", Filters.element(), null,
                Namespace.getNamespace("def", namespace.getURI()));
        for (Element editionCriteria : xp.evaluate(doc)) {
            String xmlId = editionCriteria.getAttributeValue("source").substring(1);
            System.out.println(xmlId);
            System.out.println(VirtualModule.getInstance().getVirtualEditionByXmlId(xmlId));

            VirtualEdition virtualEdition = VirtualModule.getInstance().getVirtualEditionByXmlId(xmlId);

            Element mediaSource = editionCriteria.getChild("mediaSource", namespace);
            if (mediaSource != null) {
                new MediaSource(virtualEdition, mediaSource.getAttributeValue("name"));
            }

            Element timeWindow = editionCriteria.getChild("timeWindow", namespace);
            if (timeWindow != null) {
                // TODO: new code to support empty string exported dates
                LocalDate beginDate = null;
                LocalDate endDate = null;
                if (!timeWindow.getAttributeValue("beginDate").equals("")) {
                    beginDate = LocalDate.parse(timeWindow.getAttributeValue("beginDate"));
                }
                if (!timeWindow.getAttributeValue("endDate").equals("")) {
                    endDate = LocalDate.parse(timeWindow.getAttributeValue("endDate"));
                }

                new TimeWindow(virtualEdition, beginDate, endDate);

                // old code
                // new TimeWindow(virtualEdition,
                // LocalDate.parse(timeWindow.getAttributeValue("beginDate")),
                // LocalDate.parse(timeWindow.getAttributeValue("endDate")));
            }

            Element geographicLocation = editionCriteria.getChild("geographicLocation", namespace);
            if (geographicLocation != null) {
                new GeographicLocation(virtualEdition, geographicLocation.getAttributeValue("country"),
                        geographicLocation.getAttributeValue("location"));
            }

            Element frequency = editionCriteria.getChild("frequency", namespace);
            if (frequency != null) {
                new Frequency(virtualEdition, Integer.parseInt(frequency.getAttributeValue("frequency")));
            }

        }
    }

    private void parseTEIFile(InputStream file) {
        SAXBuilder builder = new SAXBuilder();
        builder.setIgnoringElementContentWhitespace(true);
        try {
            // TODO: create a config variable for the xml file
            this.doc = builder.build(file);
        } catch (FileNotFoundException e) {
            throw new LdoDLoadException("Ficheiro não encontrado");
        } catch (JDOMException e) {
            throw new LdoDLoadException("Ficheiro com problemas de codificação TEI");
        } catch (IOException e) {
            throw new LdoDLoadException("Problemas com o ficheiro, tipo ou formato");
        }

        if (this.doc == null) {
            LdoDLoadException ex = new LdoDLoadException("Ficheiro inexistente ou sem formato TEI");
            throw ex;
        }

        this.ldoDTEI = this.doc.getRootElement();
        this.namespace = this.ldoDTEI.getNamespace();
    }


    @Atomic(mode = TxMode.WRITE)
    public void loadTEICorpusVirtual(InputStream file) {

        parseTEIFile(file);
        this.virtualModule = VirtualModule.getInstance();
        loadTitleStmt();
    }

    private void loadTitleStmt() {
        Element corpusHeaderTitleStmt = this.ldoDTEI.getChild("teiHeader", this.namespace)
                .getChild("fileDesc", this.namespace).getChild("titleStmt", this.namespace);

        this.virtualModule.setTitle(corpusHeaderTitleStmt.getChild("title", this.namespace).getText());
        this.virtualModule.setAuthor(corpusHeaderTitleStmt.getChild("author", this.namespace).getText());
        this.virtualModule.setEditor(corpusHeaderTitleStmt.getChild("editor", this.namespace).getText());
        this.virtualModule.setSponsor(corpusHeaderTitleStmt.getChild("sponsor", this.namespace).getText());
        this.virtualModule.setFunder(corpusHeaderTitleStmt.getChild("funder", this.namespace).getText());
        this.virtualModule.setPrincipal(corpusHeaderTitleStmt.getChild("principal", this.namespace).getText());
    }

}


import org.apache.commons.lang.StringEscapeUtils;
import org.jdom2.Attribute;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.virtual.domain.*;

public class VirtualEditionsTEICorpusExport {
    private static final String ED_VIRT = "ED.VIRT";

    Namespace xmlns = Namespace.getNamespace("http://www.tei-c.org/ns/1.0");

    Document jdomDoc = null;

    @Atomic
    public String export() {
        this.jdomDoc = new Document();
        Element rootElement = new Element("teiCorpus");
        rootElement.setNamespace(this.xmlns);
        this.jdomDoc.setRootElement(rootElement);
        Element teiHeader = new Element("teiHeader", this.xmlns);
        teiHeader.setAttribute("type", "corpus");
        rootElement.addContent(teiHeader);


        // NOT NECESSARY THEY CAN BE LOADED FROM THE FILES
//		Element tweetList = generateTweetList(teiHeader);
//		for (Tweet tweet : VirtualModule.getInstance().getTweetSet()) {
//			exportTweet(tweetList, tweet);
//		}


        Element listPlayer = generatePlayerList(teiHeader);
        /*for (Player player : ClassificationModule.getInstance().getPlayerSet()) { //TODO: this should be exported through the game module
            exportPlayer(listPlayer, player);
        }*/

        Element listBibl = generateFileDesc(teiHeader);
        for (VirtualEdition virtualEdition : VirtualModule.getInstance().getVirtualEditionsSet()) {
            exportVirtualEditionBibl(listBibl, virtualEdition);
        }

        Element classDecl = generateEncodingDesc(teiHeader);
        for (VirtualEdition virtualEdition : VirtualModule.getInstance().getVirtualEditionsSet()) {
            exportVirtualEditionTaxonomy(classDecl, virtualEdition);
        }

        Element socialMediaCriteria = generateSocialMediaCriteria(teiHeader);
        for (VirtualEdition virtualEdition : VirtualModule.getInstance().getVirtualEditionsSet()) {
            exportVirtualEditionSocialMediaCriteria(socialMediaCriteria, virtualEdition);
        }

        XMLOutputter xml = new XMLOutputter();
        xml.setFormat(Format.getPrettyFormat());
        // System.out.println(xml.outputString(rootElement));

        return xml.outputString(rootElement);
    }

    // TODO: passar os element para attribute - done
//	protected void exportTweet(Element tweetList, Tweet tweet) {
//		Element tweetElement = new Element("tweet", this.xmlns);
//		tweetList.addContent(tweetElement);
//
//		tweetElement.setAttribute("sourceLink", tweet.getSourceLink());
//		tweetElement.setAttribute("date", tweet.getDate());
//
//		Element tweetText = new Element("tweetText", this.xmlns);
//		tweetText.addContent(tweet.getTweetText());
//		tweetElement.addContent(tweetText);
//
//		tweetElement.setAttribute("tweetId", Long.toString(tweet.getTweetID()));
//		try {
//			tweetElement.setAttribute("location", tweet.getLocation().replace("?", ""));
//		} catch (org.jdom2.IllegalDataException e) {
//			tweetElement.setAttribute("location", "");
//		}
//		tweetElement.setAttribute("country", tweet.getCountry());
//		tweetElement.setAttribute("username", tweet.getUsername());
//		tweetElement.setAttribute("userProfileURL", tweet.getUserProfileURL());
//		tweetElement.setAttribute("userImageURL", tweet.getUserProfileURL());
//
//		tweetElement.setAttribute("originalTweetId", Long.toString(tweet.getOriginalTweetID()));
//		tweetElement.setAttribute("isRetweet", String.valueOf(tweet.getIsRetweet()));
//
//		// TODO: discutir com o professor a utilidade deste atributo, útil apenas para
//		// debug
//		// Este atributo stressa com o teste original de export do corpus pq os tweets
//		// são exportados antes das citations, e no início os tweets têm todas as
//		// citations a null e por isso este atributo não era exportado
//		// if (tweet.getCitation() != null) {
//		// tweetElement.setAttribute("citationId",
//		// Long.toString(tweet.getCitation().getId()));
//		// }
//	}

//	protected Element generateTweetList(Element teiHeader) {
//		Element tweetList = new Element("tweetList", this.xmlns);
//		teiHeader.addContent(tweetList);
//		return tweetList;
//	}


    protected Element generatePlayerList(Element teiHeader) {
        Element playerList = new Element("playerList", this.xmlns);
        teiHeader.addContent(playerList);
        return playerList;
    }

//    private void exportPlayer(Element userElement, Player player) {
//        Element playerElement = new Element("player");
//        playerElement.setAttribute("user", player.getUser());
//        playerElement.setAttribute("score", Double.toString(player.getScore()));
//        userElement.addContent(playerElement);
//    }

    protected Element generateFileDesc(Element teiHeader) {
        Element fileDesc = new Element("fileDesc", this.xmlns);
        teiHeader.addContent(fileDesc);
        Element sourceDesc = new Element("sourceDesc", this.xmlns);
        fileDesc.addContent(sourceDesc);
        Element listBibl = new Element("listBibl", this.xmlns);
        Attribute id = new Attribute("id", ED_VIRT, Namespace.XML_NAMESPACE);
        listBibl.setAttribute(id);
        sourceDesc.addContent(listBibl);
        return listBibl;
    }

    protected void exportVirtualEditionBibl(Element element, VirtualEdition virtualEdition) {
        Element bibl = new Element("bibl", this.xmlns);
        Attribute id = new Attribute("id", virtualEdition.getAcronym(), Namespace.XML_NAMESPACE);
        bibl.setAttribute(id);
        bibl.setAttribute("status", virtualEdition.getPub() ? "PUBLIC" : "PRIVATE");

        Element title = new Element("title", this.xmlns);
        title.setText(StringEscapeUtils.unescapeHtml(virtualEdition.getTitle()));
        bibl.addContent(title);

        Element synopsis = new Element("synopsis", this.xmlns);
        synopsis.setText(StringEscapeUtils.unescapeHtml(virtualEdition.getSynopsis()));
        bibl.addContent(synopsis);

        Element date = new Element("date", this.xmlns);
        date.setAttribute("when", virtualEdition.getDate().toString());
        bibl.addContent(date);

        exportEditors(bibl, virtualEdition);

        element.addContent(bibl);
    }

    private void exportEditors(Element element, VirtualEdition virtualEdition) {
        for (Member member : virtualEdition.getMemberSet()) {
            exportEditor(element, member);
        }
    }

    private void exportEditor(Element element, Member member) {
        Element editorElement = new Element("editor", this.xmlns);
        editorElement.setAttribute("nymRef", member.getUser());
        editorElement.setAttribute("role", member.getRole().toString());
        editorElement.setAttribute("active", exportBoolean(member.getActive()));
        element.addContent(editorElement);

//        Element persNameElement = new Element("persName", this.xmlns);
//        persNameElement.setText(member.getUser().getFirstName() + " " + member.getUser().getLastName());
//        editorElement.addContent(persNameElement);

        Element date = new Element("date", this.xmlns);
        date.setAttribute("when", member.getDate().toString());
        editorElement.addContent(date);

    }

    protected Element generateEncodingDesc(Element teiHeader) {
        Element encodingDesc = new Element("encodingDesc", this.xmlns);
        teiHeader.addContent(encodingDesc);
        Element classDecl = new Element("classDecl", this.xmlns);
        encodingDesc.addContent(classDecl);
        return classDecl;
    }

    protected void exportVirtualEditionTaxonomy(Element element, VirtualEdition virtualEdition) {
        Taxonomy taxonomy = virtualEdition.getTaxonomy();

        Element taxonomyElement = new Element("taxonomy", this.xmlns);
        taxonomyElement.setAttribute("source", "#" + ED_VIRT + "." + virtualEdition.getAcronym());

        Element taxonomyDesc = new Element("desc", this.xmlns);
        taxonomyElement.addContent(taxonomyDesc);

        Element descList = new Element("list", this.xmlns);
        descList.setAttribute("type", "interaction");
        taxonomyDesc.addContent(descList);

        Element listItem = new Element("item", this.xmlns);
        listItem.setText(taxonomy.getOpenManagement() ? "OPEN_MANAGEMENT" : "CLOSED_MANAGEMENT");
        descList.addContent(listItem);

        listItem = new Element("item", this.xmlns);
        listItem.setText(taxonomy.getOpenAnnotation() ? "OPEN_ANNOTATION" : "CLOSED_ANNOTATION");
        descList.addContent(listItem);

        listItem = new Element("item", this.xmlns);
        listItem.setText(taxonomy.getOpenVocabulary() ? "OPEN_VOCABULARY" : "CLOSED_VOCABULARY");
        descList.addContent(listItem);

        for (Category category : taxonomy.getCategoriesSet()) {
            exportCategory(taxonomyElement, category);
        }

        element.addContent(taxonomyElement);
    }

    private void exportCategory(Element element, Category category) {
        Element categoryElement = new Element("category", this.xmlns);
        Attribute id = new Attribute("id", category.getXmlId(), Namespace.XML_NAMESPACE);
        categoryElement.setAttribute(id);
        element.addContent(categoryElement);

        Element catDescElement = new Element("catDesc", this.xmlns);
        catDescElement.setText(category.getName());

        categoryElement.addContent(catDescElement);

    }

    private String exportBoolean(boolean value) {
        if (value) {
            return "true";
        } else {
            return "false";
        }
    }

    protected Element generateSocialMediaCriteria(Element teiHeader) {
        Element socialMediaCriteria = new Element("socialMediaCriteria", this.xmlns);
        teiHeader.addContent(socialMediaCriteria);
        return socialMediaCriteria;
    }

    protected Element exportVirtualEditionSocialMediaCriteria(Element socialMediaCriteria,
                                                              VirtualEdition virtualEdition) {
        Element virtualEditionSocialCriteria = new Element("editionCriteria", this.xmlns);
        virtualEditionSocialCriteria.setAttribute("source", "#" + ED_VIRT + "." + virtualEdition.getAcronym());
        socialMediaCriteria.addContent(virtualEditionSocialCriteria);

        for (SocialMediaCriteria criteria : virtualEdition.getCriteriaSet()) {
            if (criteria instanceof MediaSource) {
                Element mediaSource = new Element("mediaSource", this.xmlns);
                mediaSource.setAttribute("name", ((MediaSource) criteria).getName());
                virtualEditionSocialCriteria.addContent(mediaSource);
            } else if (criteria instanceof TimeWindow) {
                Element timeWindow = new Element("timeWindow", this.xmlns);

                // TODO: changed because begindate and enddate cannot be null
                String beginDate = "";
                String endDate = "";
                if (((TimeWindow) criteria).getBeginDate() != null) {
                    beginDate = ((TimeWindow) criteria).getBeginDate().toString();
                }
                if (((TimeWindow) criteria).getEndDate() != null) {
                    endDate = ((TimeWindow) criteria).getEndDate().toString();
                }
                timeWindow.setAttribute("beginDate", beginDate);
                timeWindow.setAttribute("endDate", endDate);

                // old code
                // timeWindow.setAttribute("beginDate", ((TimeWindow)
                // criteria).getBeginDate().toString());
                // timeWindow.setAttribute("endDate", ((TimeWindow)
                // criteria).getEndDate().toString());

                virtualEditionSocialCriteria.addContent(timeWindow);
            } else if (criteria instanceof GeographicLocation) {
                Element geographicLocation = new Element("geographicLocation", this.xmlns);
                geographicLocation.setAttribute("country", ((GeographicLocation) criteria).getCountry());

                // TODO: changed because location cannot be null
                String location = ((GeographicLocation) criteria).getLocation();
                if (location == null) {
                    location = "";
                }
                geographicLocation.setAttribute("location", location);

                // old code
                // geographicLocation.setAttribute("location", ((GeographicLocation)
                // criteria).getLocation());

                virtualEditionSocialCriteria.addContent(geographicLocation);
            } else if (criteria instanceof Frequency) {
                Element frequency = new Element("frequency", this.xmlns);
                frequency.setAttribute("frequency", Integer.toString(((Frequency) criteria).getFrequency()));
                virtualEditionSocialCriteria.addContent(frequency);
            } else {
                assert true; // TODO: qual é o objetivo disto?
            }

        }

        return virtualEditionSocialCriteria;
    }

}


import org.apache.commons.io.IOUtils;
import pt.ist.fenixframework.Atomic;

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.notification.event.EventInterface;


import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class WriteVirtualEditonsToFile {

    @Atomic
    public String export() throws IOException, FileNotFoundException {
        String timeStamp = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(new Date());

        String exportDir = PropertiesManager.getProperties().getProperty("export.dir");
        File directory = new File(exportDir);
        String filename = "virtualeditions-" + timeStamp + ".zip";
        FileOutputStream fos = new FileOutputStream(directory.getPath() + "/" + filename);
        ZipOutputStream zos = new ZipOutputStream(fos);

        zos.putNextEntry(new ZipEntry("users.xml"));
        InputStream in = generateUsersInputStream();
        copyToZipStream(zos, in);
        zos.closeEntry();

        zos.putNextEntry(new ZipEntry("corpus.xml"));
        in = generateCorpusInputStream();
        copyToZipStream(zos, in);
        zos.closeEntry();


        for (FragmentDto fragmentDto : VirtualRequiresInterface.getInstance().getFragmentDtoSet()) {
            zos.putNextEntry(new ZipEntry(fragmentDto.getXmlId() + ".xml"));
            in = generateFragmentInputStream(fragmentDto.getXmlId());
            copyToZipStream(zos, in);
            zos.closeEntry();

        }

        zos.close();

        EventInterface.getInstance().publish(new Event(Event.EventType.VIRTUAL_EXPORT, filename));

        return filename;
    }

    private void copyToZipStream(ZipOutputStream zos, InputStream in) throws IOException {
        byte[] buffer = new byte[1024];
        int len;
        while ((len = in.read(buffer)) > 0) {
            zos.write(buffer, 0, len);
        }
        in.close();
    }

    private InputStream generateUsersInputStream() throws IOException {
//        UsersXMLExport usersExporter = new UsersXMLExport();
        InputStream in = IOUtils.toInputStream(VirtualRequiresInterface.getInstance().exportXMLUsers(), "UTF-8");
        return in;
    }

    private InputStream generateCorpusInputStream() throws IOException {
        VirtualEditionsTEICorpusExport generator = new VirtualEditionsTEICorpusExport();
        InputStream in = IOUtils.toInputStream(generator.export(), "UTF-8");
        return in;
    }

    private InputStream generateFragmentInputStream(String fragmentXmlId) throws IOException {
        VirtualEditionFragmentsTEIExport generator = new VirtualEditionFragmentsTEIExport();
        InputStream in = IOUtils.toInputStream(generator.exportFragment(fragmentXmlId), "UTF-8");
        return in;
    }

}


import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;


import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.utils.LdoDLoadException;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualEdition;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;
import pt.ist.socialsoftware.edition.virtual.feature.topicmodeling.CorpusGenerator;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Set;

public class GenerateTEIFragmentsCorpus {

    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(GenerateTEIFragmentsCorpus.class);


    private VirtualModule virtualModule = null;

    public GenerateTEIFragmentsCorpus() { }


    public void LoadFragmentCorpus(Set<FragmentDto> fragments) {
        this.virtualModule = VirtualModule.getInstance();
        fragments.forEach(fragmentDto -> generateCorpus(fragmentDto));
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    private void generateCorpus(FragmentDto fragment) {

        // generate corpus in corpus.dir
        CorpusGenerator generator = new CorpusGenerator();
        try {
            generator.generate(fragment);
        } catch (FileNotFoundException e1) {
            throw new LdoDLoadException(
                    "LoadTEIFragments.loadFragment erro FileNotFoundException a gerar corpus do fragmento "
                            + fragment.getXmlId() + e1.getMessage());
        } catch (IOException e1) {
            throw new LdoDLoadException("LoadTEIFragments.loadFragment erro IOException a gerar corpus do fragmento "
                    + fragment.getXmlId());
        }

        // generate index in indexer.dir
          for (ScholarInterDto interDto: fragment.getEmbeddedScholarInterDtos()) {
            try {
//                Indexer indexer = Indexer.getIndexer();
//                indexer.addDocument(interDto);
//                textProvidesInterface.addDocumentToIndexer(interDto);
                VirtualRequiresInterface.getInstance().addDocumentToIndexer(interDto.getXmlId());

            } catch (FileNotFoundException e) {
                throw new LdoDLoadException(
                        "LoadTEIFragments.loadFragment erro FileNotFoundException a gerar index da interpretação "
                                + interDto.getXmlId());
            } catch (IOException e) {
                throw new LdoDLoadException(
                        "LoadTEIFragments.loadFragment erro IOException a gerar index da interpretação "
                                + interDto.getXmlId());
            }
        }

        VirtualEdition archiveEdition = this.virtualModule.getArchiveEdition();
        ScholarInterDto sourceInter = fragment.getSortedSourceInter().get(fragment.getSortedSourceInter().size() - 1);

        // if the representative fragment interpretation is not in
        // the archive edition we have to add it
        if (archiveEdition != null
                && !archiveEdition.getIntersSet().contains(sourceInter)) {
            logger.debug("loadFragment ldod-edition-size:{}", archiveEdition.getAllDepthVirtualEditionInters().size());
//            archiveEdition.createVirtualEditionInter(new ScholarInterDto(sourceInter.getXmlId()),
//                    archiveEdition.getMaxFragNumber() + 1);
            archiveEdition.createVirtualEditionInter(VirtualRequiresInterface.getInstance().getScholarInterByXmlId(sourceInter.getXmlId()),
                    archiveEdition.getMaxFragNumber() + 1);
        }


//         uncomment when a pretty print of the result of load is required in
//         stdout
//         Element rootElement = new Element(fragment.getXmlId(),
//         Namespace.getNamespace("http://www.tei-c.org/ns/1.0"));
//         JDomTEITextPortionWriter writer = new
//         JDomTEITextPortionWriter(rootElement,
//         fragment.getFragmentInterSet());
//         writer.visit((AppText) fragment.getTextPortion());
//         XMLOutputter xml = new XMLOutputter();
//         xml.setFormat(Format.getPrettyFormat());
//         System.out.println(xml.outputString(rootElement));

    }

}


import org.apache.commons.io.comparator.NameFileComparator;
import org.apache.commons.io.filefilter.FileFileFilter;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.domain.LastTwitterID;
import pt.ist.socialsoftware.edition.virtual.domain.Tweet;
import pt.ist.socialsoftware.edition.virtual.domain.TwitterCitation;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;


import java.io.*;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class TweetFactory {
    private static final Logger logger = LoggerFactory.getLogger(TweetFactory.class);

    public void create() throws IOException {
        logger.debug("STARTED TWEET FACTORY!!!");

        File folder = new File(PropertiesManager.getProperties().getProperty("social.aware.dir"));
        // get just files, not directories
        File[] files = folder.listFiles((FileFilter) FileFileFilter.FILE);
        Arrays.sort(files, NameFileComparator.NAME_COMPARATOR);

        String[] sources = {LastTwitterID.FP_CITATIONS, LastTwitterID.LIVRO_CITATIONS, LastTwitterID.BERNARDO_CITATIONS, LastTwitterID.VICENTE_CITATIONS};

        for (String source : sources) {
            String lastFileName = getLastProcessedFileName(source);

            List<File> sourceFiles = Arrays.stream(files)
                    .filter(f -> f.getName().contains(source) && f.getName().compareTo(lastFileName) >= 0)
                    .collect(Collectors.toList());

            for (File fileEntry : sourceFiles) {
                logger.debug("JSON file name: " + fileEntry.getName());
                fileTweetCreation(fileEntry);
                updateLastProcessedFileName(fileEntry);
            }
        }

        logger.debug("DELETE CITATIONS WITHOUT INFO RANGE");
        VirtualModule.deleteTweetCitationsWithoutInfoRangeOrTweet();

        logger.debug("DELETE TWEETS WITHOUT CITATION");
        VirtualModule.deleteTweetsWithoutCitation();

        logger.debug("FINISHED TWEET FACTORY!!!");
    }

    @Atomic(mode = TxMode.WRITE)
    private void updateLastProcessedFileName(File fileEntry) {
        VirtualModule.getInstance().getLastTwitterID().updateLastParsedFile(fileEntry.getName());
    }

    @Atomic(mode = TxMode.READ)
    private String getLastProcessedFileName(String source) {
        return VirtualModule.getInstance().getLastTwitterID().getLastParsedFile(source) != null
                ? VirtualModule.getInstance().getLastTwitterID().getLastParsedFile(source)
                : "";
    }

    private void fileTweetCreation(File fileEntry) throws FileNotFoundException, IOException {
        String line = null;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(fileEntry));

        while ((line = bufferedReader.readLine()) != null) {
//			try {
//				FenixFramework.getTransactionManager().begin();
//			} catch (NotSupportedException | SystemException e1) {
//				throw new LdoDException("Fail a transaction begin");
//			}

            try {

                // verify here if the line tweet ID is bigger than the last twitter id in the
                // archive

                createTweet(line);
            } catch (ParseException e1) {
                logger.debug("Miss the creation of a tweet due to the parse of some of its data");
            }

//			try {
//				FenixFramework.getTransactionManager().commit();
//			} catch (SecurityException | IllegalStateException | RollbackException | HeuristicMixedException
//					| HeuristicRollbackException | SystemException e) {
//				logger.debug("Miss the creation of a tweet due to the info it contains");
//
//			}
        }
        bufferedReader.close();
    }

    @Atomic(mode = TxMode.WRITE)
    private void createTweet(String line) throws ParseException {
        VirtualModule virtualModule = VirtualModule.getInstance();
        JSONObject obj = (JSONObject) new JSONParser().parse(line);

        // if tweets set does not contain current tweet in json file
        if (!virtualModule.checkIfTweetExists((long) obj.get("tweetID"))) {
            // remove emojis, etc
            String regex = "[^\\p{L}\\p{N}\\p{P}\\p{Z}]";
            Pattern pattern = Pattern.compile(regex, Pattern.UNICODE_CHARACTER_CLASS);
            Matcher matcher = pattern.matcher((String) obj.get("text"));
            String tweetTextSubstring = matcher.replaceAll("");

            // removing "http" from tweet text
            if (tweetTextSubstring.contains("http")) {
                int httpIndex = tweetTextSubstring.indexOf("http");
                tweetTextSubstring = tweetTextSubstring.substring(0, httpIndex);
            }

            if (!tweetTextSubstring.equals("")) {
                TwitterCitation twitterCitation = null;
                boolean isRetweet = false;
                long originalTweetID = -1L;
                // new JSON files contain this field
                if (obj.containsKey("originalTweetID")) {

                    originalTweetID = (long) obj.get("originalTweetID");
                    isRetweet = (boolean) obj.get("isRetweet");
                    // tweet is a retweet
                    if (isRetweet) {
                        twitterCitation = virtualModule.getTwitterCitationByTweetID((long) obj.get("originalTweetID"));

                    }
                    // tweet is not a retweet
                    else {
                        twitterCitation = virtualModule.getTwitterCitationByTweetID((long) obj.get("tweetID"));
                    }
                }
                // old JSON files
                else {
                    twitterCitation = virtualModule.getTwitterCitationByTweetID((long) obj.get("tweetID"));
                }

                // we only create Tweets that have a Twitter Citation with InfoRange associated
                if (twitterCitation != null && !twitterCitation.getInfoRangeDtoSet().isEmpty()) {
                    // Create tweet
                    matcher = pattern.matcher((String) obj.get("location"));
                    String cleanTweetLocation = matcher.replaceAll("");

                    matcher = pattern.matcher((String) obj.get("country"));
                    String cleanTweetCountry = matcher.replaceAll("");

                    new Tweet(virtualModule, (String) obj.get("tweetURL"), (String) obj.get("date"), tweetTextSubstring,
                            (long) obj.get("tweetID"), cleanTweetLocation, cleanTweetCountry,
                            (String) obj.get("username"), (String) obj.get("profURL"), (String) obj.get("profImg"),
                            originalTweetID, isRetweet, twitterCitation);
                }

            }

        }
    }
}


import org.apache.lucene.analysis.*;
import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;
import org.apache.lucene.analysis.pt.PortugueseAnalyzer;
import org.apache.lucene.analysis.standard.StandardTokenizer;

public class IgnoreDiacriticsAnalyzer extends Analyzer {

    private final CharArraySet stopWords;

    public IgnoreDiacriticsAnalyzer() {
        this.stopWords = PortugueseAnalyzer.getDefaultStopSet();
    }

    @Override
    protected TokenStreamComponents createComponents(String fieldName) {
        Tokenizer source = new StandardTokenizer();
        TokenStream tokenStream = source;
        tokenStream = new LowerCaseFilter(tokenStream);
        tokenStream = new StopFilter(tokenStream, getStopwordSet());
        tokenStream = new ASCIIFoldingFilter(tokenStream);
        return new TokenStreamComponents(source, tokenStream);
    }

    private CharArraySet getStopwordSet() {
        return this.stopWords;
    }

}


import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.DomainObject;
import pt.ist.fenixframework.FenixFramework;

import pt.ist.socialsoftware.edition.notification.dtos.text.CitationDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.InfoRangeDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;

import pt.ist.socialsoftware.edition.virtual.domain.*;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public class AwareAnnotationFactory {
    private static final Logger logger = LoggerFactory.getLogger(AwareAnnotationFactory.class);


    // main method of this Factory
    @Atomic(mode = TxMode.WRITE)
    public void generate() throws IOException {
        logger.debug("BEGINNIG OF AWARE FACTORY");

        for (VirtualEdition ve : VirtualModule.getInstance().getVirtualEditionsSet()) {
            if (ve.isSAVE()) {
                searchForAwareAnnotations(ve);
            }
        }

        logger.debug("END OF AWARE FACTORY");
    }

    @Atomic(mode = TxMode.WRITE)
    public void searchForAwareAnnotations(VirtualEdition ve) {
        logger.debug("STARTED AWARE FACTORY");

        Set<SocialMediaCriteria> criteria = ve.getCriteriaSet();

        for (VirtualEditionInter inter : ve.getAllDepthVirtualEditionInters()) {

            if (validateFrequency(criteria, inter)) {
                Set<TwitterCitation> totalTwitterCitations = getTotalTwitterCitationsByInterAndCriteria(inter, criteria);

                // *********************** REMOVAL ****************************

                removeAllAwareAnnotationsFromVEInter(inter);

                for (TwitterCitation newCitation : totalTwitterCitations) {

                    createAwareAnnotation(inter, newCitation);
                }
            }
        }

        logger.debug("ENDED AWARE FACTORY");
    }

    // método responsável por criar aware annotation no vei com meta informação
    // contida na tc
    private void createAwareAnnotation(VirtualEditionInter vei, TwitterCitation tc) {
        InfoRangeDto infoRange = getInfoRangeByVirtualEditionInter(vei, tc);

//        if (vei.getVirtualEdition().getAcronym().equals(LdoD.TWITTER_EDITION_ACRONYM)) {
//            logger.debug("createAwareAnnotation title: {}, start: {}, end: {}, startOffset: {}, endOffset: {}, quote: {}, text: {}",
//                    vei.getTitle(), infoRange.getStart(), infoRange.getEnd(), infoRange.getStartOffset(), infoRange.getEndOffset(), infoRange.getQuote(), infoRange.getText());
//        }

        AwareAnnotation annotation = new AwareAnnotation(vei, infoRange.getQuote(), infoRange.getText(), tc);

        new Range(annotation, infoRange.getStart(), infoRange.getStartOffset(), infoRange.getEnd(),
                infoRange.getEndOffset());
    }

    // TODO: utilizar o método da classe Citation em vez deste
    // a citation has several info ranges.
    // this method finds out the appropriate info range for the specific vei
    private InfoRangeDto getInfoRangeByVirtualEditionInter(VirtualEditionInter vei, TwitterCitation tc) {

        // used scholarinter
        ScholarInterDto lastUsed = getLastUsedScholarEditionInter(vei);

        InfoRangeDto infoRange = null;
        for (InfoRangeDto ir : tc.getInfoRangeDtoSet()) {

            if (lastUsed.getXmlId() == ir.getScholarInterid()) {
                infoRange = ir;
                break;
            }
        }
        return infoRange;
    }

    public void removeAllAwareAnnotationsFromVEInter(VirtualEditionInter inter) {
        Set<AwareAnnotation> awareAnnotations = inter.getAnnotationSet().stream()
                .filter(AwareAnnotation.class::isInstance).map(AwareAnnotation.class::cast).collect(Collectors.toSet());
        for (AwareAnnotation aa : awareAnnotations) {
            aa.remove();
        }
    }

    // upgraded to support criteria
    private Set<TwitterCitation> getTotalTwitterCitationsByInterAndCriteria(VirtualEditionInter inter,
                                                                            Set<SocialMediaCriteria> criteria) {
        Set<TwitterCitation> totalTwitterCitations = new HashSet<>();
        for (CitationDto tc : getFragment(inter).getCitationSet()) {
            if (validateCriteria(tc, criteria)) {
                DomainObject domainObject = FenixFramework.getDomainObject(tc.getExternalId());
                if (domainObject instanceof TwitterCitation) {
                    if (getInfoRangeByVirtualEditionInter(inter, (TwitterCitation) domainObject) != null) {
                        totalTwitterCitations.add((TwitterCitation) domainObject);
                    }

                }

            }
        }
        return totalTwitterCitations;
    }

    private boolean validateFrequency(Set<SocialMediaCriteria> criteria, VirtualEditionInter inter) {
        boolean isValid = true;
        for (SocialMediaCriteria criterion : criteria) {
            if (criterion instanceof Frequency) {
                if (((Frequency) criterion).getFrequency() > inter.getNumberOfTimesCitedIncludingRetweets()) {
                    isValid = false;
                }
            }
        }
        return isValid;
    }

    private boolean validateCriteria(CitationDto tc, Set<SocialMediaCriteria> criteria) {
        boolean isValid = true;
        for (SocialMediaCriteria criterion : criteria) {
            if (criterion instanceof MediaSource) {
                if (!((MediaSource) criterion).getName().equals("Twitter")) {
                    isValid = false;
                }
            } else if (criterion instanceof TimeWindow) {
                DateTimeFormatter formatter = DateTimeFormat.forPattern("d-MMM-yyyy");

                // estilo: "16-Aug-2016"
                String date = tc.getDate().split(" ")[0];

                // converter para estilo universal localdate: "2016-08-16"
                LocalDate localDate = LocalDate.parse(date, formatter);

                LocalDate beginDate = ((TimeWindow) criterion).getBeginDate();
                LocalDate endDate = ((TimeWindow) criterion).getEndDate();

                // new code that supports null format for date input by user
                if (beginDate != null) {
                    if (!(localDate.isAfter(beginDate) || localDate.isEqual(beginDate))) {
                        isValid = false;
                    }
                }
                if (endDate != null) {
                    if (!(localDate.isBefore(endDate) || localDate.isEqual(endDate))) {
                        isValid = false;
                    }
                }

            } else if (criterion instanceof GeographicLocation) {
                TwitterCitation twitterCitation = new TwitterCitation(tc);
                if (!((GeographicLocation) criterion).containsEveryCountry()
                        && !((GeographicLocation) criterion).containsCountry(twitterCitation.getCountry())) {
                    isValid = false;
                }
            }
        }

        return isValid;
    }

    // TODO: to be addressed when the awareness become a module on their own
    protected FragmentDto getFragment(VirtualEditionInter virtualEditionInter) {
//        return TextModule.getInstance().getFragmentByXmlId(virtualEditionInter.getFragmentXmlId());
        return VirtualRequiresInterface.getInstance().getFragmentByXmlId(virtualEditionInter.getFragmentXmlId());
    }

    // TODO: to be addressed when the awareness become a module on their own
    protected ScholarInterDto getLastUsedScholarEditionInter(VirtualEditionInter virtualEditionInter) {
//        return TextModule.getInstance().getScholarInterByXmlId(virtualEditionInter.getLastUsed().getXmlId());
        return VirtualRequiresInterface.getInstance().getScholarInterByXmlId(virtualEditionInter.getLastUsed().getXmlId());
    }

}


import org.apache.commons.io.comparator.NameFileComparator;
import org.apache.commons.io.filefilter.FileFileFilter;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.Term;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.queryparser.classic.QueryParserBase;
import org.apache.lucene.search.*;
import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
import org.apache.lucene.search.spans.SpanNearQuery;
import org.apache.lucene.search.spans.SpanQuery;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.NIOFSDirectory;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.fenixframework.FenixFramework;

import pt.ist.socialsoftware.edition.notification.dtos.text.CitationDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import pt.ist.socialsoftware.edition.virtual.api.VirtualRequiresInterface;

import pt.ist.socialsoftware.edition.virtual.domain.*;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class CitationDetecter {
    private final Logger logger = LoggerFactory.getLogger(CitationDetecter.class);


    private final int LUCENE_THRESHOLD = 20;
    private final int WINDOW_THRESHOLD = 13;

    private final String ID = "id";
    private final String TEXT = "text";

    private final Path docDir;
    private final Analyzer analyzer;
    private final QueryParserBase queryParser;

    public CitationDetecter() throws IOException {
        String path = PropertiesManager.getProperties().getProperty("indexer.dir");
        this.docDir = Paths.get(path);
        this.analyzer = new IgnoreDiacriticsAnalyzer();
        this.queryParser = new QueryParser(this.TEXT, this.analyzer);
    }

    public void detect() throws IOException {
        this.logger.debug("STARTING CITATION DETECTER!!");
        // resets last twitter IDs
        citationDetection();
        this.logger.debug("FINISHED DETECTING CITATIONS!!!");

        // identify ranges
        this.logger.debug("STARTED IDENTIFYING RANGES!!!");
        createInfoRanges();
        this.logger.debug("FINISHED IDENTIFYING RANGES!!!");

        printNumberOfCitationsWithInfoRanges();

        this.logger.debug("STARTED REMOVING TWEETS WITHOUT CITATIONS!!!");
        removeTweetsWithoutCitationsWithInfoRange();
        this.logger.debug("FINISHED REMOVING TWEETS WITHOUT CITATIONS!!!");

        printNumberOfCitationsWithInfoRanges();
    }

    @Atomic(mode = TxMode.WRITE)
    private void removeTweetsWithoutCitationsWithInfoRange() {
        VirtualModule.getInstance().removeTweetsWithoutCitationsWithInfoRange();
    }

    @Atomic
    private void printNumberOfCitationsWithInfoRanges() {
        this.logger.debug(
                "Number of Citations with Info Ranges: " + VirtualModule.getInstance().getNumberOfCitationsWithInfoRanges());
    }

    @Atomic(mode = TxMode.WRITE)
    private void resetLastTwitterIds() {
        VirtualModule.getInstance().getLastTwitterID().resetTwitterIDS();
    }

    private void citationDetection() throws IOException, FileNotFoundException {
        File folder = new File(PropertiesManager.getProperties().getProperty("social.aware.dir"));
        // get just files, not directories
        File[] files = folder.listFiles((FileFilter) FileFileFilter.FILE);
        Arrays.sort(files, NameFileComparator.NAME_COMPARATOR);

        String[] sources = {"fp", "livro", "bernardo", "vicente"};

        for (String source : sources) {
            String lastFileName = getLastFilenameForSource(source);

            List<File> sourceFiles = Arrays.stream(files)
                    .filter(f -> f.getName().contains(source) && f.getName().compareTo(lastFileName) >= 0)
                    .collect(Collectors.toList());

            for (File fileEntry : sourceFiles) {
                fileCitationDetection(fileEntry);

            }
        }

        printLastTwitterIdsAndFiles();

    }

    @Atomic
    private String getLastFilenameForSource(String source) {
        String lastFileName = VirtualModule.getInstance().getLastTwitterID().getLastParsedFile(source) != null
                ? VirtualModule.getInstance().getLastTwitterID().getLastParsedFile(source)
                : "";
        return lastFileName;
    }

    private void fileCitationDetection(File fileEntry) throws IOException {
        this.logger.debug("JSON file name: " + fileEntry.getName());

        JSONObject obj = new JSONObject();
        String line = null;

        BufferedReader bufferedReader = new BufferedReader(new FileReader(fileEntry));

        // criar um tempMaxID que guarda o valor de
        // VirtualModule.getInstance().getLastTwitterID()
        // pq é preciso darmos set na base de dados do valor antes do while, pq vem logo
        // na primeira linha
        long tempMaxID = getLastTwitterId(fileEntry);

        int lineNum = 0;
        while ((line = bufferedReader.readLine()) != null) {
            // logger.debug(line);

            try {
                obj = (JSONObject) new JSONParser().parse(line);

                if (lineNum == 0) {
                    updateLastTwitterId(fileEntry, obj);
                }
                lineNum++;

                if (obj.containsKey("isRetweet") && (boolean) obj.get("isRetweet")) {
                    continue;
                }

                if ((long) obj.get("tweetID") > tempMaxID) {
                    String tweetTextWithoutHttp = removeHttpFromTweetText(obj);

                    if (!tweetTextWithoutHttp.equals("")) {
                        searchQueryParserJSON(tweetTextWithoutHttp, obj);
                        // searchQueryParser(absoluteSearch(tweetTextWithoutHttp)); //demasiado rígida,
                        // nao funciona no nosso caso
                    }

                } else {
                    break;
                }
            } catch (ParseException |
                    org.apache.lucene.queryparser.classic.ParseException |
                    org.json.simple.parser.ParseException e) {
                e.printStackTrace();
            }
        }
        bufferedReader.close();
    }

    private void searchQueryParserJSON(String query, JSONObject obj)
            throws ParseException, org.apache.lucene.queryparser.classic.ParseException, IOException {
        Query parsedQuery = this.queryParser.parse(QueryParser.escape(query)); // escape foi a solução porque ele
        // stressava

//		try {
//			FenixFramework.getTransactionManager().begin();
//		} catch (NotSupportedException | SystemException e1) {
//			throw new LdoDException("Fail a transaction begin");
//		}

        searchIndexAndDisplayResultsJSON(parsedQuery, obj);

//		try {
//			FenixFramework.getTransactionManager().commit();
//		} catch (SecurityException | IllegalStateException | RollbackException | HeuristicMixedException
//				| HeuristicRollbackException | SystemException e) {
//			this.logger.debug("Miss the creation of a citation due to the info it contains");
//
//		}

    }

    @Atomic(mode = TxMode.WRITE)
    private void searchIndexAndDisplayResultsJSON(Query query, JSONObject obj) {
        try {
            int hitsPerPage = 5;
            Directory directory = new NIOFSDirectory(this.docDir);
            IndexReader idxReader = DirectoryReader.open(directory);
            IndexSearcher idxSearcher = new IndexSearcher(idxReader);

            ScoreDoc[] hits = idxSearcher.search(query, hitsPerPage).scoreDocs;
            if (hits.length > 0) {
                int docId = hits[0].doc;
                float score = hits[0].score;
                if (score > this.LUCENE_THRESHOLD) {
                    Document d = idxSearcher.doc(docId);

                    // necessary because the same tweet was collected using different keywords in
                    // FetchCitationsFromTwitter class
                    // check if twitter ID already exists in the list of Citations
                    // if it does idExists=true, therefore we don't create a citation for it!
//                    Set<TwitterCitation> allTwitterCitations = VirtualModule.getInstance().getCitationSet().stream()
//                            .filter(TwitterCitation.class::isInstance).map(TwitterCitation.class::cast)
//                            .collect(Collectors.toSet());
                    Set<TwitterCitation> allTwitterCitations = VirtualRequiresInterface.getInstance().getCitationSet().stream()
                            .map(c -> (TwitterCitation) FenixFramework.getDomainObject(c.getExternalId()))
                            .collect(Collectors.toSet());
                    boolean twitterIDExists = false;
                    for (TwitterCitation tc : allTwitterCitations) {
                        if (tc.getTweetID() == (long) obj.get("tweetID")) {
                            twitterIDExists = true;
                            break;
                        }
                    }
                    if (!twitterIDExists) {
                        // obtain Fragment
                        // using external id
//                        ScholarInter inter = FenixFramework.getDomainObject(d.get(this.ID));
//                        Fragment fragment = inter.getFragment();
                        ScholarInterDto inter = VirtualRequiresInterface.getInstance().getScholarInterbyExternalId(d.get(this.ID));
                        FragmentDto fragment  = VirtualRequiresInterface.getInstance().getFragmentByXmlId(inter.getFragmentXmlId());

                        String tweetTextWithoutHttp = removeHttpFromTweetText(obj);

                        // remove emojis, etc
                        String regex = "[^\\p{L}\\p{N}\\p{P}\\p{Z}]";
                        Pattern pattern = Pattern.compile(regex, Pattern.UNICODE_CHARACTER_CLASS);

                        Matcher matcher = pattern.matcher(tweetTextWithoutHttp);
                        String cleanTweetText = matcher.replaceAll("");
                        cleanTweetText = removeEmojiAndSymbolFromString(cleanTweetText);

                        matcher = pattern.matcher((String) obj.get("location"));
                        String cleanTeeetLocation = matcher.replaceAll("");
                        cleanTeeetLocation = removeEmojiAndSymbolFromString(cleanTeeetLocation);

                        matcher = pattern.matcher((String) obj.get("country"));
                        String cleanTeeetCountry = matcher.replaceAll("");
                        cleanTeeetCountry = removeEmojiAndSymbolFromString(cleanTeeetCountry);

                        new TwitterCitation(fragment, (String) obj.get("tweetURL"), (String) obj.get("date"),
                                d.get(this.TEXT), cleanTweetText, (long) obj.get("tweetID"), cleanTeeetLocation,
                                cleanTeeetCountry, (String) obj.get("username"), (String) obj.get("profURL"),
                                (String) obj.get("profImg"));
                    }

                }
            }
            idxReader.close();
            directory.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Atomic(mode = TxMode.WRITE)
    private void updateLastTwitterId(File fileEntry, JSONObject obj) {
        if ((long) obj.get("tweetID") > VirtualModule.getInstance().getLastTwitterID().getLastTwitterID(fileEntry.getName())) {
            VirtualModule.getInstance().getLastTwitterID().updateLastTwitterID(fileEntry.getName(), (long) obj.get("tweetID"));
        }
    }

    private String removeHttpFromTweetText(JSONObject obj) {
        String tweetText = (String) obj.get("text");
        String tweetTextWithoutHttp = tweetText;

        // removing "http" from tweet text
        if (tweetText.contains("http")) {
            int httpIndex = tweetText.indexOf("http");
            tweetTextWithoutHttp = tweetText.substring(0, httpIndex);
        }
        return tweetTextWithoutHttp;
    }

    private String removeEmojiAndSymbolFromString(String content) throws UnsupportedEncodingException {
        String utf8tweet = "";

        byte[] utf8Bytes = content.getBytes("UTF-8");
        utf8tweet = new String(utf8Bytes, "UTF-8");

        Pattern unicodeOutliers =
                Pattern.compile(
                        "[\ud83c\udc00-\ud83c\udfff]|[\ud83d\udc00-\ud83d\udfff]|[\u2600-\u27ff]",
                        Pattern.UNICODE_CASE |
                                Pattern.CANON_EQ |
                                Pattern.CASE_INSENSITIVE
                );
        Matcher unicodeOutlierMatcher = unicodeOutliers.matcher(utf8tweet);

        utf8tweet = unicodeOutlierMatcher.replaceAll(" ");
        return utf8tweet;
    }

    @Atomic
    private void printLastTwitterIdsAndFiles() {
        this.logger.debug("VirtualModule Book:{}, {}", VirtualModule.getInstance().getLastTwitterID().getLastBookParsedFile(),
                VirtualModule.getInstance().getLastTwitterID().getBookLastTwitterID());
        this.logger.debug("VirtualModule Bernardo:{}, {}", VirtualModule.getInstance().getLastTwitterID().getLastBernardoParsedFile(),
                VirtualModule.getInstance().getLastTwitterID().getBernardoLastTwitterID());
        this.logger.debug("VirtualModule Vicente:{}, {}", VirtualModule.getInstance().getLastTwitterID().getLastVicenteParsedFile(),
                VirtualModule.getInstance().getLastTwitterID().getVicenteLastTwitterID());
        this.logger.debug("VirtualModule Pessoa:{}, {}", VirtualModule.getInstance().getLastTwitterID().getLastPessoaParsedFile(),
                VirtualModule.getInstance().getLastTwitterID().getPessoaLastTwitterID());
    }

//    @Atomic(mode = TxMode.WRITE)
//    private void createInfoRanges() {
//        for (Citation citation : VirtualModule.getInstance().getCitationSet()) {
//            if (citation.getInfoRangeSet().isEmpty()) {
//                Fragment citationFragment = citation.getFragment();
//                Set<ScholarInter> inters = new HashSet<>(citationFragment.getScholarInterSet());
//
//                for (ScholarInter inter : inters) {
//                    createInfoRange(inter, citation);
//                }
//            }
//        }
//    }

    @Atomic(mode = TxMode.WRITE)
    private void createInfoRanges() {
        for (CitationDto citation : VirtualRequiresInterface.getInstance().getCitationSet()) {
            if (citation.isHasNoInfoRange()) {
                FragmentDto citationFragment = VirtualRequiresInterface.getInstance().getFragmentByXmlId(citation.getFragmentXmlId());
                Set<ScholarInterDto> inters = new HashSet<>(citationFragment.getScholarInterDtoSet());

                for (ScholarInterDto inter : inters) {
                    createInfoRange(inter, citation);
                }
            }
        }
    }

    private void createInfoRange(ScholarInterDto inter, CitationDto citation) {
        String htmlTransc = getHtmlTransc(inter);

        if (citation instanceof CitationDto) {
//            List<String> result = patternFinding(htmlTransc, ((TwitterCitationDto) citation).getTweetText());
            TwitterCitation twitterCitation = new TwitterCitation(citation);
            List<String> result = patternFinding(htmlTransc, twitterCitation.getTweetText());


            String infoQuote = result.get(0);
            int htmlStart = Integer.parseInt(result.get(1));
            int htmlEnd = Integer.parseInt(result.get(2));
            int numOfPStart = Integer.parseInt(result.get(3));
            int numOfPEnd = Integer.parseInt(result.get(4));

            if (htmlStart != -1 && htmlEnd != -1 && infoQuote.trim() != ""
                    && !startBiggerThanEnd(htmlStart, htmlEnd, numOfPStart, numOfPEnd)) {

                String infoText = createInfoText(citation);

//                new InfoRange(citation, inter, "/div[1]/div[1]/p[" + numOfPStart + "]", htmlStart,
//                        "/div[1]/div[1]/p[" + numOfPEnd + "]", htmlEnd, infoQuote, infoText);

                VirtualRequiresInterface.getInstance().createInfoRange(citation.getId(), inter.getXmlId(), "/div[1]/div[1]/p[" + numOfPStart + "]", htmlStart,
                        "/div[1]/div[1]/p[" + numOfPEnd + "]", htmlEnd, infoQuote, infoText);
            }
        }
    }

    private String createInfoText(CitationDto citation) {

        TwitterCitation twitterCitation = new TwitterCitation(citation);

        // concatenation of meta information
        String sourceLink = citation.getSourceLink();
        String date = citation.getDate();
        String tweetID = Long.toString(citation.getId());
        String location = twitterCitation.getLocation();
        String country = twitterCitation.getCountry();
        String username = twitterCitation.getUsername();
        String userProfileURL = twitterCitation.getUserProfileURL();

        String infoText;

        // complete info text
        // infoText = "SOURCE LINK: " + sourceLink + "\n" + "DATE: " + date + "\n" +
        // "TWEET ID: " + tweetID + "\n"
        // + "COUNTRY: " + country + "\n" + "LOCATION: " + location + "\n" + "USERNAME:"
        // + username + "\n"
        // + "USER PROFILE: " + userProfileURL;

        // short info text
        infoText = "LINK: " + sourceLink + "\n" + "DATA: " + date + "\n";
        if (!country.equals("unknown")) {
            infoText += "PAÍS: " + country;
        }

        return infoText;
    }

    private String getHtmlTransc(ScholarInterDto inter) {
       return VirtualRequiresInterface.getInstance().getWriteFromPlainHtmlWriter4OneInter(inter.getXmlId(), false);
    }

    public boolean startBiggerThanEnd(int htmlStart, int htmlEnd, int numOfPStart, int numOfPEnd) {
        return htmlStart > htmlEnd && numOfPStart == numOfPEnd;
    }

    public String convertFirstCharToUpperCaseInSentence(String str) {
        // Create a char array of given String
        char[] ch = str.toCharArray();
        for (int i = 0; i < str.length(); i++) {

            // If first character of a word is found
            if (i == 0 && ch[i] != ' ' || ch[i] != ' ' && ch[i - 1] == ' ') {

                // If it is in lower-case
                if (ch[i] >= 'a' && ch[i] <= 'z') {

                    // Convert into Upper-case
                    ch[i] = (char) (ch[i] - 'a' + 'A');
                }
            }

            // If apart from first character
            // Any one is in Upper-case
            else if (ch[i] >= 'A' && ch[i] <= 'Z') {
                // Convert into Lower-Case
                ch[i] = (char) (ch[i] + 'a' - 'A');
            }
        }

        // Convert the char array to equivalent String
        String st = new String(ch);
        return st;
    }

    public String cleanTweetText(String originalTweetText) {
        String result = originalTweetText.toLowerCase().replaceAll("[\"*«»“”()';]", "");
        result = result.replace("\\n", " ");
        result = result.replace("...", " ");

        // não posso por em variáveis pq o tamanho do texto
        // vai sendo encurtado no ciclo for
        // int resultLen = result.length();
        // int lastCharPos = resultLen - 1;

        // apagar apenas os hífenes e pontos que não fizerem parte de palavras
        String charSet = "-.,;?!q"; // 'q' porque muitas pessoas escrevem 'q' em vez de "que"
        for (int i = 0; i < result.length(); i++) {
            char c = result.charAt(i);
            if (charSet.indexOf(c) != -1) {
                result = cleanCharFromString(c, result, i, result.length() - 1);
            }
        }
        return result;
    }

    private String capitalizeFirstWord(String sentence) {
        return sentence.substring(0, 1).toUpperCase() + sentence.substring(1);
    }

    public List<String> patternFinding(String text, String tweet) {
//		logger.debug("------------------------------ PATTERN FINDING ALGORITHM-------------------------");
//		logger.debug("ORIGINAL TWEET TEXT: " + tweet);

        // é chato pôr o text é lowercase pq estamos a adulterar a informação original,
        // experimentar outra distance em vez do Jaro
        text = text.toLowerCase();
        // o "clean" já mete o tweet em lowerCase
        tweet = cleanTweetText(tweet);

//		this.logger.debug("CLEANED TWEET TEXT: " + tweet);

        // variables updated over iteration
        int start = -1; // -1 means that the pattern was not found, either for start and end
        int end = -1;
        int offset = 0;
        String patternFound = "";

        // parameters that can be adjusted
        int window = this.WINDOW_THRESHOLD;
        double jaroThreshold = 0.9;
        int startCorrectParam = 3; // parâmetro utilizado na correção da start position

        // algorithm
        int count = 0; // aux counter to check if we reach the minimum value set by "window" variable
        outerloop:
        for (String initialWord : tweet.split("\\s+")) {
            for (String word : initialWord.split(",")) {
                offset = Math.max(start, end);
                if (offset == -1) {
                    offset = 0;
                }

                List<String> info = maxJaroValue(text.substring(offset), word);
                String wordFound = info.get(0);
                double jaroValue = Double.parseDouble(info.get(1));

                // logger.debug("tweet word: " + word);
                // logger.debug("text word: " + wordFound);

                // a palavra tem de existir no texto e estar à frente do offset!
                // primeira palavra encontrada
                if (jaroValue > jaroThreshold && text.indexOf(wordFound, offset) != -1) {
                    // logger.debug(" text contains this word");
                    // logger.debug(Double.toString(jaroValue));

                    // é só updated uma vez e é quando o início começa bem
                    if (count == 0) {
                        // é só updated uma vez e é quando o início começa bem
                        start = text.indexOf(wordFound, offset);
                        patternFound += word + " ";
                        count = 1;
                    }
                    // restantes palavras encontradas
                    // vai sendo constantemente updated enquanto corre bem
                    else {
                        // entra neste if para dar o update exato do start
                        // pq a primeira palavra do padrão pode ocorrer várias vezes no texto antes de
                        // ocorrer no padrão
                        // o mais correto seria fazer quando count==1 (pq é quando já recolhemos pelo
                        // menos uma palavra)
                        // mas como o offset só é updated no início de cada ciclo temos de esperar uma
                        // iteração
                        if (count == startCorrectParam) {
                            // logger.debug(" padrão até agora: " + patternFound);

                            // este update ao start dá bug quando as palavras iniciais do padrão aparecem
                            // antes do padrão
                            String[] splits = patternFound.split(" ");
                            String firstWordOfPatternFound = splits[0];
                            String lastWordOfPatternFound = splits[splits.length - 1];

                            start = text.lastIndexOf(firstWordOfPatternFound, offset - lastWordOfPatternFound.length());
                        }
                        end = text.indexOf(wordFound, offset) + wordFound.length();
                        // logger.debug(" a palavra encontrada no Texto foi: " + wordFound);
                        patternFound += word + " ";
                        count++;
                    }
                }
                // caso em q a palavra não existe no texto
                else {
                    // logger.debug(" text DOES NOT contains this word");
                    // logger.debug(Double.toString(jaroValue));
                    if (count < window) { // significa que não fizémos o número mínimo de palavras seguidas, logo é dar
                        // reset!!
                        count = 0;
                        start = -1;
                        end = -1;
                        patternFound = "";
                        // logger.debug(" dei reset ao count, next word!");
                    } else {
                        // logger.debug(" vou dar break pq já garanti a window");
                        break outerloop;
                    }
                }
                // logger.debug(" count: " + count);
            }
        }

        // this is the case where the pattern exists (start !=-1) but the window was not
        // fulfilled
        if (count < window && start != -1) {
            start = -1;
            end = -1;
            patternFound = "";
        }

        int numOfPStart = -1;
        int numOfPEnd = -1;
        int htmlStart = -1;
        int htmlEnd = -1;

        int earlyStart = -1;
        int laterEnd = -1;

        String prefix = "";
        String suffix = "";

        if (start != -1 && end != -1) {
            // HTML treatment
            numOfPStart = 1 + countOccurencesOfSubstring(text, "<p", start); // +1 porque o getTranscription não traz o
            // primeiro <p
            numOfPEnd = 1 + countOccurencesOfSubstring(text, "<p", end); // +1 porque o getTranscription não traz o
            // primeiro <p

            htmlStart = start - text.lastIndexOf("\">", start) - 2; // -2, para compensar
            htmlEnd = end - text.lastIndexOf("\">", end) - 2; // -2, para compensar

            // logger.debug("htmlStart: " + htmlStart);
            // logger.debug("htmlEnd: " + htmlEnd);

            // logger.debug("index of >: " + text.lastIndexOf("\">", start));
            // logger.debug("index of <: " + text.indexOf("<", end));
            //
            // logger.debug("\n");
            //
            // logger.debug("start: " + start);
            // logger.debug("end: " + end);
            //
            // logger.debug("\n");
            //
            // logger.debug("last dot: " + text.lastIndexOf(".", start));
            // logger.debug("next dot: " + text.indexOf(".", end));
            //
            // logger.debug("\n");

            // dots solution
            earlyStart = htmlStart;
            laterEnd = htmlEnd;

            if (text.lastIndexOf(".", start) > text.lastIndexOf("\">", start)) {
                // para cobrir a frase até ao ponto final anterior é fazer
                earlyStart = text.lastIndexOf(".", start) - text.lastIndexOf("\">", start) - 2;
                // logger.debug("earlyStart: " + earlyStart);
                // prefix = text.substring(text.lastIndexOf(".", start) + 1, start);
                // logger.debug("prefix: " + prefix);
            }

            if (text.indexOf(".", end) < text.indexOf("<", end)) {
                // para cobrir a frase até ao ponto final seguinte é fazer
                laterEnd = text.indexOf(".", end) - text.lastIndexOf("\">", start) - 2;
                // logger.debug("laterEnd: " + laterEnd);
                // suffix = text.substring(end, text.indexOf(".", end));
                // logger.debug("suffix: " + suffix);
            }

        }

        // logger.debug("earlyStart: " + earlyStart);
        // logger.debug("laterEnd: " + laterEnd);
        //
        // logger.debug("original pattern found: " + patternFound);

        // patternFound = prefix + patternFound + suffix;
        //
        // logger.debug("modified pattern found: " + patternFound);

        patternFound = patternFound.trim();

        // converts the first letter of each sentence to upper case
        String upperPattern = "";
        if (patternFound != "") {
            String[] patternSplit = patternFound.split("\\.\\s+");
            // logger.debug("length do split: " + patternSplit.length);
            for (String s : patternSplit) {
                // logger.debug("string s: " + s);
                upperPattern += this.capitalizeFirstWord(s) + ". ";
            }

        }

        if (upperPattern != "") {
            upperPattern = upperPattern.substring(0, upperPattern.length() - 2);
        }
        // logger.debug("UPPER PATTERN: " + upperPattern);

        List<String> result = new ArrayList<>();
        result.add(upperPattern);
        result.add(String.valueOf(earlyStart));
        result.add(String.valueOf(laterEnd));
        result.add(String.valueOf(numOfPStart));
        result.add(String.valueOf(numOfPEnd));

        return result;
    }

    public int lastIndexOfCapitalLetter(String str, int auxPos) {
        for (int i = auxPos; i >= 0; i--) {
            if (Character.isUpperCase(str.charAt(i))) {
                return i;
            }
        }
        return -1;
    }

    @Atomic
    private long getLastTwitterId(File fileEntry) {
        long tempMaxID = VirtualModule.getInstance().getLastTwitterID().getLastTwitterID(fileEntry.getName());
        return tempMaxID;
    }

    // returns max jaro value between a word in the pattern and every word in the
    // text
    public List<String> maxJaroValue(String text, String wordToFind) {
        JaroWinklerDistance jaro = new JaroWinklerDistance();
        double maxJaroValue = 0.0;
        String wordFound = "";
        for (String textWord : text.split("\\s+")) {
            if (textWord.contains("</p>")) {
                textWord = textWord.substring(0, textWord.indexOf("</p>"));
            }
            if (jaro.apply(textWord, wordToFind) > maxJaroValue) {
                maxJaroValue = jaro.apply(textWord, wordToFind);
                wordFound = textWord;
            }
        }

        List<String> info = new ArrayList<>();
        info.add(wordFound);
        info.add(String.valueOf(maxJaroValue));
        return info;
    }

    private String cleanCharFromString(char charToClean, String s, int position, int lastCharPos) {
        // limpar hífenes que tenham espaços em branco à esquerda ou à direita
        if (charToClean == '-') {
            s = replaceChar(s, position, lastCharPos);
        }
        // limpar pontos que tenham espaços em branco à esquerda e à direita
        else if (charToClean == '.') {
            s = replaceDotChar(s, position, lastCharPos);
        }
        // limpar pontos que tenham ponto é vírgula em branco à esquerda e à direita
        else if (charToClean == ';') {
            s = replaceChar(s, position, lastCharPos);
        }
        // limpar vírgulas que tenham espaços em branco à esquerda e à direita
        else if (charToClean == ',') {
            s = replaceChar(s, position, lastCharPos);
        }
        // limpar pontos de interrogação que tenham espaços em branco à esquerda e à
        // direita
        else if (charToClean == '?') {
            s = replaceChar(s, position, lastCharPos);
        }
        // limpar pontos de exclamação que tenham espaços em branco à esquerda e à
        // direita
        else if (charToClean == '!') {
            s = replaceChar(s, position, lastCharPos);
        }
        // substituir as ocorrências da letra 'q' com espaços à esquerda e à direita por
        // "que"
        else if (charToClean == 'q') {
            if (position != 0) {
                if (s.charAt(position - 1) == ' ' && position != lastCharPos && s.charAt(position + 1) == ' ') {
                    s = s.substring(0, position) + "que" + s.substring(position + 1);
                }
            }
        }
        return s;
    }

    private String replaceChar(String s, int position, int lastCharPos) {
        if (position != 0) {
            if (s.charAt(position - 1) == ' ' && position != lastCharPos && s.charAt(position + 1) == ' ') {
                s = s.substring(0, position) + ' ' + s.substring(position + 1);
            }
        }
        return s;
    }

    // caso específico do ponto final
    private String replaceDotChar(String s, int position, int lastCharPos) {
        if (position != 0) {
            if (s.charAt(position - 1) == ' ' && position != lastCharPos && s.charAt(position + 1) == ' ') {
                s = s.substring(0, position) + ' ' + s.substring(position + 1);
            }
        }
        // caso em q o . vem mesmo no início da frase
        else if (position == 0) {
//			this.logger.debug("ENTREI NO IF EM QUE O . VEM NA POSITION 0");
            if (s.charAt(position + 1) == ' ') {
                s = s.substring(position + 1);
            }
        }
        return s;
    }

    private void searchQueryParser(String query)
            throws ParseException, org.apache.lucene.queryparser.classic.ParseException, IOException {
        Query parsedQuery = this.queryParser.parse(QueryParser.escape(query)); // escape foi a solução porque ele
        // stressava
        // com o EOF
        searchIndexAndDisplayResults(parsedQuery);
    }

    private void searchIndexAndDisplayResults(Query query) {
        try {
            int hitsPerPage = 5;
            Directory directory = new NIOFSDirectory(this.docDir);
            IndexReader idxReader = DirectoryReader.open(directory);
            IndexSearcher idxSearcher = new IndexSearcher(idxReader);

            ScoreDoc[] hits = idxSearcher.search(query, hitsPerPage).scoreDocs;
            if (hits.length > 0) {
                int docId = hits[0].doc;
                float score = hits[0].score;
                if (score > 30) {
                    Document d = idxSearcher.doc(docId);

                }
            }
            directory.close();
            idxReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fuzzy Query - multiple terms! pesquisa tem de ser exata
    public void searchSpanQuery(String words) {
        String[] split = words.split("\\s+");
        int len = split.length;
        SpanQuery[] clauses = new SpanQuery[len];
        for (int i = 0; i < len; i++) {
            clauses[i] = new SpanMultiTermQueryWrapper(new FuzzyQuery(new Term(this.TEXT, split[i])));
        }
        SpanNearQuery query = new SpanNearQuery(clauses, 0, true);

        searchIndexAndDisplayResults(query);
    }

    // Fuzzy SearchProcessor - Pesquisa tem de ser exata
    // SearchProcessor for fragments with a set of words similar to input
    // Fuzzy set for a minimum edition edition of 1
    public void fuzzySearch(String words)
            throws ParseException, org.apache.lucene.queryparser.classic.ParseException, IOException {
        String[] split = words.split("\\s+");
        double fuzzy = 1; // default = 0.5
        String query = "" + split[0] + "~" + fuzzy;
        int len = split.length;

        for (int i = 1; i < len; i++) {
            query += " AND " + split[i] + "~" + fuzzy;
        }
        searchQueryParser(query);
    }

    // SearchProcessor for fragments with a set of equal to inputs
    private String absoluteSearch(String words) {
        String[] split = words.split("\\s+");
        String query = "" + split[0];
        int len = split.length;

        for (int i = 1; i < len; i++) {
            query += " AND " + split[i];
        }
        return query;
    }

    private void searchSingleTerm(String field, String termText) {
        Term term = new Term(field, termText);
        TermQuery termQuery = new TermQuery(term);

        searchIndexAndDisplayResults(termQuery);
    }

    public int countOccurencesOfSubstring(String string, String substring, int subsStartPos) {
        int count = 0;
        int idx = 0;

        while ((idx = string.indexOf(substring, idx)) != -1 && idx < subsStartPos) {
            idx++;
            count++;
        }

        return count;
    }
}


import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;

import pt.ist.socialsoftware.edition.notification.utils.PropertiesManager;
import twitter4j.*;
import twitter4j.Query.ResultType;
import twitter4j.conf.ConfigurationBuilder;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class FetchCitationsFromTwitter {

    private final Logger logger = LoggerFactory.getLogger(FetchCitationsFromTwitter.class);
    private final int TWEETS_PER_QUERY = 100;
    private final int MAX_QUERIES = 180; // Queries = pages obtained (máximo empírico até agora foi 100 páginas, máximo
    // = 180)
    private final Map<String, String> TERMS_MAP = createTermsMap();

    @Atomic
    public void fetch() throws IOException {
        // Twitter twitter = getTwitterinstance(); //uses configuration builder
        Twitter twitter = new TwitterFactory().getInstance(); // uses twitter4j.properties

        this.logger.debug("Beginning of Fetch Citations");

        for (String term : this.TERMS_MAP.keySet()) {
            String fileName = this.TERMS_MAP.get(term);

            int numTweets = 0;
            long maxID = -1;

            BufferedWriter bw = null;
            FileWriter fw = null;
            File file;
            try {
                String timeStamp = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
                String exportDir = PropertiesManager.getProperties().getProperty("social.aware.dir");
                file = new File(exportDir + "twitter-" + fileName + "-" + timeStamp + ".json");

                fw = new FileWriter(file);
                bw = new BufferedWriter(fw);

                // This returns all the various rate limits in effect for us with the Twitter
                // API
                Map<String, RateLimitStatus> rateLimitStatus = twitter.getRateLimitStatus("search");
                // This finds the rate limit specifically for doing the search API call we use
                // in this program
                RateLimitStatus searchTweetsRateLimit = rateLimitStatus.get("/search/tweets");
                // System.out.printf("You have %d calls remaining out of %d, Limit resets in %d
                // seconds (= %f minutes)\n",
                // searchTweetsRateLimit.getRemaining(), searchTweetsRateLimit.getLimit(),
                // searchTweetsRateLimit.getSecondsUntilReset(),
                // searchTweetsRateLimit.getSecondsUntilReset() / 60.0);

                // This is the loop that retrieve multiple blocks of tweets from Twitter
                for (int queryNumber = 0; queryNumber < this.MAX_QUERIES; queryNumber++) {
                    // System.out.printf("\n\n!!! Starting loop %d\n\n", queryNumber);

                    // Do we need to delay because we've already hit our rate limits?
                    if (searchTweetsRateLimit.getRemaining() == 0) {
                        // Yes we do, unfortunately ...
                        // System.out.printf("!!! Sleeping for %d seconds due to rate limits\n",
                        // searchTweetsRateLimit.getSecondsUntilReset());

                        // If you sleep exactly the number of seconds, you can make your query a bit too
                        // early
                        // and still get an error for exceeding rate limitations
                        //
                        // Adding two seconds seems to do the trick. Sadly, even just adding one second
                        // still triggers a
                        // rate limit exception more often than not. I have no idea why, and I know from
                        // a Comp Sci
                        // standpoint this is really bad, but just add in 2 seconds and go about your
                        // business. Or else.
                        try {
                            Thread.sleep((searchTweetsRateLimit.getSecondsUntilReset() + 2) * 1000l);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                    Query q = new Query(term); // SearchProcessor for tweets that contains this term
                    q.setCount(this.TWEETS_PER_QUERY); // How many tweets, max, to retrieve
                    q.setResultType(ResultType.recent); // Get all tweets
                    q.setLang("pt");

                    // If maxID is -1, then this is our first call and we do not want to tell
                    // Twitter what the maximum
                    // tweet id is we want to retrieve. But if it is not -1, then it represents the
                    // lowest tweet ID
                    // we've seen, so we want to start at it-1 (if we start at maxID, we would see
                    // the lowest tweet
                    // a second time...
                    if (maxID != -1) {
                        q.setMaxId(maxID - 1);
                    }

                    // This actually does the search on Twitter and makes the call across the
                    // network
                    QueryResult r = twitter.search(q);

                    // If there are NO tweets in the result set, it is Twitter's way of telling us
                    // that there are no
                    // more tweets to be retrieved. Remember that Twitter's search index only
                    // contains about a week's
                    // worth of tweets, and uncommon search terms can run out of week before they
                    // run out of tweets
                    if (r.getTweets().size() == 0) {
                        break; // Nothing? We must be done
                    }

                    // loop through all the tweets and process them. In this sample program, we just
                    // print them
                    // out, but in a real application you might save them to a database, a CSV file,
                    // do some
                    // analysis on them, whatever...
                    // Loop through all the tweets...
                    for (Status s : r.getTweets()) {
                        // Increment our count of tweets retrieved
                        numTweets++;

                        // Keep track of the lowest tweet ID. If you do not do this, you cannot retrieve
                        // multiple
                        // blocks of tweets...
                        if (maxID == -1 || s.getId() < maxID) {
                            maxID = s.getId();
                        }

                        // Do something with the tweet....
                        String text = null;
                        if (s.getRetweetedStatus() != null) {
                            text = s.getRetweetedStatus().getText();
                        } else {
                            text = s.getText();
                        }

                        Place place = s.getPlace();

                        String country = "unknown";
                        if (place != null && !place.getCountry().equals("")) {
                            country = place.getCountry();
                        }

                        String location = s.getUser().getLocation();
                        if (location.equals("")) {
                            location = "unknown";
                        }

                        String username = s.getUser().getScreenName();
                        String tweetURL = "https://twitter.com/" + username + "/status/" + s.getId();
                        String profURL = "https://twitter.com/" + username;

                        String profImg = s.getUser().getBiggerProfileImageURL();

                        String formatedDate = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss").format(s.getCreatedAt());

                        long tweetID = s.getId();

                        boolean isRetweet = s.isRetweet();
                        boolean isRetweeted = s.isRetweeted();
                        int retweetCount = s.getRetweetCount();

                        long originalTweetID = -1L;
                        long currentUserRetID = -1L;
                        if (isRetweet) {
                            originalTweetID = s.getRetweetedStatus().getId();
                            currentUserRetID = s.getCurrentUserRetweetId();
                        }

                        // Writing in json file - JSON version
                        JSONObject obj = new JSONObject();
                        obj.put("date", formatedDate);
                        obj.put("username", username);
                        obj.put("tweetID", tweetID);
                        obj.put("text", text);
                        obj.put("country", country);
                        obj.put("location", location);
                        obj.put("tweetURL", tweetURL);
                        obj.put("profURL", profURL);
                        obj.put("profImg", profImg);

                        obj.put("isRetweet", isRetweet);
                        obj.put("isRetweeted", isRetweeted);
                        obj.put("retweetCount", retweetCount);
                        obj.put("originalTweetID", originalTweetID);
                        obj.put("currentUserRetID", currentUserRetID);

                        bw.write(obj.toString());
                        bw.write("\n");
                    }

                    // As part of what gets returned from Twitter when we make the search API call,
                    // we get an updated
                    // status on rate limits. We save this now so at the top of the loop we can
                    // decide whether we need
                    // to sleep or not before making the next call.
                    searchTweetsRateLimit = r.getRateLimitStatus();
                }
                this.logger.debug("Number of tweets retrieved: " + numTweets);
                System.out.printf("You have %d calls remaining out of %d, Limit resets in %d seconds (= %f minutes)\n",
                        searchTweetsRateLimit.getRemaining(), searchTweetsRateLimit.getLimit(),
                        searchTweetsRateLimit.getSecondsUntilReset(),
                        searchTweetsRateLimit.getSecondsUntilReset() / 60.0);

                this.logger.debug("Acabei de preencher o ficheiro: " + "twitter-" + fileName + "-" + timeStamp + ".json");

                bw.close();
                fw.close();

            } catch (IOException ioE) {
                ioE.printStackTrace();
            } catch (TwitterException te) {
                te.printStackTrace();
            }
        }
        this.logger.debug("End of Fetch Citations");
    }

    // may be useful
    public String getTweetInfoInStringFormat(Status s) {
        String toWrite = "";

        String text = null;
        if (s.getRetweetedStatus() != null) {
            text = s.getRetweetedStatus().getText();
        } else {
            text = s.getText();
        }

        Place place = s.getPlace();

        String country = "unknown";
        if (place != null && !place.getCountry().equals("")) {
            country = place.getCountry();
        }

        String location = s.getUser().getLocation();
        if (location.equals("")) {
            location = "unknown";
        }

        String username = s.getUser().getScreenName();
        String tweetURL = "https://twitter.com/" + username + "/status/" + s.getId();
        String profURL = "https://twitter.com/" + username;
        String profImg = s.getUser().getBiggerProfileImageURL();

        String formatedDate = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss").format(s.getCreatedAt());

        long tweetID = s.getId();

        boolean isRetweet = s.isRetweet();
        boolean isRetweeted = s.isRetweeted();
        int retweetCount = s.getRetweetCount();

        long originalTweetID = -1L;
        long currentUserRetID = -1L;
        if (isRetweet) {
            originalTweetID = s.getRetweetedStatus().getId();
            currentUserRetID = s.getCurrentUserRetweetId();
        }

        toWrite = "\t At " + formatedDate + ", @" + username + " (id: " + tweetID + ")" + "\n" + "said: " + text + "\n"
                + "country: " + country + "\n" + "location: " + location + "\n" + "tweet URL: " + tweetURL + "\n"
                + "profile URL: " + profURL + "\n" + "profile Picture: " + profImg + "\n" + "isRetweet: " + isRetweet
                + "\n" + "isRetweeted: " + isRetweeted + "\n" + "retweetCount: " + retweetCount + "\n"
                + "originalTweetID: " + originalTweetID + "\n" + "currentUserRetID: " + currentUserRetID + "\n"
                + "############################" + "\n";

        return toWrite;
    }

    public Map<String, String> createTermsMap() {
        Map<String, String> termsMap = new HashMap<>();
        termsMap.put("Livro do Desassossego", "livro");
        termsMap.put("Fernando Pessoa", "fp");
        termsMap.put("Bernardo Soares", "bernardo");
        termsMap.put("Vicente Guedes", "vicente");
        return termsMap;
    }

    public Status getTweetById(long id, Twitter t) {
        Status s = null;
        try {
            s = t.showStatus(id);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        } catch (TwitterException e) {
            e.printStackTrace();
        }
        return s;
    }

    public Twitter getTwitterinstance() {
        /**
         * if not using properties file, we can set access token by following way
         */
        ConfigurationBuilder cb = new ConfigurationBuilder();
        cb.setDebugEnabled(false).setOAuthConsumerKey("ije0NGcyFrXfDScLeCbwz2GQt")
                .setOAuthConsumerSecret("AibLMO2mbyFeUjyyjDxH1aftDoJjOF1UZXU8OuM76dDuJ3stdC")
                .setOAuthAccessToken("922101092938342400-IF3ButS0cnh76TsOiBhr8aZopVHQkTv")
                .setOAuthAccessTokenSecret("7boYO5EISBvC2WfWBeuEIgqEOEvLWDGTUgGsG2btGL2cx").setTweetModeExtended(true)
                .setPrettyDebugEnabled(false);

        TwitterFactory tf = new TwitterFactory(cb.build());
        Twitter twitter = tf.getInstance();
        return twitter;
    }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import java.util.Arrays;

public class JaroWinklerDistance {
    /**
     * Represents a failed index search.
     */
    public static final int INDEX_NOT_FOUND = -1;

    /**
     * Find the Jaro Winkler Distance which indicates the similarity score between
     * two CharSequences.
     *
     * <pre>
     * distance.apply(null, null)          = IllegalArgumentException
     * distance.apply("","")               = 0.0
     * distance.apply("","a")              = 0.0
     * distance.apply("aaapppp", "")       = 0.0
     * distance.apply("frog", "fog")       = 0.93
     * distance.apply("fly", "ant")        = 0.0
     * distance.apply("elephant", "hippo") = 0.44
     * distance.apply("hippo", "elephant") = 0.44
     * distance.apply("hippo", "zzzzzzzz") = 0.0
     * distance.apply("hello", "hallo")    = 0.88
     * distance.apply("ABC Corporation", "ABC Corp") = 0.93
     * distance.apply("D N H Enterprises Inc", "D &amp; H Enterprises, Inc.") = 0.95
     * distance.apply("My Gym Children's Fitness Center", "My Gym. Childrens Fitness") = 0.92
     * distance.apply("PENNSYLVANIA", "PENNCISYLVNIA")    = 0.88
     * </pre>
     *
     * @param left  the first String, must not be null
     * @param right the second String, must not be null
     * @return result distance
     * @throws IllegalArgumentException if either String input {@code null}
     */
    public Double apply(CharSequence left, CharSequence right) {
        double defaultScalingFactor = 0.1;

        if (left == null || right == null) {
            throw new IllegalArgumentException("Strings must not be null");
        }

        int[] mtp = matches(left, right);
        double m = mtp[0];
        if (m == 0) {
            return 0D;
        }
        double j = (m / left.length() + m / right.length() + (m - mtp[1]) / m) / 3;
        double jw = j < 0.7D ? j : j + Math.min(defaultScalingFactor, 1D / mtp[3]) * mtp[2] * (1D - j);
        return jw;
    }

    /**
     * This method returns the Jaro-Winkler string matches, transpositions, prefix,
     * max array.
     *
     * @param first  the first string to be matched
     * @param second the second string to be matched
     * @return mtp array containing: matches, transpositions, prefix, and max length
     */
    protected static int[] matches(CharSequence first, CharSequence second) {
        CharSequence max;
        CharSequence min;
        if (first.length() > second.length()) {
            max = first;
            min = second;
        } else {
            max = second;
            min = first;
        }
        int range = Math.max(max.length() / 2 - 1, 0);
        int[] matchIndexes = new int[min.length()];
        Arrays.fill(matchIndexes, -1);
        boolean[] matchFlags = new boolean[max.length()];
        int matches = 0;
        for (int mi = 0; mi < min.length(); mi++) {
            char c1 = min.charAt(mi);
            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {
                if (!matchFlags[xi] && c1 == max.charAt(xi)) {
                    matchIndexes[mi] = xi;
                    matchFlags[xi] = true;
                    matches++;
                    break;
                }
            }
        }
        char[] ms1 = new char[matches];
        char[] ms2 = new char[matches];
        for (int i = 0, si = 0; i < min.length(); i++) {
            if (matchIndexes[i] != -1) {
                ms1[si] = min.charAt(i);
                si++;
            }
        }
        for (int i = 0, si = 0; i < max.length(); i++) {
            if (matchFlags[i]) {
                ms2[si] = max.charAt(i);
                si++;
            }
        }
        int transpositions = 0;
        for (int mi = 0; mi < ms1.length; mi++) {
            if (ms1[mi] != ms2[mi]) {
                transpositions++;
            }
        }
        int prefix = 0;
        for (int mi = 0; mi < min.length(); mi++) {
            if (first.charAt(mi) == second.charAt(mi)) {
                prefix++;
            } else {
                break;
            }
        }
        return new int[]{matches, transpositions / 2, prefix, max.length()};
    }
}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.virtual.domain.TwitterCitation;
import pt.ist.socialsoftware.edition.virtual.domain.VirtualModule;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class LucenePerformance {

    private final Logger logger = LoggerFactory.getLogger(LucenePerformance.class);

    @Atomic(mode = TxMode.WRITE)
    public void runLivro() throws IOException {
        this.logger.debug("STARTED BOOK PERFORMANCE ANALYSIS");

        String fileSuffix = "livroIDs.txt";
        File file = new File("C:\\Users\\dnf_o\\projetoTese\\ldod\\social\\teste\\" + fileSuffix);

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));

        computePrecisionAndRecall(bufferedReader);

        bufferedReader.close();

        this.logger.debug("FINISHED BOOK PERFORMANCE ANALYSIS");

    }

    @Atomic(mode = TxMode.WRITE)
    public void runBernardo() throws IOException {
        this.logger.debug("STARTED BERNARDO PERFORMANCE ANALYSIS");

        String fileSuffix = "bernardoIDs.txt";
        File file = new File("C:\\Users\\dnf_o\\projetoTese\\ldod\\social\\teste\\" + fileSuffix);

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));

        computePrecisionAndRecall(bufferedReader);

        bufferedReader.close();

        this.logger.debug("FINISHED BERNARDO PERFORMANCE ANALYSIS");
    }

    @Atomic(mode = TxMode.WRITE)
    public void runFP() throws IOException {
        this.logger.debug("STARTED FP PERFORMANCE ANALYSIS");

        String fileSuffix = "fpIDs.txt";
        File file = new File("C:\\Users\\dnf_o\\projetoTese\\ldod\\social\\teste\\" + fileSuffix);

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));

        computePrecisionAndRecall(bufferedReader);

        bufferedReader.close();

        this.logger.debug("FINISHED FP PERFORMANCE ANALYSIS");
    }

    @Atomic(mode = TxMode.WRITE)
    public void runVicente() throws IOException {
        this.logger.debug("STARTED VICENTE PERFORMANCE ANALYSIS");

        String fileSuffix = "vicenteIDs.txt";
        File file = new File("C:\\Users\\dnf_o\\projetoTese\\ldod\\social\\teste\\" + fileSuffix);

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));

        computePrecisionAndRecall(bufferedReader);

        bufferedReader.close();

        this.logger.debug("FINISHED VICENTE PERFORMANCE ANALYSIS");
    }

    private void computePrecisionAndRecall(BufferedReader bufferedReader) throws IOException {
        String line = null;
        int TP = 0;
        int FP = 0;
        int TN = 0;
        int FN = 0;

        // só faz sentido alterar estas variáveis
        // quando a tc != null, senão nem há info ranges
        int jaroTP = 0;
        int jaroFP = 0;
        int jaroTN = 0;
        int jaroFN = 0;

        while ((line = bufferedReader.readLine()) != null) {
            String[] split = line.split(";");
            long id = Long.parseLong(split[0]);
            boolean isCitation = false;
            if (split[1].contains("yes")) {
                isCitation = true;
            }
            TwitterCitation tc = VirtualModule.getInstance().getTwitterCitationByTweetID(id);

            if (tc != null && isCitation) {
                TP++;
                if (!tc.getInfoRangeDtoSet().isEmpty()) {
                    jaroTP++;
                } else {
                    // logger.debug("Tweet ID: " + id + " is a Jaro FN!!");
                    jaroFN++;
                }
            } else if (tc != null && !isCitation) {
                FP++;
                this.logger.debug("Tweet ID: " + id + " is FP");
                if (!tc.getInfoRangeDtoSet().isEmpty()) {
                    jaroFP++;
                    // logger.debug("Tweet ID: " + id + " is a Jaro FP!!");
                } else {
                    jaroTN++;
                }
            } else if (tc == null && isCitation) {
                FN++;
                this.logger.debug("Tweet ID: " + id + " is FN");
            } else if (tc == null && !isCitation) {
                TN++;
            }

        }

        this.logger.debug("\nTP: " + TP + "\n" + "FP: " + FP + "\n" + "TN: " + TN + "\n" + "FN: " + FN);
        this.logger.debug("+++++++++++++++++++++++++++++++++");

        double precision = (double) TP / (TP + FP);
        double recall = (double) TP / (TP + FN);

        this.logger.debug("Precision = " + precision);
        this.logger.debug("Recall = " + recall + "\n");

        // for (TwitterCitation tc : VirtualModule.getInstance().getAllTwitterCitation()) {
        // logger.debug("Date: " + tc.getDate() + " Tweet ID: " + tc.getTweetID() + "\n"
        // + "Tweet text: "
        // + tc.getTweetText() + "\n");
        // }

        this.logger.debug("==========================================================================");
        this.logger.debug("==========================================================================\n");

        this.logger.debug("\njaroTP: " + jaroTP + "\n" + "jaroFP: " + jaroFP + "\n" + "jaroTN: " + jaroTN + "\n" + "jaroFN: "
                + jaroFN);
        this.logger.debug("+++++++++++++++++++++++++++++++++");

        double jaroPrecision = (double) jaroTP / (jaroTP + jaroFP);
        double jaroRecall = (double) jaroTP / (jaroTP + jaroFN);

        this.logger.debug("JaroPrecision = " + jaroPrecision);
        this.logger.debug("JaroRecall = " + jaroRecall);
    }

}


import org.junit.jupiter.api.Test;
import pt.ist.socialsoftware.edition.recommendation.feature.Vectors;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class VectorsCalculateSimilariryTest {

    @Test
    public void testCalculateSimiliraties() {
        double[] array1 = {1.0, 0.9, 0.8, 0.7};
        double[] array2 = {1.0, 0.9, 0.8, 0.7};
        double calculateSimiliraty1 = Vectors.calculateSimilarity(array1, array2);
        double[] array4 = {0.9, 1.0, 0.9, 0.8,};
        double calculateSimiliraty2 = Vectors.calculateSimilarity(array1, array4);
        assertTrue(calculateSimiliraty1 > calculateSimiliraty2);
        double[] array6 = {0.8, 0.9, 1.0, 0.9,};
        double calculateSimiliraty3 = Vectors.calculateSimilarity(array1, array6);
        assertTrue(calculateSimiliraty2 > calculateSimiliraty3);
    }

    @Test
    public void testCalculateSimiliraty() {
        double[] array1 = {2.0, 0.0, 1.0, 0.0};
        double[] array2 = {2.0, 1.0, 1.0, 1.0};
        double calculateSimiliraty = Vectors.calculateSimilarity(array1, array2);
        assertEquals(calculateSimiliraty, 0.8451542547285165, 0.0000001);
    }

    @Test
    public void testCalculateSimiliratyZeroVector() {
        double[] array1 = {0.0, 0.0, 0.0, 0.0};
        double[] array2 = {0.0, 0.0, 0.0, 0.0};
        double calculateSimiliraty = Vectors.calculateSimilarity(array1, array2);
        assertEquals(calculateSimiliraty, 0.0, 0.0000001);
    }
}
//package recommendation;
//
//import org.apache.lucene.queryparser.classic.ParseException;
//import org.joda.time.LocalDate;
//import org.junit.jupiter.api.*;
//import pt.ist.fenixframework.Atomic;
//import pt.ist.fenixframework.Atomic.TxMode;
//import pt.ist.socialsoftware.edition.ldod.TestLoadUtils;
//import pt.ist.socialsoftware.edition.ldod.frontend.text.FeTextRequiresInterface;
//import pt.ist.socialsoftware.edition.ldod.frontend.virtual.FeVirtualRequiresInterface;
//import pt.ist.socialsoftware.edition.ldod.frontend.virtual.virtualDto.TopicListDTO;
//
//import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionInterDto;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMVirtualEditionInterRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;
//
//
//
//
//import java.io.FileNotFoundException;
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.HashSet;
//import java.util.List;
//import java.util.Set;
//import java.util.stream.Collectors;
//
//import static org.junit.Assert.assertTrue;
//
//public class VSMVirtualEditionInterRecomenderPerformanceTest {
//    private static String USER_ARS = "ars";
//    public static final String TEST_PIZARRO_ACRONYM = "TestPizarroRecommendations";
//    private static VirtualEditionDto pizarroVirtualEdition = null;
//    private static Set<VirtualEditionInterDto> pizarroVirtualEditionInters = null;
//    private static VirtualEditionDto zenithVirtualEdition = null;
//    private static Set<VirtualEditionInterDto> zenithVirtualEditionInters = null;
//    private static VirtualEditionDto cunhaVirtualEdition = null;
//    private static Set<VirtualEditionInterDto> cunhaVirtualEditionInters = null;
//    private static VSMRecommender<pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionInterDto> recommender;
//
//    private FeTextRequiresInterface feTextRequiresInterface;
//    private FeVirtualRequiresInterface feVirtualRequiresInterface;
//
//    // Assuming that the 4 expert editions, the archive edition and user ars are
//    // in the database @BeforeAll
//    @BeforeEach
//    @Atomic(mode = TxMode.WRITE)
//    protected void setUp() throws FileNotFoundException {
//        TestLoadUtils.setUpDatabaseWithCorpus();
//        String[] fragments = {"001.xml", "002.xml", "003.xml"};
//        TestLoadUtils.loadFragments(fragments);
//
//        feTextRequiresInterface = new FeTextRequiresInterface();
//        feVirtualRequiresInterface = new FeVirtualRequiresInterface();
////        TextModule text = TextModule.getInstance();
////        ExpertEdition pizarroEdition = text.getJPEdition();
////        ExpertEdition zenithEdition = text.getRZEdition();
////        ExpertEdition cunhaEdition = text.getTSCEdition();
//
//        // create pizarro virtual edition
//        feVirtualRequiresInterface.createVirtualEdition(USER_ARS, TEST_PIZARRO_ACRONYM,
//                "TestPizarroRecommendations", LocalDate.now(), true, "JP");
//        pizarroVirtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + TEST_PIZARRO_ACRONYM);
//        pizarroVirtualEditionInters = pizarroVirtualEdition.getIntersSet();
//
//        // create pizarro taxonomy
//        TopicListDTO topicListDTO = null;
//        try {
//            topicListDTO = feVirtualRequiresInterface.generateTopicModeler(USER_ARS, pizarroVirtualEdition.getExternalId(), 50, 6, 11, 100);
//        } catch (IOException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
//        feVirtualRequiresInterface.getVirtualEditionByAcronym(pizarroVirtualEdition.getAcronym()).getTaxonomy().createGeneratedCategories(topicListDTO);
//
//        // create zenith virtual edition
//        feVirtualRequiresInterface.createVirtualEdition(USER_ARS, "TestZenithRecommendations",
//                "TestZenithRecommendations", LocalDate.now(), true, "RZ");
//        zenithVirtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-TestZenithRecommendations");
//        zenithVirtualEditionInters = zenithVirtualEdition.getIntersSet();
//
//        // create cunha virtual edition
//        feVirtualRequiresInterface.createVirtualEdition(USER_ARS, "TestCunhaRecommendations", "TestCunhaRecommendations",
//                LocalDate.now(), true, "TSC");
//        cunhaVirtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-TestCunhaRecommendations");
//        cunhaVirtualEditionInters = cunhaVirtualEdition.getIntersSet();
//
//        // create recommender
//        recommender = new VSMVirtualEditionInterRecommender();
//    }
//
//    @AfterEach
//    @Atomic(mode = TxMode.WRITE)
//    protected void tearDown() {
//        TestLoadUtils.cleanDatabase();
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForAllAsList() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//        properties.add(new DateProperty(1.0));
//        properties.add(new TaxonomyProperty(1.0, "LdoD-" + TEST_PIZARRO_ACRONYM, Property.PropertyCache.OFF));
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList(virtualEditionInter,
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForAllAsListTwo() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = (VirtualEditionInterDto) inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//        properties.add(new DateProperty(1.0));
//        properties.add(new TaxonomyProperty(1.0, "LdoD-" + TEST_PIZARRO_ACRONYM, Property.PropertyCache.OFF));
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForDateAsList() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new DateProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForDateAsListTwo() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new DateProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForHeteronymAsList() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : cunhaVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(cunhaVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForHeteronymAsListTwo() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : cunhaVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(cunhaVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForNotCachedTaxonomyAsList() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TaxonomyProperty(1.0, "LdoD-" + TEST_PIZARRO_ACRONYM, Property.PropertyCache.OFF));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForCachedTaxonomyAsList() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TaxonomyProperty(1.0, "LdoD-" + TEST_PIZARRO_ACRONYM, Property.PropertyCache.ON));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForTextAsListOneAgain() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForTextAsListOneCunha() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : cunhaVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(cunhaVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForTextAsListOneZenith() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : zenithVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(zenithVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForTextAsListOnePizarro() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForTextAsListTwo() throws IOException, ParseException {
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : pizarroVirtualEdition.getIntersSet()) {
//            virtualEditionInter = inter;
//            break;
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        List<VirtualEditionInterDto> result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//
//        result = recommender.getMostSimilarItemsAsList((virtualEditionInter),
//                new HashSet<>(pizarroVirtualEditionInters), properties);
//
//        assertTrue(result.size() != 0);
//    }
//
//}

//package recommendation;
//
//import org.apache.lucene.queryparser.classic.ParseException;
//import org.junit.jupiter.api.AfterAll;
//import org.junit.jupiter.api.BeforeAll;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import pt.ist.fenixframework.Atomic;
//import pt.ist.fenixframework.Atomic.TxMode;
//import pt.ist.socialsoftware.edition.ldod.TestLoadUtils;
//
//import pt.ist.socialsoftware.edition.ldod.frontend.reading.ReadingRecommendation;
//
//import pt.ist.socialsoftware.edition.ldod.frontend.text.FeTextRequiresInterface;
//import pt.ist.socialsoftware.edition.ldod.frontend.text.textDto.ExpertEditionDto;
//import pt.ist.socialsoftware.edition.ldod.frontend.text.textDto.ScholarInterDto;
//import pt.ist.socialsoftware.edition.ldod.frontend.virtual.FeVirtualRequiresInterface;
//
//import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionInterDto;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMVirtualEditionInterRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;
//
//
//import java.io.FileNotFoundException;
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.HashSet;
//import java.util.List;
//import java.util.Set;
//import java.util.stream.Collectors;
//
//import static org.junit.jupiter.api.Assertions.assertFalse;
//
//public class ReadingRecommendationPerformanceTest {
//    public static final String ARCHIVE_EDITION_ACRONYM = "LdoD-Arquivo";
//
//    @BeforeAll
//    @Atomic(mode = TxMode.WRITE)
//    public static void setUpAll() throws FileNotFoundException {
//        TestLoadUtils.setUpDatabaseWithCorpus();
//
//        String[] fragments = {"001.xml", "002.xml", "003.xml"};
//        TestLoadUtils.loadFragments(fragments);
//    }
//
//    @AfterAll
//    @Atomic(mode = TxMode.WRITE)
//    public static void tearDownAll() throws FileNotFoundException {
//        TestLoadUtils.cleanDatabase();
//    }
//
//    // Assuming that the 4 expert editions, the archive edition and user ars are
//    // in the database @BeforeAll
//    @BeforeEach
//    @Atomic(mode = TxMode.WRITE)
//    protected void setUp() {
//
//
//        VirtualEditionDto archiveEdition = (RecommendationRequiresInterface.getInstance().getArchiveEdition());
//        List<VirtualEditionInterDto> archiveVirtualEditionInters = archiveEdition.getSortedVirtualEditionInterDtoList();
//
//        VSMRecommender<pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionInterDto> recommender = new VSMVirtualEditionInterRecommender();
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1));
//        properties.add(new DateProperty(1));
//        properties.add(new TaxonomyProperty(1, ARCHIVE_EDITION_ACRONYM, Property.PropertyCache.ON));
//        properties.add(new TextProperty(1));
//
//        // warm the system in order to create all the caches
//        recommender.getMostSimilarItemsAsList(archiveVirtualEditionInters.get(2),
//                new HashSet<>(archiveVirtualEditionInters), properties);
//
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testSeveralRecommendations() throws IOException, ParseException {
//        ReadingRecommendation recommender = new ReadingRecommendation();
//
//        recommender.setDateWeight(1);
//        recommender.setHeteronymWeight(1);
//        recommender.setTextWeight(1);
//        recommender.setTaxonomyWeight(1);
//
//        ExpertEditionDto pizarroEdition = (new FeTextRequiresInterface().getExpertEditionByAcronym("JP"));
//        ScholarInterDto inter = pizarroEdition.getExpertEditionInters().stream().collect(Collectors.toList())
//                .get(0);
//
//        for (int i = 0; i < 100; i++) {
//            Set<pt.ist.socialsoftware.edition.recommendation.api.textDto.ScholarInterDto> nextInters = recommender.getNextRecommendations(inter.getExternalId());
//            assertFalse(nextInters.isEmpty());
//        }
//
//    }
//
//}

//package recommendation;
//
//import org.apache.lucene.queryparser.classic.ParseException;
//import org.joda.time.LocalDate;
//import org.junit.jupiter.api.AfterEach;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import pt.ist.fenixframework.Atomic;
//import pt.ist.fenixframework.Atomic.TxMode;
//import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
//import pt.ist.socialsoftware.edition.recommendation.api.textDto.FragmentDto;
//import pt.ist.socialsoftware.edition.recommendation.api.textDto.ScholarInterDto;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.CategoryDto;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto;
//import pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionInterDto;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.VSMVirtualEditionInterRecommender;
//import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;
//
//
//import java.io.FileNotFoundException;
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.HashSet;
//import java.util.List;
//import java.util.stream.Collectors;
//
//import static org.junit.Assert.*;
//import static org.junit.jupiter.api.Assertions.assertFalse;
//
//public class VSMVirtualEditionInterRecomenderTest {
//    private static final String ACRONYM = "TestRecommendations";
//    private static String USER_ARS = "ars";
//
//    private static final Logger logger = LoggerFactory.getLogger(VSMVirtualEditionInterRecomenderTest.class);
//    private FeTextRequiresInterface feTextRequiresInterface = new FeTextRequiresInterface();
//    private FeVirtualRequiresInterface feVirtualRequiresInterface = new FeVirtualRequiresInterface();
//
//    private static VSMRecommender<VirtualEditionInterDto> recommender;
//
//    private VirtualEditionDto virtualEdition;
//
//    @AfterEach
//    @Atomic(mode = TxMode.WRITE)
//    protected void tearDown() {
//        TestLoadUtils.cleanDatabase();
//    }
//
//    // Assuming that the 4 expert editions and user ars are in the database
//    @BeforeEach
//    @Atomic(mode = TxMode.WRITE)
//    protected void setUp() throws FileNotFoundException {
//        TestLoadUtils.setUpDatabaseWithCorpus();
//        String[] fragments = {"001.xml", "181.xml", "593.xml"};
//        TestLoadUtils.loadFragments(fragments);
////        ExpertEdition pizarroEdition = TextModule.getInstance().getJPEdition();
//
//        // create virtual edition
//        feVirtualRequiresInterface.createVirtualEdition(USER_ARS, ACRONYM, "Name", LocalDate.now(), true,
//                "JP");
//        this.virtualEdition = feVirtualRequiresInterface.getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//
//        // set open vocabulary taxonomy
//        this.virtualEdition.getTaxonomy().setOpenVocabulary(true);
//
//        // create recommender
//        recommender = new VSMVirtualEditionInterRecommender();
//
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForHeteronym() {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            if (inter.getLastUsed().getHeteronym() != null) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = virtualEditionInter;
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertEquals(virtualEditionInter.getLastUsed().getHeteronym().getXmlId(), result.getLastUsed().getHeteronym().getXmlId());
//        assertEquals(1.0, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.001);
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForNoHeteronym() {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            if (getLastUsedScholarEditionInter(inter).getHeteronym().getName().equals("não atribuído")) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter);
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
////        assertEquals("NULL", result.getLastUsed().getHeteronym().getXmlId());
//        assertEquals("não atribuído", result.getLastUsed().getHeteronym().getName());
//
//        assertEquals(1.0, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.001);
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForDate() {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            if (inter.getLastUsed().getLdoDDate() != null
//                    && (inter.getLastUsed()).getLdoDDate().getDate().getYear() == 1929) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new DateProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter);
//
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertEquals(virtualEditionInter.getLastUsed().getLdoDDate().getDate().getYear(),
//                result.getLastUsed().getLdoDDate().getDate().getYear());
//        assertEquals(1.0, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.001);
//    }
//
//    @Test
//    @Atomic(mode = TxMode.WRITE)
//    public void testGetMostSimilarItemForNoDate() {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            if ((inter.getLastUsed()).getLdoDDate() == null) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new DateProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter);
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertNotNull(result.getLastUsed().getLdoDDate());
//        assertNull(virtualEditionInter.getLastUsed().getLdoDDate());
//        assertEquals(0.0, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.001);
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForTaxonomy() {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        CategoryDto category = new CategoryDto();
//        virtualEdition.getTaxonomy().createCategory("car");
////        category.init(virtualEdition.getTaxonomy(), "car");
//        VirtualEditionInterDto virtualEditionInter1 = null;
//        VirtualEditionInterDto virtualEditionInter2 = null;
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            GameRequiresInterface.getInstance().createTag(virtualEdition.getAcronym(), inter.getXmlId(), "car", "ars");
//            //            new Tag().init(inter, category, "ars");
//            if (virtualEditionInter1 == null) {
////                new Tag().init(inter, category, "ars");
//                GameRequiresInterface.getInstance().createTag(virtualEdition.getAcronym(), inter.getXmlId(), "car", "ars");
//                virtualEditionInter1 = inter;
//            } else if (virtualEditionInter2 == null
//                    && !inter.getFragmentXmlId().equals(virtualEditionInter1.getFragmentXmlId())) {
////                new Tag().init(inter, category, "ars");
//                GameRequiresInterface.getInstance().createTag(virtualEdition.getAcronym(), inter.getXmlId(), "car", "ars");
//                virtualEditionInter2 = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TaxonomyProperty(1.0, "LdoD-"+ACRONYM, Property.PropertyCache.OFF));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter1);
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertEquals((virtualEditionInter2), result);
//        assertEquals(1.0, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.001);
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForText() throws IOException, ParseException {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
////        Indexer indexer = Indexer.getIndexer();
//
//        List<String> tfidfWords = new ArrayList<>();
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
//            tfidfWords = RecommendationRequiresInterface.getInstance().getFragmentTFIDF(getFragment(inter).getXmlId(), TextProperty.NUMBER_OF_TERMS);
//            System.out.println(tfidfWords.get(0));
//            if (tfidfWords.contains("noite")) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new TextProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter);
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertEquals(0.01, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.1);
//    }
//
//    @Test
//    @Atomic
//    public void testGetMostSimilarItemForAll() throws IOException, ParseException {
//        pt.ist.socialsoftware.edition.recommendation.api.virtualDto.VirtualEditionDto virtualEdition = RecommendationRequiresInterface.getInstance().getVirtualEditionByAcronym("LdoD-" + ACRONYM);
//        VirtualEditionInterDto virtualEditionInter = null;
////        Indexer indexer = Indexer.getIndexer();
//
//        List<String> tfidfWords = new ArrayList<>();
//        for (VirtualEditionInterDto inter : virtualEdition.getIntersSet()) {
////            tfidfWords = indexer.getTFIDFTerms(getFragment(inter), TextProperty.NUMBER_OF_TERMS);
//            tfidfWords = RecommendationRequiresInterface.getInstance().getFragmentTFIDF(getFragment(inter).getXmlId(), TextProperty.NUMBER_OF_TERMS);
//            if (tfidfWords.contains("noite")) {
//                virtualEditionInter = inter;
//                break;
//            }
//        }
//
//        List<Property> properties = new ArrayList<>();
//        properties.add(new HeteronymProperty(1.0));
//        properties.add(new DateProperty(1.0));
//        properties.add(new TaxonomyProperty(1.0, "LdoD-" + ACRONYM, Property.PropertyCache.OFF));
//        properties.add(new TextProperty(1.0));
//
//        VirtualEditionInterDto virtualEditionInterDto = (virtualEditionInter);
//
//        VirtualEditionInterDto result = recommender.getMostSimilarItem(virtualEditionInterDto, new HashSet<>(virtualEdition
//                .getIntersSet()), properties);
//
//
//        assertFalse(virtualEditionInterDto.getXmlId().equals(result.getXmlId()));
//        assertEquals(virtualEditionInter.getLastUsed().getHeteronym().getXmlId(), result.getLastUsed().getHeteronym().getXmlId());
//        assertEquals(virtualEditionInter.getLastUsed().getLdoDDate().getDate().getYear(),
//                result.getLastUsed().getLdoDDate().getDate().getYear());
//
//        assertEquals(0.9, recommender.calculateSimilarity(virtualEditionInterDto, result, properties), 0.1);
//    }
//
//
////    private Fragment getFragment(VirtualEditionInter virtualEditionInter) {
////        return getLastUsedScholarEditionInter(virtualEditionInter).getFragment();
////    }
//
////    private ScholarInter getLastUsedScholarEditionInter(VirtualEditionInter virtualEditionInter) {
////        return TextModule.getInstance().getScholarInterByXmlId(virtualEditionInter.getLastUsed().getXmlId());
////    }
//
//    private FragmentDto getFragment(VirtualEditionInterDto virtualEditionInter) {
//        return getLastUsedScholarEditionInter(virtualEditionInter).getFragmentDto();
//    }
//
//private ScholarInterDto getLastUsedScholarEditionInter(VirtualEditionInterDto virtualEditionInter) {
//    return feTextRequiresInterface.getScholarInterByXmlId(virtualEditionInter.getLastUsed().getXmlId());
//}
//
//}



import org.springframework.core.ParameterizedTypeReference;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.HeteronymDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.event.Event;
import pt.ist.socialsoftware.edition.notification.event.EventInterface;
import pt.ist.socialsoftware.edition.notification.event.SubscribeInterface;

import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationModule;



import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.TEXT_SERVICE_URL;
import static pt.ist.socialsoftware.edition.notification.endpoint.ServiceEndpoints.VIRTUAL_SERVICE_URL;

@Component
public class RecommendationRequiresInterface implements SubscribeInterface {

    private final WebClient.Builder webClient = WebClient.builder().baseUrl(TEXT_SERVICE_URL);

    private static RecommendationRequiresInterface instance;

    public static RecommendationRequiresInterface getInstance() {
        if (instance == null) {
            instance = new RecommendationRequiresInterface();
        }
        return instance;
    }

    protected RecommendationRequiresInterface() {
    }

    @JmsListener(id = "3", containerFactory = "jmsListenerContainerFactory", destination = "test-topic")
    public void listener(Event message){
        this.notify(message);
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public void notify(Event event) {
        if (event.getType().equals(Event.EventType.USER_REMOVE)) {
            String username = event.getIdentifier();
            RecommendationModule recommendationModule = RecommendationModule.getInstance();

            recommendationModule.getRecommendationWeightsSet().stream()
                    .filter(recommendationWeights -> recommendationWeights.getUser().equals(username))
                    .forEach(recommendationWeights -> recommendationWeights.remove());
        } else if (event.getType().equals(Event.EventType.VIRTUAL_EDITION_REMOVE)) {
            String virtualEditionAcronym = event.getIdentifier();
            RecommendationModule recommendationModule = RecommendationModule.getInstance();

            recommendationModule.getRecommendationWeightsSet().stream()
                    .filter(recommendationWeights -> recommendationWeights.getVirtualEditionAcronym().equals(virtualEditionAcronym))
                    .forEach(recommendationWeights -> recommendationWeights.remove());
        }
    }

    // Uses Text Module
 //   private final TextProvidesInterface textProvidesInterface = new TextProvidesInterface();

    public Set<FragmentDto> getFragments() {
        return webClient.build()
                .get()
                .uri("/fragments")
                .retrieve()
                .bodyToFlux(FragmentDto.class)
                .toStream()
                .collect(Collectors.toSet());
        //  return this.textProvidesInterface.getFragmentDtoSet();
    }

    public List<HeteronymDto> getSortedHeteronymsList() {
      //  return this.textProvidesInterface.getSortedHeteronymList();
        return webClient.build()
                .get()
                .uri("/sortedHeteronyms")
                .retrieve()
                .bodyToFlux(HeteronymDto.class)
                .collectList()
                .block();
    }

    public Map<String, Double> getFragmentTFIDF(String xmlId, List<String> commonTerms) {
        return webClient.build().get()
                .uri( uriBuilder -> uriBuilder
                        .path("/fragment/" + xmlId + "/TFIDF")
                        .queryParam("terms", commonTerms)
                        .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Map<String, Double>>() {})
                .block();
        //   return this.textProvidesInterface.getFragmentTFIDF(xmlId, commonTerms);
    }

    public List<String> getFragmentTFIDF(String xmlId, int numberOfTerms) {
        return webClient.build().get()
                .uri( uriBuilder -> uriBuilder
                        .path("/fragment/" + xmlId + "/TFIDF")
                        .queryParam("numberOfTerms", numberOfTerms)
                        .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //  return this.textProvidesInterface.getFragmentTFIDF(xmlId, numberOfTerms);
    }

    public void cleanTermsTFIDFCache() {
         webClient.build()
                .get()
                .uri("/clearTermsTFIDFCache")
                .retrieve();
        //   this.textProvidesInterface.clearTermsTFIDFCache();
    }


    // Uses Virtual Module
    private final WebClient.Builder webClientVirtual = WebClient.builder().baseUrl(VIRTUAL_SERVICE_URL);


    public List<String> getVirtualEditionSortedCategoryList(String acronym) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym + "/sortedCategory")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getVirtualEditionSortedCategoryList(acronym);
    }

    public List<String> getFragmentCategoriesInVirtualEditon(String acronym, String xmlId) {
        return webClientVirtual.build()
                .get()
                .uri(uriBuilder -> uriBuilder
                    .path("/virtualEdition/" + acronym + "/fragmentCategories")
                    .queryParam("xmlId", xmlId)
                    .build())
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<String>>() {})
                .block();
        //        return this.virtualProvidesInterface.getFragmentCategoriesInVirtualEditon(acronym, xmlId);
    }

    public VirtualEditionDto getArchiveEdition() {
        return webClientVirtual.build()
                .get()
                .uri("/archiveVirtualEdition")
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
//        return this.virtualProvidesInterface.getArchiveVirtualEdition();
    }

    public VirtualEditionDto getVirtualEditionByAcronym(String acronym) {
        return webClientVirtual.build()
                .get()
                .uri("/virtualEdition/" + acronym)
                .retrieve()
                .bodyToMono(VirtualEditionDto.class)
                .block();
        //        return this.virtualProvidesInterface.getVirtualEdition(acronym);
    }

}


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import pt.ist.fenixframework.Atomic;

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.api.dto.PropertyDto;

import pt.ist.socialsoftware.edition.recommendation.api.dto.WeightsDto;
import pt.ist.socialsoftware.edition.recommendation.api.wrappers.IntersByDistance;
import pt.ist.socialsoftware.edition.recommendation.api.wrappers.MostSimilarFragments;
import pt.ist.socialsoftware.edition.recommendation.api.wrappers.RecommendationVirtualEditionInter;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationModule;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;
import pt.ist.socialsoftware.edition.recommendation.api.dto.InterIdDistancePairDto;
import pt.ist.socialsoftware.edition.recommendation.feature.VSMFragmentRecommender;
import pt.ist.socialsoftware.edition.recommendation.feature.VSMScholarInterRecommender;
import pt.ist.socialsoftware.edition.recommendation.feature.VSMVirtualEditionInterRecommender;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.TaxonomyProperty;
import pt.ist.socialsoftware.edition.recommendation.utils.RecommendationBootstrap;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api")
public class RecommendationProvidesInterface {
    private static final Logger logger = LoggerFactory.getLogger(RecommendationProvidesInterface.class);

    //private final RecommendationRequiresInterface recommendationRequiresInterface = new RecommendationRequiresInterface();

    @PostMapping("/scholarIntersByDistance")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<InterIdDistancePairDto> getScholarIntersByDistance(@RequestBody IntersByDistance wrapper) {
        logger.debug("getScholarIntersByDistance");
        ScholarInterDto scholarInterDto = wrapper.getScholarInterDto();
        WeightsDto weights = wrapper.getWeightsDto();

        List<ScholarInterDto> inters = scholarInterDto.getExpertEdition().getExpertEditionInters();

        VSMScholarInterRecommender recommender = new VSMScholarInterRecommender();

        inters.remove(scholarInterDto);

        List<InterIdDistancePairDto> recommendedEdition = new ArrayList<>();

        List<Property> properties = weights.getProperties();
        for (ScholarInterDto inter : inters) {
            recommendedEdition.add(new InterIdDistancePairDto(inter.getExternalId(),
                    recommender.calculateSimilarity(scholarInterDto, inter, properties)));
        }

        recommendedEdition = recommendedEdition.stream().sorted(Comparator.comparing(InterIdDistancePairDto::getDistance).reversed()).collect(Collectors.toList());
        recommendedEdition.add(0, new InterIdDistancePairDto(scholarInterDto.getExternalId(), 1.0d));

        return recommendedEdition;
    }

    @PostMapping("/virtualEditionIntersByDistance")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<InterIdDistancePairDto> geVirtualEditiontIntersByDistance(@RequestBody IntersByDistance wrapper) {
        logger.debug("virtualEditionIntersByDistance");
        VirtualEditionInterDto virtualEditionInterDto = wrapper.getVirtualEditionInterDto();
        WeightsDto weights = wrapper.getWeightsDto();

        VirtualEditionDto virtualEditionDto = virtualEditionInterDto.getVirtualEditionDto();

        List<VirtualEditionInterDto> inters = virtualEditionDto.getSortedVirtualEditionInterDtoList();

        VSMVirtualEditionInterRecommender recommender = new VSMVirtualEditionInterRecommender();

        inters.remove(virtualEditionInterDto);

        List<InterIdDistancePairDto> recommendedEdition = new ArrayList<>();

        List<Property> properties = weights.getProperties(virtualEditionDto.getAcronym());
        for (VirtualEditionInterDto inter : inters) {
            recommendedEdition.add(new InterIdDistancePairDto(inter.getExternalId(),
                    recommender.calculateSimilarity(virtualEditionInterDto, inter, properties)));
        }

        recommendedEdition = recommendedEdition.stream().sorted(Comparator.comparing(InterIdDistancePairDto::getDistance).reversed()).collect(Collectors.toList());

        recommendedEdition.add(0, new InterIdDistancePairDto(virtualEditionInterDto.getExternalId(), 1.0d));

        return recommendedEdition;
    }

    @PostMapping("/generateRecommendationFromVirtualEditionInter")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public List<VirtualEditionInterDto> generateRecommendationFromVirtualEditionInter(@RequestBody RecommendationVirtualEditionInter wrapper) {
        logger.debug("generateRecommendationFromVirtualEditionInter");
        VirtualEditionInterDto inter = wrapper.getInter();
        String username = wrapper.getUsername();
        VirtualEditionDto virtualEdition = wrapper.getVirtualEditionDto();
        List<Property> properties = wrapper.getProperties().stream().map(PropertyDto::getProperty).collect(Collectors.toList());

        List<VirtualEditionInterDto> recommendedEdition = new ArrayList<>();

        List<VirtualEditionInterDto> inters = virtualEdition.getSortedVirtualEditionInterDtoList();

        if (inters.isEmpty()) {
            return recommendedEdition;
        }

        VirtualEditionInterDto selected;
        RecommendationWeights recommendationWeights =
                RecommendationModule.getInstance().getRecommendationWeightsForUserInVirtualEdition(username, virtualEdition.getAcronym());
        if (inter == null) {
            selected = inters.get(0);
            recommendationWeights.setWeightsZero();

        } else {
            selected = inter;
            recommendationWeights.setWeights(properties);

        }

        inters.remove(selected);

        VSMVirtualEditionInterRecommender recommender = new VSMVirtualEditionInterRecommender();

        recommendedEdition.add(selected);
        recommendedEdition.addAll(recommender.getMostSimilarItemsAsList(selected, inters, recommendationWeights.getPropertiesWithStoredWeights()));

        return recommendedEdition;
    }

    @PostMapping("/mostSimilarFragmentsOfGivenFragment")
    @Atomic(mode = Atomic.TxMode.READ)
    public List<Map.Entry<FragmentDto, Double>> getMostSimilarFragmentsOfGivenFragment(@RequestBody MostSimilarFragments wrapper) {
        logger.debug("getMostSimilarFragmentsOfGivenFragment");
        FragmentDto toReadFragment = wrapper.getToReadFragment();
        Set<FragmentDto> toBeRecommended = wrapper.getToBeRecommended();
        WeightsDto weightsDto = wrapper.getWeightsDto();

        VSMFragmentRecommender recommender = new VSMFragmentRecommender();
        List<Property> properties = weightsDto.getProperties().stream().map(property -> {
            if (property instanceof TaxonomyProperty) {
                property.setCached(Property.PropertyCache.ON);
                return property;
            } else {
                return property;
            }
        }).collect(Collectors.toList());
        ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter();
        try {
            String json = ow.writeValueAsString(recommender.getMostSimilarItems(toReadFragment, toBeRecommended,
                    properties));
            logger.debug(json);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return recommender.getMostSimilarItems(toReadFragment, toBeRecommended,
                properties);
    }

    @PostMapping("/initializeRecommendationModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void initializeRecommendationModule() {
        logger.debug("initializeRecommendationModule");
        RecommendationBootstrap.initializeRecommendationModule();
    }

    @PostMapping("/loadRecommendationCache")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void loadRecommendationCache() {
        logger.debug("loadRecommendationCache");
        RecommendationBootstrap.loadRecommendationCache();
    }

    @PostMapping("/removeRecommendationModule")
    @Atomic(mode = Atomic.TxMode.WRITE)
    public void removeRecommendationModule() {
        RecommendationModule recommendationModule = RecommendationModule.getInstance();
        if (recommendationModule != null) {
            recommendationModule.remove();
        }
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.recommendation.api.dto.WeightsDto;

import java.util.Set;

public class MostSimilarFragments {

    private FragmentDto toReadFragment;
    private Set<FragmentDto> toBeRecommended;
    private WeightsDto weightsDto;

    public MostSimilarFragments(FragmentDto fragmentDto, Set<FragmentDto> fragmentDtos, WeightsDto weightsDto) {
        this.toReadFragment = fragmentDto;
        this.toBeRecommended = fragmentDtos;
        this.weightsDto = weightsDto;
    }

    public MostSimilarFragments() {}

    public FragmentDto getToReadFragment() {
        return toReadFragment;
    }

    public void setToReadFragment(FragmentDto toReadFragment) {
        this.toReadFragment = toReadFragment;
    }

    public Set<FragmentDto> getToBeRecommended() {
        return toBeRecommended;
    }

    public void setToBeRecommended(Set<FragmentDto> toBeRecommended) {
        this.toBeRecommended = toBeRecommended;
    }

    public WeightsDto getWeightsDto() {
        return weightsDto;
    }

    public void setWeightsDto(WeightsDto weightsDto) {
        this.weightsDto = weightsDto;
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.api.dto.WeightsDto;


public class IntersByDistance {

    private ScholarInterDto scholarInterDto;
    private WeightsDto weightsDto;
    private VirtualEditionInterDto virtualEditionInterDto;

    public IntersByDistance(ScholarInterDto scholarInterDto, WeightsDto weightsDto) {
        this.scholarInterDto = scholarInterDto;
        this.weightsDto = weightsDto;
    }

    public IntersByDistance(VirtualEditionInterDto virtualEditionInterDto, WeightsDto weightsDto) {
        this.virtualEditionInterDto = virtualEditionInterDto;
        this.weightsDto = weightsDto;
    }

    public IntersByDistance() {}

    public ScholarInterDto getScholarInterDto() {
        return scholarInterDto;
    }

    public void setScholarInterDto(ScholarInterDto scholarInterDto) {
        this.scholarInterDto = scholarInterDto;
    }

    public WeightsDto getWeightsDto() {
        return weightsDto;
    }

    public void setWeightsDto(WeightsDto weightsDto) {
        this.weightsDto = weightsDto;
    }

    public VirtualEditionInterDto getVirtualEditionInterDto() {
        return virtualEditionInterDto;
    }

    public void setVirtualEditionInterDto(VirtualEditionInterDto virtualEditionInterDto) {
        this.virtualEditionInterDto = virtualEditionInterDto;
    }
}


import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.api.dto.PropertyDto;

import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

import java.util.List;

public class RecommendationVirtualEditionInter {

    private VirtualEditionInterDto inter;
    private String username;
    private VirtualEditionDto virtualEditionDto;
    private List<PropertyDto> properties;

    public RecommendationVirtualEditionInter(VirtualEditionInterDto inter,
                                             String username,
                                             VirtualEditionDto virtualEdition,
                                             List<PropertyDto> properties) {
        this.inter = inter;
        this.username = username;
        this.virtualEditionDto = virtualEdition;
        this.properties = properties;
    }

    public RecommendationVirtualEditionInter() {}

    public VirtualEditionInterDto getInter() {
        return inter;
    }

    public void setInter(VirtualEditionInterDto inter) {
        this.inter = inter;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public VirtualEditionDto getVirtualEditionDto() {
        return virtualEditionDto;
    }

    public void setVirtualEditionDto(VirtualEditionDto virtualEditionDto) {
        this.virtualEditionDto = virtualEditionDto;
    }

    public List<PropertyDto> getProperties() {
        return properties;
    }

    public void setProperties(List<PropertyDto> properties) {
        this.properties = properties;
    }
}


import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;

public class RecommendVirtualEditionParam {
    private final String acronym;
    private final String id;
    private final List<PropertyDto> properties;

    public RecommendVirtualEditionParam(@JsonProperty("acronym") String acronym,
                                        @JsonProperty("id") String id,
                                        @JsonProperty("properties") List<PropertyDto> properties) {
        this.acronym = acronym;
        this.id = id;
        this.properties = properties;
    }

    public String getAcronym() {
        return this.acronym;
    }

    public String getId() {
        return this.id;
    }

    public List<PropertyDto> getProperties() {
        return this.properties;
    }

}

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;


@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "type")
@JsonSubTypes({@JsonSubTypes.Type(value = HeteronymPropertyDto.class, name = PropertyDto.HETERONYM),
        @JsonSubTypes.Type(value = DatePropertyDto.class, name = PropertyDto.DATE),
        @JsonSubTypes.Type(value = TextPropertyDto.class, name = PropertyDto.TEXT),
        @JsonSubTypes.Type(value = TaxonomyPropertyDto.class, name = PropertyDto.TAXONOMY)})
public abstract class PropertyDto {
    public static final String HETERONYM = "heteronym";
    public static final String DATE = "date";
    public static final String TEXT = "text";
    public static final String TAXONOMY = "taxonomy";

    protected final double weight;
    protected final String acronym;

    public PropertyDto(double weight, String acronym) {
        this.weight = weight;
        this.acronym = acronym;
    }

    public abstract Property getProperty();

    public abstract String getType();

    public double getWeight() {
        return this.weight;
    }

    public String getAcronym() {
        return this.acronym;
    }
}

public class InterIdDistancePairDto {
    private String interId;
    private double distance;

    public InterIdDistancePairDto(String interId, double distance) {
        this.interId = interId;
        this.distance = distance;
    }

    public InterIdDistancePairDto() {
    }

    public String getInterId() {
        return this.interId;
    }

    public void setInter(String interId) {
        this.interId = interId;
    }

    public double getDistance() {
        return this.distance;
    }

    public void setDistance(double distance) {
        this.distance = distance;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.TextProperty;

public class TextPropertyDto extends PropertyDto {
    public TextPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

    @Override
    public Property getProperty() {
        return new TextProperty(this.weight);
    }

    @Override
    public String getType() {
        return TEXT;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.DateProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

public class DatePropertyDto extends PropertyDto {

    public DatePropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

    @Override
    public Property getProperty() {
        return new DateProperty(this.weight);
    }

    @Override
    public String getType() {
        return DATE;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.TaxonomyProperty;

public class TaxonomyPropertyDto extends PropertyDto {

    public TaxonomyPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

    @Override
    public Property getProperty() {
        return new TaxonomyProperty(this.weight, this.acronym);
    }

    @Override
    public String getType() {
        return PropertyDto.TAXONOMY;
    }
}



import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;

import java.util.ArrayList;
import java.util.List;

public class WeightsDto {
    private float heteronymWeight;
    private float dateWeight;
    private float textWeight;
    private float taxonomyWeight;

    public WeightsDto() {
    }

    public WeightsDto(float heteronymWeight, float dateWeight, float textWeight, float taxonomyWeight) {
        this.heteronymWeight = heteronymWeight;
        this.dateWeight = dateWeight;
        this.textWeight = textWeight;
        this.taxonomyWeight = taxonomyWeight;
    }

    public List<Property> getProperties() {
        List<Property> result = new ArrayList<>();
        if (getHeteronymWeight() > 0.0) {
            result.add(new HeteronymProperty(getHeteronymWeight()));
        }
        if (getDateWeight() > 0.0) {
            result.add(new DateProperty(getDateWeight()));
        }
        if (getTextWeight() > 0.0) {
            result.add(new TextProperty(getTextWeight()));
        }

        return result;
    }

    public List<Property> getProperties(String editionAcronym) {
        List<Property> result = getProperties();

        if (getTaxonomyWeight() > 0.0) {
            result.add(new TaxonomyProperty(getTaxonomyWeight(), editionAcronym,
                    Property.PropertyCache.OFF));
        }

        return result;
    }


    public float getHeteronymWeight() {
        return this.heteronymWeight;
    }

    public void setHeteronymWeight(float heteronymWeight) {
        this.heteronymWeight = heteronymWeight;
    }

    public float getDateWeight() {
        return this.dateWeight;
    }

    public void setDateWeight(float dateWeight) {
        this.dateWeight = dateWeight;
    }

    public float getTextWeight() {
        return this.textWeight;
    }

    public void setTextWeight(float textWeight) {
        this.textWeight = textWeight;
    }

    public float getTaxonomyWeight() {
        return this.taxonomyWeight;
    }

    public void setTaxonomyWeight(float taxonomyWeight) {
        this.taxonomyWeight = taxonomyWeight;
    }

}


import com.fasterxml.jackson.annotation.JsonProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.HeteronymProperty;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

public class HeteronymPropertyDto extends PropertyDto {

    public HeteronymPropertyDto(@JsonProperty("weight") String weight, @JsonProperty("acronym") String acronym) {
        super(Double.parseDouble(weight), acronym);
    }

    @Override
    public Property getProperty() {
        return new HeteronymProperty(this.weight);
    }

    @Override
    public String getType() {
        return HETERONYM;
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationModule;
import pt.ist.socialsoftware.edition.recommendation.feature.VSMFragmentRecommender;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class RecommendationBootstrap {
    private static final Logger logger = LoggerFactory.getLogger(RecommendationBootstrap.class);
    public static final String ARCHIVE_EDITION_ACRONYM = "LdoD-Arquivo";



    public static void initializeRecommendationModule() {
        boolean recommendationCreate = false;
        if (RecommendationModule.getInstance() == null) {
            new RecommendationModule();
            recommendationCreate = true;
        } else {
            loadRecommendationCache();
        }
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public static void loadRecommendationCache() {
        //RecommendationRequiresInterface recommendationRequiresInterface = new RecommendationRequiresInterface();
        Set<FragmentDto> fragments = RecommendationRequiresInterface.getInstance().getFragments();

        if (fragments.size() > 800) {
            List<Property> properties = new ArrayList<>();
            properties.add(new TextProperty(1.0));
            properties.add(new HeteronymProperty(1.0));
            properties.add(new DateProperty(1.0));
            properties.add(new TaxonomyProperty(1.0, ARCHIVE_EDITION_ACRONYM,
                    Property.PropertyCache.ON));

            VSMFragmentRecommender recommender = new VSMFragmentRecommender();
            for (FragmentDto fragment : fragments) {
                logger.debug("loadRecommendationCache xmlId:{}", fragment.getXmlId());
                recommender.getMostSimilarItem(fragment, fragments, properties);
            }
        }

        RecommendationRequiresInterface.getInstance().cleanTermsTFIDFCache();
    }

}


import org.apache.activemq.ActiveMQConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration
@EnableJms
public class ConsumerConfig {


//    @Value("${activemqbrokerurl}")
//    private String brokerUrl;

    @Primary
    @Bean
    public ActiveMQConnectionFactory activeMQConnectionFactory() {
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
//        activeMQConnectionFactory.setBrokerURL("tcp://localhost:61616");
        activeMQConnectionFactory.setBrokerURL("tcp://activemq:61616");
        activeMQConnectionFactory.setTrustAllPackages(true);
        return activeMQConnectionFactory;
    }

    @Primary
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(activeMQConnectionFactory());
        factory.setPubSubDomain(true);
        return factory;
    }
}

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.jms.annotation.EnableJms;


@PropertySource({"classpath:application.properties", "classpath:specific.properties", "classpath:secrete.properties"})
@ComponentScan(basePackages = "pt.ist.socialsoftware.edition.recommendation")
@SpringBootApplication
@Configuration
@EnableJms
public class RecommendationApplication extends SpringBootServletInitializer implements InitializingBean {

    public static void main(String[] args) {
        SpringApplication.run(RecommendationApplication.class, args);
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        return new Jackson2ObjectMapperBuilder().serializationInclusion(JsonInclude.Include.NON_NULL).build();
    }

    @Override
    public void afterPropertiesSet() throws Exception {

    }

    @Bean
    public ActiveMQTopic queue(){
        return new ActiveMQTopic("test-topic");
    }
}


import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

@Service
public class BeanUtil implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }

}


import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.Atomic.TxMode;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.*;

import java.util.ArrayList;
import java.util.List;

public class RecommendationWeights extends RecommendationWeights_Base {

    public RecommendationWeights(String user, String virtualEditionAcronym) {
        setUser(user);
        setVirtualEditionAcronym(virtualEditionAcronym);
        setHeteronymWeight(0.);
        setDateWeight(0.);
        setTextWeight(0.);
        setTaxonomyWeight(0.);

        setRecommendationModule(RecommendationModule.getInstance());
    }

    @Atomic(mode = TxMode.WRITE)
    public void remove() {
        setRecommendationModule(null);

        deleteDomainObject();
    }

    @Atomic(mode = TxMode.WRITE)
    public void setWeightsZero() {
        setHeteronymWeight(0.);
        setDateWeight(0.);
        setTextWeight(0.);
        setTaxonomyWeight(0.);
    }

    @Atomic(mode = TxMode.WRITE)
    public void setWeights(List<Property> properties) {
        for (Property property : properties) {
            property.userWeight(this);
        }
    }

    public List<Property> getPropertiesWithStoredWeights() {
        List<Property> result = new ArrayList<>();
        if (getHeteronymWeight() > 0.0) {
            result.add(new HeteronymProperty(getHeteronymWeight()));
        }
        if (getDateWeight() > 0.0) {
            result.add(new DateProperty(getDateWeight()));
        }
        if (getTextWeight() > 0.0) {
            result.add(new TextProperty(getTextWeight()));
        }
        if (getTaxonomyWeight() > 0.0) {
            result.add(new TaxonomyProperty(getTaxonomyWeight(), getVirtualEditionAcronym(),
                    Property.PropertyCache.OFF));
        }

        return result;
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.fenixframework.Atomic;
import pt.ist.fenixframework.FenixFramework;
import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;

public class RecommendationModule extends RecommendationModule_Base {
    private static final Logger log = LoggerFactory.getLogger(RecommendationModule.class);

    public static RecommendationModule getInstance() {
        return FenixFramework.getDomainRoot().getRecommendationModule();
    }

    public RecommendationModule() {
        FenixFramework.getDomainRoot().setRecommendationModule(this);
        RecommendationRequiresInterface.getInstance();
    }

    public void remove() {
        getRecommendationWeightsSet().forEach(RecommendationWeights::remove);

        setRoot(null);

        deleteDomainObject();
    }

    public RecommendationWeights getRecommendationWeightsForUserInVirtualEdition(String user, String virtualEditionAcronym) {
        for (RecommendationWeights recommendationWeights : getRecommendationWeightsSet()) {
            if (recommendationWeights.getUser().equals(user)
                    && recommendationWeights.getVirtualEditionAcronym().equals(virtualEditionAcronym)) {
                return recommendationWeights;
            }
        }
        return createRecommendationWeightsForUser(user, virtualEditionAcronym);
    }

    @Atomic(mode = Atomic.TxMode.WRITE)
    public RecommendationWeights createRecommendationWeightsForUser(String user, String virtualEditionAcronym) {
        return new RecommendationWeights(user, virtualEditionAcronym);
    }


}


import org.jblas.DoubleMatrix;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Vectors {
    private static final Logger logger = LoggerFactory.getLogger(Vectors.class);

    public static double calculateSimilarity(double[] t1, double[] t2) {
        if (t1 == null || t2 == null) {
            return 0.0;
        }

        DoubleMatrix matrix1 = new DoubleMatrix(t1);
        DoubleMatrix matrix2 = new DoubleMatrix(t2);
        double dotProduct = matrix1.dot(matrix2);
        double eucledianDist = matrix1.norm2() * matrix2.norm2();

        // if ((eucledianDist == 0 ? 0 : dotProduct / eucledianDist) > 0.5) {
        // logger.debug("calculateSimilarity v1:{}", t1);
        // logger.debug("calculateSimilarity v2:{}", t2);
        // logger.debug("calculateSimilarity dot:{}, euc:{}, sim:{}",
        // dotProduct, eucledianDist,
        // eucledianDist == 0 ? 0 : dotProduct / eucledianDist);
        // }

        return eucledianDist == 0 ? 0 : dotProduct / eucledianDist;
    }

}

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

public class VSMFragmentRecommender extends VSMRecommender<FragmentDto> {

    @Override
    protected void prepareToLoadProperty(FragmentDto t1, FragmentDto t2, Property property) {
        property.prepareToLoadProperty(t1, t2);
    }

    @Override
    protected double[] loadProperty(FragmentDto t1, Property property) {
        return property.loadProperty(t1);
    }

}

import java.util.Collection;
import java.util.List;
import java.util.Map;

public interface Recommender<T, P> {

    double calculateSimilarity(T t1, T t2, Collection<P> ps);

    T getMostSimilarItem(T t, Collection<T> ts, Collection<P> ps);

    List<Map.Entry<T, Double>> getMostSimilarItems(T t, Collection<T> ts, Collection<P> ps);

}

import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;


public class VSMVirtualEditionInterRecommender extends VSMRecommender<VirtualEditionInterDto> {
    @Override
    protected void prepareToLoadProperty(VirtualEditionInterDto t1, VirtualEditionInterDto t2, Property property) {
        property.prepareToLoadProperty(t1, t2);
    }

    @Override
    protected double[] loadProperty(VirtualEditionInterDto t1, Property property) {
        return property.loadProperty(t1);
    }

}

import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;


public class VSMScholarInterRecommender extends VSMRecommender<ScholarInterDto> {
    @Override
    protected void prepareToLoadProperty(ScholarInterDto t1, ScholarInterDto t2, Property property) {
        property.prepareToLoadProperty(t1, t2);
    }

    @Override
    protected double[] loadProperty(ScholarInterDto t1, Property property) {
        return property.loadProperty(t1);
    }

}


import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class StoredVectors {
    private static StoredVectors instance = new StoredVectors();

    // thread safe
    public static StoredVectors getInstance() {
        return instance;
    }

    public static void cleanCache() {
        instance = new StoredVectors();
    }

    private final Map<Class<? extends Property>, Map<String, double[]>> weights;

    private StoredVectors() {
        this.weights = new ConcurrentHashMap<>();
    }

    public boolean contains(Property property, String id) {
        if (this.weights.containsKey(property.getClass())) {
            if (this.weights.get(property.getClass()).containsKey(id)) {
                return true;
            }
        }
        return false;
    }

    public double[] get(Property property, String id) {
        if (this.weights.containsKey(property.getClass())) {
            if (this.weights.get(property.getClass()).containsKey(id)) {
                return this.weights.get(property.getClass()).get(id);
            }
        }
        return null;
    }

    public void put(Property property, String id, double[] weightCollection) {
        if (!this.weights.containsKey(property.getClass())) {
            this.weights.put(property.getClass(), new ConcurrentHashMap<>());
        }
        this.weights.get(property.getClass()).put(id, weightCollection);
    }

}


import org.apache.commons.lang.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ist.socialsoftware.edition.recommendation.feature.properties.Property;

import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

public abstract class VSMRecommender<T> implements Recommender<T, Property> {
    private static final Logger logger = LoggerFactory.getLogger(VSMRecommender.class);

    public static final int NUMBER_OF_RECOMMENDATIONS = 5;

    protected static final Random RANDOM = new Random();

    protected abstract void prepareToLoadProperty(T item1, T item2, Property property);

    protected abstract double[] loadProperty(T item1, Property property);

    @Override
    public double calculateSimilarity(T item1, T item2, Collection<Property> ps) {
        double[] vector1 = null;
        double[] vector2 = null;
        for (Property property : ps) {
            prepareToLoadProperty(item1, item2, property);
            vector1 = ArrayUtils.addAll(vector1, loadProperty(item1, property));
            vector2 = ArrayUtils.addAll(vector2, loadProperty(item2, property));
        }
        return Vectors.calculateSimilarity(vector1, vector2);
    }

    @Override
    public T getMostSimilarItem(T item, Collection<T> items, Collection<Property> properties) {
        T result = null;
        double max = Double.NEGATIVE_INFINITY;
        double similarity;
        for (T otherItem : items) {
            if (!otherItem.equals(item)) {
                similarity = calculateSimilarity(item, otherItem, properties);
                if (similarity > max) {
                    result = otherItem;
                    max = similarity;
                }
            }
        }
        return result;
    }

    @Override
    public List<Entry<T, Double>> getMostSimilarItems(T item, Collection<T> items, Collection<Property> properties) {
        double similarity;
        Map<T, Double> map = new HashMap<>();
        for (T otherItem : items) {
            if (!otherItem.equals(item)) {
                similarity = calculateSimilarity(item, otherItem, properties);
                if (similarity >= Double.NEGATIVE_INFINITY) {
                    map.put(otherItem, similarity);
                }
            }
        }

        return map.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))
                .collect(Collectors.toList());
    }

    public List<T> getMostSimilarItemsAsList(T item, Collection<T> items, List<Property> properties) {
        List<T> result = new ArrayList<>();
        T nextItem = item;
        while (!items.isEmpty()) {
            nextItem = getMostSimilarItem(nextItem, items, properties);
            result.add(nextItem);
            items.remove(nextItem);
        }

        // for (Entry<T, Double> entry : getMostSimilarItems(item, items,
        // properties)) {
        // inters.add(entry.getKey());
        // }

        return result;
    }

}


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;


import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TaxonomyProperty extends Property {
    private static final Logger logger = LoggerFactory.getLogger(TaxonomyProperty.class);

    private final String acronym;
    private List<String> sortedCategories = null;

    private static final Map<String, List<String>> categoriesCache = new HashMap<>();

    public TaxonomyProperty(double weight, String acronym, PropertyCache cached) {
        super(weight, cached);
        this.acronym = acronym;
        this.sortedCategories = this.recommendationRequiresInterface.getVirtualEditionSortedCategoryList(acronym);
    }

    public TaxonomyProperty(double weight, String acronym) {
        super(weight, PropertyCache.OFF);
        this.acronym = acronym;
        this.sortedCategories = this.recommendationRequiresInterface.getVirtualEditionSortedCategoryList(acronym);
    }

    @Override
    double[] extractVector(ScholarInterDto scholarInterDto) {
        return new double[0];
    }

    @Override
    protected double[] extractVector(VirtualEditionInterDto inter) {
        double[] vector = getDefaultVector();
        for (String category : getCategoriesFromCache(inter)) {
            if (this.sortedCategories.contains(category)) {
                vector[this.sortedCategories.indexOf(category)] = 1.0;
            }
        }
        return vector;
    }

    @Override
    public double[] extractVector(FragmentDto fragment) {
        double[] vector = getDefaultVector();
        for (String category : this.recommendationRequiresInterface.getFragmentCategoriesInVirtualEditon(this.acronym, fragment.getXmlId())) {
            if (this.sortedCategories.contains(category)) {
                vector[this.sortedCategories.indexOf(category)] = 1.0;
            }
        }
        return vector;
    }

    @Override
    protected double[] getDefaultVector() {
        return new double[this.sortedCategories.size()];
    }

    @Override
    public void userWeight(RecommendationWeights recommendationWeights) {
        recommendationWeights.setTaxonomyWeight(getWeight());
    }

    private List<String> getCategoriesFromCache(VirtualEditionInterDto interDto) {
        List<String> categories = categoriesCache.get(interDto.getXmlId());
        if (categories == null) {
            categories = interDto.getSortedCategoriesName();
            categoriesCache.put(interDto.getXmlId(), categories);
        }
        return categories;
    }

}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;



import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TextProperty extends Property {
    private static final Logger logger = LoggerFactory.getLogger(TextProperty.class);

    public static final int NUMBER_OF_TERMS = 100;
    public static final int NUMBER_OF_TERMS_TO_SHOW = 3;

    private static final Map<String, Map<String, double[]>> vectorsCache = new ConcurrentHashMap<>();
    private static final Map<String, FragmentDto> fragmentsCache = new HashMap<>();
    private static final Map<String, List<String>> commonTermsTFIDFCache = new ConcurrentHashMap<>();
    private static final Map<String, Map<String, Double>> TFIDFCache = new ConcurrentHashMap<>();


    private List<String> commonTerms;

    private FragmentDto fragment1;
    private FragmentDto fragment2;

    public TextProperty(double weigth) {
        super(weigth, PropertyCache.OFF);
    }

    @Override
    public void prepareToLoadProperty(ScholarInterDto inter1, ScholarInterDto inter2) {
        prepareToLoadProperty(getFragmentFromCache(inter1), getFragmentFromCache(inter2));
    }

    @Override
    public void prepareToLoadProperty(VirtualEditionInterDto inter1, VirtualEditionInterDto inter2) {
        prepareToLoadProperty(inter1.getLastUsed(), inter2.getLastUsed());
    }

    @Override
    public void prepareToLoadProperty(FragmentDto fragment1, FragmentDto fragment2) {
        this.fragment1 = fragment1;
        this.fragment2 = fragment2;
        double[] vector = getFromVectorsCache(fragment1);
        if (vector == null) {
            vector = generateFragmentVector(fragment1);
            putIntoVectorsCache(fragment1, vector);
        }
        vector = getFromVectorsCache(fragment2);
        if (vector == null) {
            vector = generateFragmentVector(fragment2);
            putIntoVectorsCache(fragment2, vector);
        }
    }

    private double[] buildVector(Map<String, Double> tfidf) {
        double[] vector = new double[this.commonTerms.size()];
        for (int i = 0; i < vector.length; i++) {
            String term = this.commonTerms.get(i);
            if (tfidf.containsKey(term)) {
                vector[i] = tfidf.get(term);
            }
        }
        return vector;
    }

    @Override
    protected double[] extractVector(ScholarInterDto scholarInter) {
        return extractVector(getFragmentFromCache(scholarInter));
        //        return extractVector(scholarInter.getFragmentDto());
    }

    @Override
    protected double[] extractVector(VirtualEditionInterDto virtualEditionInter) {
        return extractVector(virtualEditionInter.getLastUsed());
    }

    @Override
    protected double[] extractVector(FragmentDto fragment) {
        return getFromVectorsCache(fragment);
    }

    private double[] getFromVectorsCache(FragmentDto fragment) {
        FragmentDto fragmentOther = fragment.getXmlId().equals(this.fragment1.getXmlId()) ? this.fragment2 : this.fragment1;
        Map<String, double[]> map = vectorsCache.get(fragment.getXmlId());
        if (map == null) {
            return null;
        }
        double[] tmp = map.get(fragmentOther.getXmlId());
        return tmp;
    }

    private void putIntoVectorsCache(FragmentDto fragment, double[] vector) {
        FragmentDto fragmentOther = fragment.getXmlId().equals(this.fragment1.getXmlId()) ? this.fragment2 : this.fragment1;
        Map<String, double[]> map = vectorsCache.get(fragment.getXmlId());
        if (map == null) {
            map = new ConcurrentHashMap<>();
            vectorsCache.put(fragment.getXmlId(), map);
        }
        map.put(fragmentOther.getXmlId(), vector);
    }

    private double[] generateFragmentVector(FragmentDto fragment) {
        this.commonTerms = getFragmentsCommonTerms(this.fragment1, this.fragment2);

//        Map<String, Double> tfidf = this.recommendationRequiresInterface.getFragmentTFIDF(fragment.getXmlId(), this.commonTerms);
        Map<String, Double> tfidf = getFragmentTFIDF(fragment, this.commonTerms);

        return buildVector(tfidf);
    }

    private Map<String, Double> getFragmentTFIDF(FragmentDto fragment, List<String> commonTerms) {
        String id = fragment.getExternalId();
        if (TFIDFCache.containsKey(id)) {
            Map<String, Double> TFIDFMap = new HashMap<>(TFIDFCache.get(id));
            TFIDFMap.keySet().retainAll(commonTerms);
            return TFIDFMap;
        }
        Map<String, Double> tfidf = this.recommendationRequiresInterface.getFragmentTFIDF(fragment.getXmlId(), commonTerms);
        TFIDFCache.put(id, tfidf);
        return tfidf;
    }

    private List<String> getFragmentsCommonTerms(FragmentDto fragment1, FragmentDto fragment2) {
        List<String> result = new ArrayList<>();
        result.addAll(getCommonTermsFromCache(fragment1.getXmlId()));
        result.addAll(getCommonTermsFromCache(fragment2.getXmlId()));

        return result;
    }

    private FragmentDto getFragmentFromCache(ScholarInterDto scholarInterDto) {
        FragmentDto fragmentDto = fragmentsCache.get(scholarInterDto.getXmlId());
        if (fragmentDto == null) {
            fragmentDto = scholarInterDto.getFragmentDto();
            fragmentsCache.put(scholarInterDto.getXmlId(), fragmentDto);
        }
        return fragmentDto;
    }

    private List<String> getCommonTermsFromCache(String xmlId) {
        List<String> commonTerms = commonTermsTFIDFCache.get(xmlId);
        if (commonTerms == null) {
            commonTerms = this.recommendationRequiresInterface.getFragmentTFIDF(xmlId, NUMBER_OF_TERMS);
            commonTermsTFIDFCache.put(xmlId, commonTerms);
        }
        return commonTerms;
    }

    @Override
    protected double[] getDefaultVector() {
        return new double[this.commonTerms.size()];
    }

    @Override
    public void userWeight(RecommendationWeights recommendationWeights) {
        recommendationWeights.setTextWeight(getWeight());
    }

}


import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;
import pt.ist.socialsoftware.edition.recommendation.api.RecommendationRequiresInterface;
import pt.ist.socialsoftware.edition.recommendation.feature.StoredVectors;




public abstract class Property {
    protected RecommendationRequiresInterface recommendationRequiresInterface = RecommendationRequiresInterface.getInstance();

    public enum PropertyCache {
        ON, OFF
    }

    private final double weight;

    private PropertyCache cached;

    public Property(double weight, PropertyCache cached) {
        this.weight = weight;
        this.cached = cached;
    }

    abstract double[] getDefaultVector();

    public abstract void userWeight(RecommendationWeights recommendationWeights);

    abstract double[] extractVector(ScholarInterDto scholarInterDto);

    abstract double[] extractVector(VirtualEditionInterDto virtualEditionInter);

    abstract double[] extractVector(FragmentDto fragmnet);

    public void prepareToLoadProperty(ScholarInterDto t1, ScholarInterDto t2) {
    }

    public void prepareToLoadProperty(VirtualEditionInterDto virtualEditionInter1,
                                      VirtualEditionInterDto virtualEditionInter2) {
    }

    public void prepareToLoadProperty(FragmentDto fragment1, FragmentDto fragment2) {
    }

    private double[] applyWeights(double[] vector, double weight) {
        double[] result = new double[vector.length];
        if (weight == 1.0) {
            return vector;
        } else if (weight == 0.0) {
            return result;
        } else {
            for (int i = 0; i < vector.length; i++) {
                result[i] = vector[i] * weight;
            }
            return result;
        }
    }

    public final double[] loadProperty(ScholarInterDto scholarInterDto) {
        if (this.cached.equals(PropertyCache.ON)) {
            String interXmlId = scholarInterDto.getXmlId();
            double[] vector = StoredVectors.getInstance().get(this, interXmlId);
            if (vector == null) {
                vector = extractVector(scholarInterDto);
                StoredVectors.getInstance().put(this, interXmlId, vector);
            }
            return applyWeights(vector, getWeight());
        } else {
            return applyWeights(extractVector(scholarInterDto), getWeight());
        }
    }

    public final double[] loadProperty(VirtualEditionInterDto virtualEditionInter) {
        if (this.cached.equals(PropertyCache.ON)) {
            String xmlId = virtualEditionInter.getUsesScholarInterId();
            double[] vector = StoredVectors.getInstance().get(this, xmlId);
            if (vector == null) {
                vector = extractVector(virtualEditionInter);
                StoredVectors.getInstance().put(this, xmlId, vector);
            }
            return applyWeights(vector, getWeight());
        } else {
            return applyWeights(extractVector(virtualEditionInter), getWeight());
        }
    }

    public final double[] loadProperty(FragmentDto fragment) {
        if (this.cached.equals(PropertyCache.ON)) {
            double[] vector = StoredVectors.getInstance().get(this, fragment.getXmlId());
            if (vector == null) {
                vector = extractVector(fragment);
                StoredVectors.getInstance().put(this, fragment.getExternalId(), vector);
            }
            return applyWeights(vector, getWeight());
        } else {
            return applyWeights(extractVector(fragment), getWeight());
        }
    }

    public double getWeight() {
        return this.weight;
    }

    public void setCached(PropertyCache cached) {
        this.cached = cached;
    }


}


import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.HeteronymDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;




import java.util.ArrayList;
import java.util.List;

public class HeteronymProperty extends Property {
    private final List<HeteronymDto> heteronymList = this.recommendationRequiresInterface.getSortedHeteronymsList();

    public HeteronymProperty(double weight) {
        super(weight, PropertyCache.ON);
    }

    private double[] buildVector(List<String> foundHeteronyms) {
        double[] vector = getDefaultVector();
        int i = 0;
        for (HeteronymDto heteronym : this.heteronymList) {
            if (foundHeteronyms.contains(heteronym.getName())) {
                vector[i] = 1.0;
            } else {
                vector[i] = 0.0;
            }
            i++;
        }
        return vector;
    }

    @Override
    double[] extractVector(ScholarInterDto scholarInterDto) {
        List<String> foundHeteronyms = new ArrayList<>();

        foundHeteronyms.add(scholarInterDto.getHeteronym().getName());

        return buildVector(foundHeteronyms);
    }

    @Override
    public double[] extractVector(VirtualEditionInterDto virtualEditionInter) {
        List<String> foundHeteronyms = new ArrayList<>();

        foundHeteronyms.add(virtualEditionInter.getLastUsed().getHeteronym().getName());

        return buildVector(foundHeteronyms);
    }

    @Override
    public double[] extractVector(FragmentDto fragment) {
        List<String> foundHeteronyms = new ArrayList<>();
        for (ScholarInterDto inter : fragment.getScholarInterDtoSet()) {
            foundHeteronyms.add(inter.getHeteronym().getName());
        }
        for (SourceDto source : fragment.getSourcesSet()) {
            foundHeteronyms.add(source.getHeteronym().getName());
        }
        return buildVector(foundHeteronyms);
    }

    @Override
    protected double[] getDefaultVector() {
        return new double[this.heteronymList.size()];
    }

    @Override
    public void userWeight(RecommendationWeights recommendationWeights) {
        recommendationWeights.setHeteronymWeight(getWeight());
    }

}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pt.ist.socialsoftware.edition.notification.dtos.text.FragmentDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.ScholarInterDto;
import pt.ist.socialsoftware.edition.notification.dtos.text.SourceDto;
import pt.ist.socialsoftware.edition.notification.dtos.virtual.VirtualEditionInterDto;
import pt.ist.socialsoftware.edition.recommendation.domain.RecommendationWeights;




import java.util.HashSet;
import java.util.Set;

public class DateProperty extends Property {
    private static final Logger logger = LoggerFactory.getLogger(DateProperty.class);

    private static final Integer STARTYEAR = 1913;
    private static final Integer ENDYEAR = 1934;

    private static int getNumberOfYears() {
        return ENDYEAR - STARTYEAR + 1;
    }

    public DateProperty(double weight) {
        super(weight, PropertyCache.ON);
    }

    private double[] addDateToVector(int date, double[] vector) {
        int start = date - STARTYEAR;
        // double degree = 1.0 / vector.size();
        double degree = 0.1;
        double j = 1.0;
        for (int i = start; i >= 0 && j > 0 && i < vector.length - 1 && j >= vector[i]; i--, j -= degree) {
            vector[i] = j;
        }
        j = 1.0;
        for (int i = start; i < vector.length - 1 && j > 0 && j >= vector[i]; i++, j -= degree) {
            vector[i] = j;
        }
        return vector;
    }

    private double[] buildVector(Set<Integer> dates) {
        double[] vector = getDefaultVector();

        if (dates.isEmpty()) {
            vector[vector.length - 1] = 1.0;

            return vector;
        }

        for (int date : dates) {
            addDateToVector(date, vector);
        }
        return vector;
    }

    @Override
    double[] extractVector(ScholarInterDto scholarInterDto) {
        Set<Integer> dates = new HashSet<>();
        if (scholarInterDto.getLdoDDate() != null) {
            dates.add(scholarInterDto.getLdoDDate().getDate().getYear());
        }
        return buildVector(dates);
    }

    @Override
    double[] extractVector(VirtualEditionInterDto virtualEditionInter) {
        Set<Integer> dates = new HashSet<>();
        ScholarInterDto scholarInterDto = virtualEditionInter.getLastUsed();
        if (scholarInterDto.getLdoDDate() != null) {
            dates.add(scholarInterDto.getLdoDDate().getDate().getYear());
        }
        return buildVector(dates);
    }

    @Override
    double[] extractVector(FragmentDto fragment) {
        Set<Integer> dates = new HashSet<>();
        for (ScholarInterDto inter : fragment.getScholarInterDtoSet()) {
            if (inter.getLdoDDate() != null) {
                dates.add(inter.getLdoDDate().getDate().getYear());
            }
        }
        for (SourceDto source : fragment.getSourcesSet()) {
            if (source.getLdoDDate() != null) {
                dates.add(source.getLdoDDate().getDate().getYear());
            }
        }
        return buildVector(dates);
    }

    @Override
    protected double[] getDefaultVector() {
        return new double[getNumberOfYears() + 1];
    }

    @Override
    public void userWeight(RecommendationWeights recommendationWeights) {
        recommendationWeights.setDateWeight(getWeight());
    }

}
